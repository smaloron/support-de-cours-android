# Module 14 : Architecture d'Application : Le Pattern MVVM

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Expliquer les problèmes du code "spaghetti" et la nécessité d'une architecture.
* Définir les responsabilités de chaque couche du pattern MVVM : View, ViewModel, et Model (Repository).
* Comprendre le principe de la séparation des préoccupations (Separation of Concerns).
* Mettre en place le composant `ViewModel` d'Android Jetpack et comprendre son cycle de vie distinct.

### Introduction

Vous vous souvenez de notre compteur dans le module 4 ? Quand on tournait l'écran, le compte revenait à zéro. Pourquoi ?
Parce que l'état (la variable `counter`) était stocké dans l'Activity, et que l'Activity était détruite et recréée.
C'était un cauchemar à gérer. De plus, si nous avions ajouté de la logique (sauvegarder le score, le comparer...), tout
aurait été mélangé dans le fichier de l'Activity, créant un plat de "spaghetti" indigeste.

L'architecture **MVVM** est la recette qui nous sauve de ce chaos. C'est un modèle qui sépare notre code en trois
couches distinctes, comme un gâteau à trois étages. Chaque étage a un rôle précis et ne communique qu'avec l'étage
directement adjacent. C'est cette séparation stricte qui résout nos problèmes de perte d'état et rend notre code propre,
testable et maintenable.

### Notions abordées

* Pourquoi une Architecture ? Le problème du code "spaghetti".
* Les Rôles du MVVM (Model-View-ViewModel).
* Le composant `ViewModel` d'Android Jetpack.

---

### Pourquoi une Architecture ?

#### Introduction à la notion

Avez-vous déjà essayé de démêler un énorme nœud d'écouteurs ? C'est frustrant, long, et on risque de tout casser. Le
code sans architecture, c'est exactement ça. Tout est emmêlé : la logique de l'interface, la logique métier, l'accès aux
données... Une bonne architecture, c'est comme ranger chaque câble dans sa propre boîte étiquetée.

#### Explication de la notion

Dans les premiers jours d'Android, il était courant de tout mettre dans l'Activity ou le Fragment : les clics sur les
boutons, les appels réseau, les requêtes en base de données, la manipulation des données...
Ce qu'on appelle le **code "spaghetti"** a des conséquences désastreuses :

* **Difficile à lire et à maintenir :** Des fichiers de milliers de lignes où tout est mélangé.
* **Difficile à tester :** Comment tester une logique métier si elle est étroitement liée à l'interface Android ?
* **Sujet aux bugs :** La gestion du cycle de vie (comme la rotation d'écran) devient un enfer, provoquant des fuites de
  mémoire et des pertes de données.

Le principe fondamental pour résoudre ce problème est la **Séparation des Préoccupations (Separation of Concerns)**.
Chaque partie de votre application ne doit avoir qu'une seule et unique responsabilité.

---

### Les Rôles du MVVM

#### Introduction à la notion {id="introduction-la-notion_1"}

MVVM est un plan d'organisation qui définit trois rôles clairs, comme dans une équipe :

* La **View** est l'**artiste**. Elle est douée pour dessiner l'interface et écouter le public (événements utilisateur),
  mais elle est "bête" et ne prend aucune décision.
* Le **ViewModel** est le **manager**. Il ne sait pas dessiner, mais il prend les décisions logiques. Il dit à l'artiste
  quoi afficher et réagit quand l'artiste lui rapporte une information du public. Il est le cerveau de l'interface.
* Le **Model** est l'**expert-comptable**. Il gère les sources de données (les livres de comptes, les contacts
  externes...). Le manager lui demande des informations, et il les lui fournit sans savoir à quoi elles serviront.

#### Explication de la notion {id="explication-de-la-notion_1"}

**Model (Modèle)**
C'est la couche de gestion des données. Elle est responsable de fournir les données, qu'elles viennent d'une base de
données `Room`, d'une API `Retrofit`, ou des `SharedPreferences`.

* Elle expose des données brutes.
* Elle ne connaît absolument rien de l'interface utilisateur.
* On y trouve souvent le **Repository Pattern** : une classe (ex: `UserRepository`) qui sert de source de vérité unique
  pour un certain type de données, en cachant la complexité (doit-on aller chercher les données dans le cache ou sur le
  réseau ?).

**View (Vue)**
C'est la couche UI, représentée par votre `Fragment` ou votre `Activity`.

* Sa **seule** responsabilité est d'afficher les données à l'écran et de transmettre les actions de l'utilisateur au
  ViewModel.
* Elle ne contient **AUCUNE** logique métier. Pas de calculs, pas de décisions.
* Elle observe les données exposées par le ViewModel et se met à jour en conséquence.

**ViewModel (Vue-Modèle)**
C'est le pont entre la View et le Model.

* Il contient la logique de présentation et l'**état** de l'UI.
* Il récupère les données brutes du Model et les prépare pour que la View puisse les afficher facilement.
* Il expose des données que la View peut "observer".
* Il ne connaît rien des détails de l'implémentation de la View (il ne sait pas s'il s'agit d'un Fragment, d'une
  Activity, etc.).

```plantuml
@startuml
title Diagramme de l'architecture MVVM

package "View (Fragment/Activity)" {
  [UI] as UI_Component
}

package "ViewModel Layer" {
  [ViewModel] as VM
  note bottom of VM: Contient la logique de présentation\net l'état de l'UI.
}

package "Model Layer" {
  [Repository] as Repo
  [Room (DB)] -- Repo
  [Retrofit (API)] -- Repo
  note bottom of Repo: Source de vérité des données.
}

' Relations entre les couches, en utilisant les alias
UI_Component -> VM : "L'utilisateur a cliqué"
VM -> UI_Component : "Affiche cette liste" (via LiveData/Flow)

VM -> Repo : "Donne-moi les utilisateurs"
Repo --> VM : Retourne les utilisateurs



@enduml
```
![MVM.svg](MVM.svg)



---

### Le composant `ViewModel` d'Android Jetpack

#### Introduction à la notion {id="introduction-la-notion_2"}

Le composant `ViewModel` de Google est la clé de voûte de cette architecture. C'est un manager très spécial : il a son
propre bureau, indépendant de la scène. Quand la scène est détruite et reconstruite (rotation d'écran), le manager reste
tranquillement dans son bureau, avec tous ses dossiers intacts. Quand la nouvelle scène est prête, elle vient simplement
se reconnecter au même manager.

#### Explication de la notion {id="explication-de-la-notion_2"}

Un `ViewModel` est une classe qui hérite de `androidx.lifecycle.ViewModel`. Sa caractéristique magique est qu'il est *
*conscient du cycle de vie, mais d'une manière différente** :

* Un `ViewModel` est créé la première fois qu'un `Fragment` ou une `Activity` le demande.
* Il **survit** aux changements de configuration (comme la rotation) qui détruisent et recréent l'Activity/Fragment.
* Il n'est détruit que lorsque le composant UI qui lui est associé est définitivement détruit (ex: l'utilisateur quitte
  l'écran avec le bouton Retour).

Ceci **résout complètement** le problème de la perte d'état. L'état de l'UI est stocké dans le `ViewModel`, pas dans la
View.

#### Mise en place

**1. Ajouter la dépendance** dans `build.gradle.kts`

```kotlin
dependencies {
    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    // Pour l'instanciation dans les fragments
    implementation("androidx.fragment:fragment-ktx:1.6.2")
}
```

**2. Créer la classe ViewModel**

```kotlin
package fr.formation.mvvm.counter

import androidx.lifecycle.ViewModel

// Notre ViewModel pour le compteur
class CounterViewModel : ViewModel() {

    // L'état (le compteur) est maintenant ici, à l'abri des rotations
    var count = 0
        private set // On ne peut le modifier que depuis le ViewModel

    fun increment() {
        count++
    }
}
```

**3. Instancier le ViewModel dans la View (Fragment/Activity)**
On utilise le délégué de propriété `by viewModels()` qui vient de la dépendance `fragment-ktx`.

```kotlin
package fr.formation.mvvm.counter

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.activity.viewModels // Import important

class CounterActivity : AppCompatActivity() {

    // Instanciation magique : le framework gère la création et la conservation
    private val viewModel: CounterViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        // ...

        // On lit l'état depuis le ViewModel
        updateUi()

        binding.incrementButton.setOnClickListener {
            // On délègue l'action au ViewModel
            viewModel.increment()
            // On met à jour l'UI avec le nouvel état
            updateUi()
        }
    }

    private fun updateUi() {
        binding.counterTextView.text = viewModel.count.toString()
    }
}
```

Avec ce code, si vous faites pivoter l'écran, la valeur du compteur sera conservée !

#### Exercice 1 : Refactoriser le compteur en MVVM

**Énoncé :**
Reprenez le code du TP du module 4 (l'application "Compteur" qui perdait son état à la rotation) et refactorisez-le pour
utiliser l'architecture MVVM.

1. Ajoutez la dépendance `lifecycle-viewmodel-ktx`.
2. Créez une classe `CounterViewModel` qui contiendra la variable `count` et la méthode `increment()`.
3. Dans votre `MainActivity`, instanciez le `CounterViewModel` en utilisant `by viewModels()`.
4. Modifiez le code de l'Activity pour qu'elle lise l'état et appelle les méthodes du ViewModel, au lieu de gérer l'état
   elle-même.

**Correction exercice 1** {collapsible='true'}

**1. `build.gradle.kts`**

```kotlin
dependencies {
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    implementation("androidx.activity:activity-ktx:1.9.0") // pour by viewModels() dans une Activity
    // ...
}
```

**2. `CounterViewModel.kt`**

```kotlin
package fr.formation.compteurapp.viewmodel

import androidx.lifecycle.ViewModel

class CounterViewModel : ViewModel() {

    var count = 0
        private set

    fun incrementCounter() {
        count++
    }
}
```

**3. `MainActivity.kt`**

```kotlin
package fr.formation.compteurapp

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.activity.viewModels // Important
import fr.formation.compteurapp.databinding.ActivityMainBinding
import fr.formation.compteurapp.viewmodel.CounterViewModel

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    // Délégation de l'instanciation du ViewModel au framework
    private val viewModel: CounterViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // L'Activity ne fait plus que de l'affichage
        updateCounterText()

        binding.incrementButton.setOnClickListener {
            // L'Activity notifie le ViewModel de l'action de l'utilisateur
            viewModel.incrementCounter()
            // L'Activity met à jour son affichage en fonction du nouvel état
            updateCounterText()
        }
    }

    private fun updateCounterText() {
        // L'Activity lit l'état depuis le ViewModel
        binding.counterTextView.text = viewModel.count.toString()
    }
}
```

Maintenant, l'état du compteur survit à la rotation de l'écran.

---

### TP 14 : Mettre en place la structure MVVM pour notre application de notes

**Objectif :** Préparer l'architecture de notre application de notes en créant les différentes couches du MVVM.

<procedure>

1. **Créez la couche Model (Repository) :**
    * Créez une classe `NoteRepository`.
    * Pour l'instant, elle aura une dépendance vers le `NoteDao`.
    * Créez des méthodes qui encapsulent les appels au DAO (ex: `getAllNotes()`, `insert(note: Note)`).
    * Le but est que le ViewModel ne parle qu'au Repository, jamais directement au DAO.
   ```kotlin
   class NoteRepository(private val noteDao: NoteDao) {
       suspend fun getAllNotes(): List<Note> {
           return noteDao.getAllNotes()
       }

       suspend fun insert(note: Note) {
           noteDao.insert(note)
       }
   }
   ```
2. **Créez la couche ViewModel :**
    * Créez un `NoteViewModel` qui hérite de `ViewModel`.
    * Le `NoteViewModel` aura besoin d'une instance du `NoteRepository`. Nous verrons plus tard comment l'injecter
      proprement, pour l'instant on peut le passer au constructeur.
3. **Réfléchissez à la communication :**
    * Pour l'instant, notre `MainActivity` appelle `viewModel.increment()` puis `updateUi()`. C'est un peu manuel. Ne
      serait-ce pas génial si l'UI se mettait à jour **automatiquement** quand `count` change ?
    * C'est le problème que nous allons résoudre dans le prochain module avec `LiveData` et `StateFlow`.

</procedure>

---

### Auto-évaluation

**1. Quelle est la responsabilité principale de la couche "View" dans l'architecture MVVM ? (QCM)**

* A) Effectuer les appels réseau et les requêtes en base de données.
* B) Contenir la logique métier et les décisions complexes.
* C) Afficher l'état de l'UI et transmettre les interactions de l'utilisateur au ViewModel.
* D) Stocker l'état de l'UI de manière persistante.

**2. Quel est l'avantage majeur du composant `ViewModel` de Jetpack ? (QCM)**

* A) Il accélère les requêtes en base de données.
* B) Il survit aux changements de configuration, protégeant ainsi l'état de l'UI.
* C) Il simplifie l'écriture des layouts XML.
* D) Il gère automatiquement la navigation entre les fragments.

**3. Lequel de ces éléments ne devrait JAMAIS se trouver dans un `ViewModel` ? (QCM)**

* A) Une référence à un Repository.
* B) Des données d'état de l'interface (comme une liste d'items à afficher).
* C) Une référence directe à une Activity ou un Fragment (un `Context`).
* D) La logique pour formater une date à afficher.

**4. Expliquez avec vos mots le principe de "Séparation des Préoccupations". (Question ouverte)**

**5. Quel problème fondamental l'architecture MVVM résout-elle concernant le cycle de vie d'Android ? (Question ouverte)
**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Quelle est la responsabilité principale de la couche "View" ?**

* **Réponse : C) Afficher l'état de l'UI et transmettre les interactions de l'utilisateur au ViewModel.**
* **Justification :** La View doit être aussi "bête" que possible. Son rôle est de traduire un état (fourni par le
  ViewModel) en pixels à l'écran, et de traduire les actions de l'utilisateur (clics, etc.) en appels de méthode sur le
  ViewModel.

**2. Quel est l'avantage majeur du composant `ViewModel` ?**

* **Réponse : B) Il survit aux changements de configuration, protégeant ainsi l'état de l'UI.**
* **Justification :** Son cycle de vie est découplé de celui de la View (Activity/Fragment), ce qui lui permet de
  conserver les données en mémoire lors de la recréation de l'UI, comme lors d'une rotation d'écran.

**3. Lequel de ces éléments ne devrait JAMAIS se trouver dans un `ViewModel` ?**

* **Réponse : C) Une référence directe à une Activity ou un Fragment (un `Context`).**
* **Justification :** Détenir une référence à une View dans un ViewModel est une source majeure de fuites de mémoire.
  Comme le ViewModel a une durée de vie plus longue que la View, il l'empêcherait d'être détruite et nettoyée par le "
  garbage collector", même quand l'utilisateur a quitté l'écran.

**4. Expliquez le principe de "Séparation des Préoccupations".**

* **Réponse type :** C'est le principe de conception logicielle qui consiste à découper un programme en parties
  distinctes, où chaque partie s'occupe d'un aspect spécifique du problème. Dans MVVM, la View ne se préoccupe que de
  l'affichage, le ViewModel de la logique de présentation, et le Model de la source des données. Cette séparation rend
  le code plus facile à comprendre, à tester et à faire évoluer, car un changement dans une partie (par exemple, changer
  la base de données) a moins de chances d'impacter les autres.

**5. Quel problème fondamental MVVM résout-il concernant le cycle de vie d'Android ?**

* **Réponse type :** Il résout le problème de la **perte d'état** due à la destruction et recréation des composants UI (
  Activity/Fragment) lors des changements de configuration. En déplaçant la responsabilité de la gestion de l'état de la
  View (qui a un cycle de vie volatile) vers le `ViewModel` (qui a un cycle de vie stable et plus long), l'architecture
  garantit que les données affichées à l'écran sont préservées de manière fiable, améliorant ainsi considérablement
  l'expérience utilisateur.

---

### Conclusion du module

Vous avez posé les fondations de votre architecture ! Vous comprenez maintenant l'importance de structurer votre code et
vous savez comment mettre en place les différentes couches du pattern MVVM. Vous avez résolu le problème de la perte
d'état grâce au `ViewModel` de Jetpack.

Cependant, la communication entre notre View et notre ViewModel est encore un peu "manuelle". La View doit explicitement
demander au ViewModel de mettre à jour l'UI. Dans le prochain et dernier module de contenu, nous allons découvrir
comment rendre cette communication **réactive** avec `LiveData` et `StateFlow`, pour que l'UI se mette à jour *
*automatiquement** comme par magie. C'est la dernière pièce du puzzle pour une architecture MVVM complète et moderne.
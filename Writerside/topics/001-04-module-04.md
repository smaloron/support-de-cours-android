Parfait, continuons notre progression. Nous avons l'environnement, la structure du projet et le langage en main. Il est
temps de nous attaquer au cœur de ce qui fait un écran Android : l'**Activity**.

---

# Module 4 : Le Cœur d'un Écran : L'Activity et son Cycle de Vie

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Définir le rôle et la responsabilité d'une `Activity`.
* Décrire les états principaux du cycle de vie d'une `Activity` (`onCreate`, `onStart`, `onResume`, `onPause`, `onStop`,
  `onDestroy`).
* Utiliser le Logcat pour visualiser les transitions du cycle de vie en temps réel.
* Comprendre et constater le problème de la recréation d'une `Activity` lors d'un changement de configuration (comme la
  rotation de l'écran).

### Introduction

Imaginez un acteur de théâtre. Il ne joue pas en permanence. Il entre en scène (`onStart`), il est sous les feux des
projecteurs et interagit avec le public (`onResume`), il se met parfois en retrait lorsqu'un autre acteur prend la
parole (`onPause`), il quitte la scène (`onStop`), et à la fin de la pièce, il rentre chez lui (`onDestroy`). Sa vie sur
scène est dictée par une série d'événements.

Une `Activity` Android, c'est exactement cet acteur. Elle est le "visage" de votre application pour un écran donné, mais
elle ne contrôle pas sa propre existence. C'est le système d'exploitation Android, le "metteur en scène", qui décide
quand elle doit apparaître, disparaître, ou même être détruite pour économiser des ressources. Comprendre ce "cycle de
vie" est absolument **fondamental**. C'est la clé pour savoir **à quel moment** charger des données, démarrer des
animations, sauvegarder le travail de l'utilisateur, et éviter des crashs ou des comportements inattendus.

### Notions abordées

* Le concept de l'Activity
* Le Cycle de Vie Détaillé
* Visualisation Pratique avec les Logs
* Le Problème de la Recréation d'Activity

---

### Le concept de l'Activity

#### Introduction à la notion

Pensez à votre application comme à un livre. Chaque page que l'utilisateur peut voir et avec laquelle il peut interagir
est une `Activity`. La page de couverture, la table des matières, un chapitre spécifique... chacune est une `Activity`
distincte. C'est le point d'entrée unique pour un écran donné, le conteneur principal de votre interface utilisateur.

#### Explication de la notion

Une `Activity` (plus précisément, `androidx.appcompat.app.AppCompatActivity` dont nous héritons) est l'un des quatre
composants applicatifs majeurs d'Android. Son rôle principal est de fournir une "fenêtre" dans laquelle l'application
peut dessiner son interface utilisateur.

Une application est généralement composée de plusieurs activités qui sont liées entre elles. Par exemple, une
application d'e-mails pourrait avoir :

* Une `Activity` pour afficher la liste des e-mails.
* Une `Activity` pour lire un e-mail spécifique.
* Une `Activity` pour composer un nouvel e-mail.

Chaque `Activity` est une classe Kotlin qui hérite de `AppCompatActivity` et doit être déclarée dans le fichier
`AndroidManifest.xml`. C'est dans ce fichier que vous déclarez laquelle de vos activités est la "porte d'entrée" de
l'application (celle qui se lance quand on clique sur l'icône).

```plantuml
@startuml
allowmixing
title Relation Activity-UI

package "Application" {
  class MainActivity {
    +onCreate()
  }

  artifact "activity_main.xml" {
    component TextView
    component Button
  }

  MainActivity -> activity_main.xml : R.layout.activity_main
  note on link: Le code Kotlin charge\nle fichier de layout XML\npour construire l'interface.
}
@enduml
```


---

### Le Cycle de Vie Détaillé

#### Introduction à la notion {id="introduction-la-notion_1"}

Revenons à notre acteur. Le metteur en scène lui donne des instructions claires : "Entre en scène !", "Prends la
lumière !", "Passe en arrière-plan.", "Sors de scène.". Le cycle de vie d'une `Activity` est la liste de ces
instructions. Le système Android appelle des méthodes spécifiques sur votre `Activity` pour l'informer des changements
d'état, vous donnant ainsi l'opportunité de réagir.

#### Explication de la notion {id="explication-de-la-notion_1"}

Le cycle de vie d'une activité est défini par une série de méthodes que le système appelle dans un ordre précis. Voici
les plus importantes :

* **`onCreate()`** : Appelée **une seule fois** lorsque l'activité est créée pour la première fois. C'est ici que vous
  devez faire toute la configuration statique : créer les vues (avec `setContentView()`), lier les données à des listes,
  etc.
* **`onStart()`** : Appelée lorsque l'activité devient visible pour l'utilisateur.
* **`onResume()`** : Appelée lorsque l'activité est au premier plan et que l'utilisateur peut interagir avec elle. C'est
  l'état "actif".
* **`onPause()`** : Appelée lorsque l'activité est sur le point de passer en arrière-plan. Elle est encore visible (par
  exemple, si une boîte de dialogue apparaît par-dessus), mais n'a plus le focus. C'est le meilleur endroit pour
  sauvegarder des données non enregistrées ou stopper des animations.
* **`onStop()`** : Appelée lorsque l'activité n'est plus visible pour l'utilisateur.
* **`onDestroy()`** : Appelée juste avant que l'activité ne soit détruite. Cela peut arriver parce que l'utilisateur a
  terminé l'activité (avec le bouton "retour") ou parce que le système a besoin de récupérer de la mémoire.

```plantuml
@startuml
title Diagramme d'état corrigé du Cycle de Vie d'une Activity

' Définition des états
state "Créée" as Created
state "Démarrée" as Started
state "Reprise (Active)" as Resumed
state "En Pause" as Paused
state "Arrêtée" as Stopped

' Transitions du cycle de vie
[*] --> Created : Lancement de l'app\n(appel à **onCreate()**)

Created --> Started : appel à **onStart()**
Started --> Resumed : appel à **onResume()**

Resumed --> Paused : Une autre activité passe devant\n(appel à **onPause()**)
Paused --> Resumed : L'activité revient au premier plan\n(appel à **onResume()**)
Paused --> Stopped : L'activité n'est plus visible\n(appel à **onStop()**)

' Correction de la transition de retour depuis Stopped
Stopped --> Started : L'utilisateur revient sur l'activité\n(appel à **onRestart()**)

' Transitions menant à la destruction
Paused --> [*] : L'app est tuée par le système
Stopped --> [*] : L'activité est détruite\n(appel à **onDestroy()**)
Resumed --> [*] : L'activité est détruite (ex: finish())

' Notes explicatives associées aux états
note right of Resumed
  L'activité est au premier plan
  et interactive.
end note

note right of Paused
  L'activité est partiellement visible
  mais n'a plus le focus (ex: dialogue).
end note

note right of Stopped
  L'activité n'est plus visible
  à l'écran.
end note

@enduml
```

![activity-lifecycle.svg](activity-lifecycle.svg)


<tip>
La paire la plus importante est `onResume()` / `onPause()`. C'est entre ces deux appels que votre application est activement utilisée.
</tip>

---

### Visualisation Pratique avec les Logs

#### Introduction à la notion {id="introduction-la-notion_2"}

Lire la théorie, c'est bien. Mais voir l'acteur bouger sur scène en temps réel, c'est beaucoup mieux ! Nous allons
maintenant utiliser notre outil de débogage préféré, le Logcat, pour espionner le metteur en scène (le système Android)
et voir exactement quand il donne ses instructions à notre `Activity`.

#### Explication de la notion {id="explication-de-la-notion_2"}

Pour visualiser le cycle de vie, nous allons "surcharger" (*override*) chacune des méthodes du cycle de vie dans notre
`MainActivity` et y placer un simple `Log.d()`. Cela nous permettra de tracer chaque étape dans le Logcat.

#### Exercice 1 : Mettre le cycle de vie sous surveillance

**Énononcé :**
Modifiez votre classe `MainActivity` pour logger un message à chaque étape clé du cycle de vie (`onCreate`, `onStart`,
`onResume`, `onPause`, `onStop`, `onDestroy`).

**Correction exercice 1** {collapsible='true'}
<procedure title="Correction">
1.  Ouvrez votre fichier `MainActivity.kt`.
2.  Ajoutez une constante pour le TAG afin d'éviter les répétitions.
    ```kotlin
    private const val TAG = "MainActivityLifecycle"
    ```
3.  Surchargez les méthodes du cycle de vie. Dans Android Studio, vous pouvez utiliser le raccourci `Ctrl+O` (sur Windows/Linux) ou `Cmd+O` (sur Mac) pour ouvrir la boîte de dialogue "Override Methods" et les sélectionner facilement.
4.  Votre code complet devrait ressembler à ceci :

```kotlin
package fr.formation.lifecycleapp

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.util.Log

class MainActivity : AppCompatActivity() {

    // On définit une constante pour notre TAG Logcat.
    // C'est une bonne pratique pour éviter les fautes de frappe.
    private val TAG = "MainActivityLifecycle"

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)
        Log.d(TAG, "onCreate() a été appelée.")
    }

    override fun onStart() {
        super.onStart()
        Log.d(TAG, "onStart() a été appelée.")
    }

    override fun onResume() {
        super.onResume()
        Log.d(TAG, "onResume() a été appelée.")
    }

    override fun onPause() {
        super.onPause()
        Log.d(TAG, "onPause() a été appelée.")
    }

    override fun onStop() {
        super.onStop()
        Log.d(TAG, "onStop() a été appelée.")
    }

    override fun onDestroy() {
        super.onDestroy()
        Log.d(TAG, "onDestroy() a été appelée.")
    }
}
```

5. **Testez !**
    * Lancez l'application. Dans Logcat (filtré avec votre TAG), vous devriez voir `onCreate`, `onStart`, `onResume`.
    * Appuyez sur le bouton "Home" de l'appareil. Vous devriez voir `onPause`, `onStop`.
    * Rouvrez l'application depuis la liste des applications récentes. Vous devriez voir `onStart`, `onResume`.
    * Appuyez sur le bouton "Retour". Vous devriez voir `onPause`, `onStop`, `onDestroy`. L'activité est détruite.

</procedure>

---

### Le Problème de la Recréation d'Activity

#### Introduction à la notion {id="introduction-la-notion_3"}

Imaginez que notre acteur, en plein milieu d'une scène, change de costume. Le metteur en scène, au lieu de le laisser
continuer, le fait sortir, puis le fait revenir avec son nouveau costume, en lui faisant **oublier tout ce qu'il a fait
avant**. C'est un comportement étrange, mais c'est exactement ce que fait Android lors d'un "changement de
configuration", comme la rotation de l'écran.

#### Explication de la notion {id="explication-de-la-notion_3"}

Un changement de configuration se produit lorsque l'état de l'appareil change de manière significative, par exemple :

* L'utilisateur fait pivoter l'appareil (passage du mode portrait au paysage).
* L'utilisateur change la langue du système.
* L'utilisateur active le mode sombre.

Lorsque cela se produit, Android détruit (`onDestroy`) votre `Activity` actuelle et en crée une **nouvelle instance** (
`onCreate`). Pourquoi ? Pour lui permettre de recharger des ressources alternatives qui pourraient être optimisées pour
la nouvelle configuration (par exemple, un layout différent pour le mode paysage).

<warning>
**Le problème :** Puisqu'une nouvelle instance est créée, toutes les données stockées dans les propriétés de l'ancienne `Activity` sont **perdues** !
</warning>

C'est l'un des problèmes les plus fondamentaux du développement Android. Ne pas le comprendre mène à des applications
qui perdent l'état de l'utilisateur, ce qui est très frustrant.

La solution moderne à ce problème est l'utilisation des **ViewModel**, que nous verrons dans la partie sur
l'architecture. Pour l'instant, notre objectif est de **constater** et de **comprendre** le problème.

---

### TP 4 : L'application "Compteur"

**Objectif :** Mettre en évidence la perte de données lors de la rotation de l'écran.

<procedure>

1. **Créez un nouveau projet** "Empty Views Activity" nommé `CompteurApp`.
2. **Modifiez le layout `activity_main.xml` :**
    * Ajoutez un `TextView` pour afficher un chiffre. Donnez-lui l'ID `@+id/counterTextView`. Centrez-le à l'écran.
    * Ajoutez un `Button` en dessous. Donnez-lui l'ID `@+id/incrementButton` et le texte "Incrémenter".
    * Pour la simplicité, vous pouvez utiliser un `LinearLayout` vertical.

   ```xml
   <!-- res/layout/activity_main.xml -->
   <LinearLayout
       xmlns:android="http://schemas.android.com/apk/res/android"
       xmlns:tools="http://schemas.android.com/tools"
       android:layout_width="match_parent"
       android:layout_height="match_parent"
       android:orientation="vertical"
       android:gravity="center"
       tools:context=".MainActivity">

       <TextView
           android:id="@+id/counterTextView"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:textSize="48sp"
           android:text="0" />

       <Button
           android:id="@+id/incrementButton"
           android:layout_width="wrap_content"
           android:layout_height="wrap_content"
           android:layout_marginTop="16dp"
           android:text="Incrémenter" />
   </LinearLayout>
   ```

3. **Modifiez la classe `MainActivity.kt` :**
    * Utilisez **View Binding** pour accéder aux vues (nous le verrons en détail plus tard, pour l'instant, suivez le
      code).
    * Créez une variable de type `var` pour stocker le compteur : `private var counter = 0`.
    * Dans `onCreate`, configurez un `onClickListener` sur le bouton pour incrémenter le compteur et mettre à jour le
      `TextView`.
    * (Optionnel) Ajoutez les logs du cycle de vie de l'exercice 1 pour mieux observer.

   ```kotlin
   package fr.formation.compteurapp

   import androidx.appcompat.app.AppCompatActivity
   import android.os.Bundle
   import android.util.Log
   import fr.formation.compteurapp.databinding.ActivityMainBinding

   class MainActivity : AppCompatActivity() {

       private val TAG = "MainActivityLifecycle"
       
       // Étape 1: Activer View Binding dans build.gradle.kts (Module: app)
       // android {
       //   ...
       //   buildFeatures {
       //     viewBinding = true
       //   }
       // }
       // Puis synchroniser Gradle.

       // Étape 2: Déclarer la variable pour le binding
       private lateinit var binding: ActivityMainBinding

       // Notre variable qui stocke l'état
       private var counter = 0

       override fun onCreate(savedInstanceState: Bundle?) {
           super.onCreate(savedInstanceState)

           // Étape 3: Initialiser le binding
           binding = ActivityMainBinding.inflate(layoutInflater)
           setContentView(binding.root)

           Log.d(TAG, "onCreate ! Compteur est à $counter")

           // On met à jour le TextView avec la valeur actuelle
           updateCounterText()

           // On configure le clic sur le bouton
           binding.incrementButton.setOnClickListener {
               counter++
               updateCounterText()
               Log.d(TAG, "Clic ! Le compteur est maintenant à $counter")
           }
       }

       private fun updateCounterText() {
           binding.counterTextView.text = counter.toString()
       }

       // Ajoutez les autres méthodes du cycle de vie (onStart, etc.) ici...
       override fun onDestroy() {
           super.onDestroy()
           Log.d(TAG, "onDestroy ! La valeur finale du compteur était $counter")
       }
   }
   ```

4. **Lancez et testez :**
    * Lancez l'application.
    * Cliquez plusieurs fois sur le bouton. Le compteur s'incrémente.
    * **Faites pivoter votre émulateur ou votre téléphone.**
    * **Observez le résultat :** Le compteur est revenu à 0 !
    * **Regardez le Logcat :** Vous verrez que l'activité a été détruite (`onDestroy`) et recréée (`onCreate`). La
      variable `counter` a été réinitialisée à sa valeur par défaut.

</procedure>

---

### Auto-évaluation

**1. Dans quelle méthode du cycle de vie est-il préférable d'appeler `setContentView()` ? (QCM)**

* A) `onStart()`
* B) `onResume()`
* C) `onCreate()`
* D) `onPause()`

**2. Votre application joue de la musique. Dans quelle méthode du cycle de vie devriez-vous mettre en pause la musique
si l'utilisateur reçoit un appel téléphonique ? (QCM)**

* A) `onStop()`
* B) `onDestroy()`
* C) `onPause()`
* D) `onCreate()`

**3. Que se passe-t-il lorsqu'un utilisateur fait pivoter l'écran de son téléphone ? (QCM)**

* A) La méthode `onPause()` est appelée, puis `onResume()`.
* B) L'Activity est détruite et une nouvelle instance est créée.
* C) Seul le layout est redessiné, l'instance de l'Activity reste la même.
* D) Rien, le système gère tout automatiquement sans impacter l'Activity.

**4. Expliquez la différence entre les états "Paused" (en pause) et "Stopped" (arrêté) pour une Activity. (Question
ouverte)**

**5. Pourquoi le compteur de notre TP revient-il à zéro après une rotation ? Expliquez le processus technique derrière
ce phénomène. (Question ouverte)**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Dans quelle méthode du cycle de vie est-il préférable d'appeler `setContentView()` ?**

* **Réponse : C) `onCreate()`**
* **Justification :** `onCreate()` n'est appelée qu'une seule fois lors de la création initiale de l'activité. C'est l'
  endroit idéal pour effectuer toutes les initialisations qui ne doivent se produire qu'une seule fois, comme la
  définition du layout.

**2. Votre application joue de la musique. Dans quelle méthode du cycle de vie devriez-vous mettre en pause la musique
si l'utilisateur reçoit un appel téléphonique ?**

* **Réponse : C) `onPause()`**
* **Justification :** Un appel téléphonique fait passer votre activité en arrière-plan, mais elle reste partiellement
  visible. La méthode `onPause()` est la première à être appelée lorsque l'activité perd le focus. C'est le moment idéal
  pour stopper les processus qui ne devraient pas continuer en arrière-plan (lecture audio/vidéo, animations, etc.).

**3. Que se passe-t-il lorsqu'un utilisateur fait pivoter l'écran de son téléphone ?**

* **Réponse : B) L'Activity est détruite et une nouvelle instance est créée.**
* **Justification :** C'est le comportement par défaut d'Android pour gérer les changements de configuration. Il détruit
  l'ancienne instance et en crée une nouvelle pour charger les ressources appropriées.

**4. Expliquez la différence entre les états "Paused" (en pause) et "Stopped" (arrêté) pour une Activity.**

* **Réponse type :** Une activité est en état "Paused" lorsqu'elle a perdu le focus mais est toujours au moins
  partiellement visible pour l'utilisateur (par exemple, si une boîte de dialogue transparente ou une notification "
  pop-up" apparaît). Une activité est en état "Stopped" lorsqu'elle n'est plus du tout visible (par exemple,
  l'utilisateur a appuyé sur le bouton "Home" ou a navigué vers une autre activité qui recouvre entièrement l'écran).

**5. Pourquoi le compteur de notre TP revient-il à zéro après une rotation ? Expliquez le processus technique derrière
ce phénomène.**

* **Réponse type :** Le compteur revient à zéro car la variable `counter` est une propriété de l'instance de
  `MainActivity`. Lors de la rotation, le système Android considère qu'il s'agit d'un changement de configuration
  majeur. Il **détruit** complètement l'instance existante de `MainActivity` (ce qui efface la valeur de `counter` de la
  mémoire). Ensuite, il crée une **nouvelle instance** de `MainActivity` pour le nouveau mode (paysage ou portrait).
  Dans cette nouvelle instance, la variable `counter` est réinitialisée à sa valeur initiale, qui est 0. C'est le cycle
  `onDestroy()` -> `onCreate()` qui est la cause de cette perte de données.

---

### Conclusion du module

Vous avez maintenant touché au cœur du fonctionnement d'une application Android. Vous comprenez que vos écrans ne sont
pas des entités statiques, mais des composants dynamiques avec un cycle de vie bien défini, géré par le système.

Vous avez appris à écouter les événements de ce cycle de vie et, surtout, vous avez mis le doigt sur un des problèmes
les plus courants et les plus importants : la **perte d'état lors des changements de configuration**.

Cette compréhension est le "pourquoi" qui justifiera l'utilisation de composants d'architecture plus avancés comme le
`ViewModel`. Considérez ce que vous venez d'apprendre comme une pièce maîtresse de votre puzzle de connaissances
Android.

Dans la prochaine partie, nous allons nous concentrer sur la construction de l'interface utilisateur elle-même.
Maintenant que nous savons comment fonctionne le conteneur (`Activity`), nous allons apprendre à le remplir avec des
vues et à le rendre interactif.
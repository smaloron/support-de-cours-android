# Module 11 : Gérer une Base de Données Locale avec `Room`

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Expliquer pourquoi `Room` est la solution recommandée pour la persistance de données structurées sur Android.
* Identifier et implémenter les trois composants architecturaux de `Room` : `@Entity`, `@Dao`, et `@Database`.
* Définir une table de base de données à l'aide d'une `data class` et d'annotations.
* Créer des requêtes SQL (CRUD : Create, Read, Update, Delete) dans une interface DAO.
* Mettre en place et obtenir une instance de la base de données.

### Introduction

Imaginez que votre application ne gère plus seulement quelques réglages, mais une collection entière de livres. Vous
avez des centaines de titres, d'auteurs, de dates de publication... Utiliser des "post-its" (`SharedPreferences`) serait
un chaos total. Vous avez besoin d'une bibliothèque bien organisée, avec des étagères (`Tables`), des fiches pour chaque
livre (`Entités`), et un bibliothécaire (`DAO`) qui sait exactement où trouver un livre, comment en ajouter un nouveau
ou en retirer un ancien.

`Room` est cette bibliothèque moderne et efficace pour votre application. C'est une couche d'abstraction au-dessus de la
base de données SQLite intégrée à Android. `Room` transforme la complexité des requêtes SQL brutes en appels de
fonctions Kotlin simples et sécurisés, tout en vérifiant votre SQL à la compilation pour vous éviter des erreurs à
l'exécution. C'est la solution de référence pour toute persistance de données structurées.

### Notions abordées

* Pourquoi Room ? Une abstraction au-dessus de SQLite.
* Les 3 Piliers de Room : `@Entity`, `@Dao`, `@Database`.

---

### Pourquoi Room ? Une abstraction au-dessus de SQLite

#### Introduction à la notion

SQLite est le moteur de base de données intégré à chaque appareil Android. Il est puissant et fiable, mais son
utilisation directe en Java/Kotlin est verbeuse et risquée. C'est comme parler directement le langage machine d'un
ordinateur. `Room` est un traducteur intelligent qui vous permet de parler un langage de plus haut niveau (Kotlin), et
il se charge de la traduction complexe et sans erreur vers SQLite.

#### Explication de la notion

Utiliser l'API SQLite native (`SQLiteOpenHelper`) implique :

* Écrire des requêtes SQL sous forme de `String`, sans aucune vérification par le compilateur. Une faute de frappe ne
  sera détectée qu'au crash de l'application.
* Convertir manuellement les résultats des requêtes (objet `Cursor`) en objets Kotlin, ce qui est répétitif et source
  d'erreurs.
* Gérer manuellement les migrations de schéma de base de données.

`Room` résout tous ces problèmes :

* **Vérification des requêtes à la compilation :** Room analyse votre SQL pendant que vous compilez votre projet et vous
  signale les erreurs de syntaxe.
* **Moins de code répétitif (`boilerplate`) :** Il mappe automatiquement les résultats des requêtes vers vos objets
  Kotlin.
* **Intégration facile avec d'autres composants Jetpack :** Fonctionne parfaitement avec `LiveData`, `Flow` (pour des
  données réactives) et les Coroutines.

---

### Les 3 Piliers de Room

#### Introduction à la notion {id="introduction-la-notion_1"}

Pour construire notre bibliothèque, nous avons besoin de trois plans de construction distincts mais connectés :

1. Le plan d'une **fiche de livre** (`@Entity`) : Il décrit à quoi ressemble un livre (titre, auteur...).
2. Le plan du **comptoir du bibliothécaire** (`@Dao`) : Il liste toutes les opérations possibles (chercher un livre,
   ajouter un livre...).
3. Le plan de la **bibliothèque elle-même** (`@Database`) : Il définit l'ensemble du bâtiment, quelles étagères il
   contient, et comment y accéder.

#### Explication de la notion {id="explication-de-la-notion_1"}

`Room` s'articule autour de ces trois annotations majeures.

**1. `@Entity` : La Table de Données**

C'est une `data class` Kotlin qui représente une table dans votre base de données.

* L'annotation `@Entity` marque la classe comme une table. Vous pouvez spécifier le nom de la table (`tableName`).
* Chaque propriété de la `data class` représente une colonne dans la table.
* L'une des propriétés doit être la clé primaire, annotée avec `@PrimaryKey`. On peut la faire s'auto-incrémenter.

```kotlin
// Représente une table "notes" dans la BDD
@Entity(tableName = "notes")
data class Note(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0, // Clé primaire auto-générée

    val title: String, // Colonne "title" de type TEXT

    val content: String // Colonne "content" de type TEXT
)
```

**2. `@Dao` (Data Access Object) : L'Interface des Opérations**

C'est une **interface** Kotlin qui définit comment vous accédez à vos données. Vous y déclarez des méthodes, et `Room`
se charge de générer le code d'implémentation.

* L'annotation `@Dao` marque l'interface.
* Vous utilisez des annotations pour chaque type d'opération :
    * `@Insert` : Pour insérer un ou plusieurs objets.
    * `@Update` : Pour mettre à jour un objet.
    * `@Delete` : Pour supprimer un objet.
    * `@Query` : Pour toute autre requête (lecture, suppression complexe...). Vous écrivez la requête SQL directement
      dans l'annotation.

```kotlin
@Dao
interface NoteDao {
    @Insert
    suspend fun insert(note: Note) // `suspend` pour les coroutines

    @Update
    suspend fun update(note: Note)

    @Delete
    suspend fun delete(note: Note)

    @Query("SELECT * FROM notes ORDER BY id DESC")
    fun getAllNotes(): List<Note> // Pas `suspend` si Room utilise un autre mécanisme

    @Query("SELECT * FROM notes WHERE id = :noteId")
    suspend fun getNoteById(noteId: Long): Note?
}
```

<warning>
Les opérations d'écriture (`@Insert`, `@Update`, `@Delete`) et les requêtes potentiellement longues doivent être exécutées en dehors du thread principal. L'utilisation de `suspend` avec les coroutines est la manière moderne de le faire.
</warning>

**3. `@Database` : Le Point d'Entrée de la Base de Données**

C'est une classe **abstraite** qui hérite de `RoomDatabase`. Elle relie tous les éléments.

* L'annotation `@Database` prend en paramètres :
    * `entities` : Un tableau de toutes vos classes `@Entity`.
    * `version` : La version de votre schéma de base de données. À incrémenter à chaque modification du schéma.
* La classe doit contenir une méthode abstraite qui renvoie chaque `@Dao`.
* Elle contient généralement un `companion object` pour implémenter le pattern **Singleton**, garantissant qu'une seule
  instance de la base de données existe pour toute l'application.

```kotlin
@Database(entities = [Note::class], version = 1)
abstract class AppDatabase : RoomDatabase() {

    abstract fun noteDao(): NoteDao

    companion object {
        // @Volatile garantit que la valeur est toujours à jour pour tous les threads
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "app_database" // Nom du fichier de la BDD
                ).build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

```plantuml
@startuml
title Architecture de Room

class AppDatabase <<Database>> {
  +noteDao(): NoteDao
  +getDatabase(context): AppDatabase
}

interface NoteDao <<DAO>> {
  +insert(note: Note)
  +getAllNotes(): List<Note>
}

class Note <<Entity>> {
  +id: Long
  +title: String
  +content: String
}

AppDatabase ..> NoteDao : expose
AppDatabase ..> Note : connaît
NoteDao ..> Note : manipule

note right of AppDatabase : Singleton\nPoint d'entrée unique
note left of NoteDao : Interface des requêtes
note right of Note : Représente une table
@enduml
```

#### Exercice 1 : Mettre en place Room pour une entité "User"

**Énoncé :**
Mettez en place les trois piliers de Room pour gérer une entité `User`.

1. Créez une `data class` `User` annotée comme une `@Entity`. Elle doit avoir un `id` (Long, clé primaire auto-générée),
   un `firstName` (String) et un `lastName` (String).
2. Créez une interface `UserDao` avec des méthodes pour insérer un utilisateur et pour récupérer tous les utilisateurs.
3. Créez la classe `AppDatabase` qui inclut l'entité `User`.

**Correction exercice 1** {collapsible='true'}

**0. Dépendances (à ajouter dans `build.gradle.kts`)**

```kotlin
dependencies {
    val room_version = "2.6.1"
    implementation("androidx.room:room-runtime:$room_version")
    // Annotation processor pour générer le code
    ksp("androidx.room:room-compiler:$room_version")
    // Support pour les coroutines Kotlin
    implementation("androidx.room:room-ktx:$room_version")
}
// N'oubliez pas d'appliquer le plugin KSP en haut du fichier
// plugins { id("com.google.devtools.ksp") }
```

**1. `User.kt` (@Entity)**

```kotlin
package fr.formation.room.models

import androidx.room.Entity
import androidx.room.PrimaryKey

@Entity(tableName = "users")
data class User(
    @PrimaryKey(autoGenerate = true)
    val id: Long = 0,
    val firstName: String,
    val lastName: String
)
```

**2. `UserDao.kt` (@Dao)**

```kotlin
package fr.formation.room.dao

import androidx.room.Dao
import androidx.room.Insert
import androidx.room.Query
import fr.formation.room.models.User

@Dao
interface UserDao {
    @Insert
    suspend fun insert(user: User)

    @Query("SELECT * FROM users ORDER BY lastName ASC")
    fun getAllUsers(): List<User> // Pour cet exemple, on la laisse synchrone
}
```

**3. `AppDatabase.kt` (@Database)**

```kotlin
package fr.formation.room.database

import android.content.Context
import androidx.room.Database
import androidx.room.Room
import androidx.room.RoomDatabase
import fr.formation.room.dao.UserDao
import fr.formation.room.models.User

@Database(entities = [User::class], version = 1)
abstract class AppDatabase : RoomDatabase() {

    abstract fun userDao(): UserDao

    companion object {
        @Volatile
        private var INSTANCE: AppDatabase? = null

        fun getDatabase(context: Context): AppDatabase {
            return INSTANCE ?: synchronized(this) {
                val instance = Room.databaseBuilder(
                    context.applicationContext,
                    AppDatabase::class.java,
                    "my_app_database"
                )
                    .fallbackToDestructiveMigration() // Pour la simplicité du TP
                    .build()
                INSTANCE = instance
                instance
            }
        }
    }
}
```

---

### TP 11 : Une application de prise de notes simple

**Objectif :** Créer une application qui permet d'ajouter des notes et de les afficher dans une liste. Les notes doivent
persister même après la fermeture de l'application. (Pour ce TP, l'interaction avec la BDD se fera encore sur le thread
principal pour la simplicité, nous introduirons les coroutines au module suivant).

<procedure>

1.  **Mettez en place Room** avec l'entité `Note` et le `NoteDao` vus dans l'exemple ci-dessus. N'oubliez pas les dépendances.
2.  **Créez un layout `activity_main.xml`** qui contient :
    *   Un `EditText` pour le titre de la note.
    *   Un `EditText` pour le contenu de la note.
    *   Un `Button` "Ajouter".
    *   Un `RecyclerView` pour afficher les notes.
3.  **Créez un `NoteAdapter`** pour le `RecyclerView`.
4.  **Dans `MainActivity.kt` :**
    *   Obtenez une instance de votre base de données : `val db = AppDatabase.getDatabase(this)`.
    *   Créez une fonction `loadNotes()` qui :
        *   Récupère toutes les notes via `db.noteDao().getAllNotes()`.
        *   Met à jour l'adapter du RecyclerView avec cette liste.
        *   **Attention :** par défaut, Room interdit les requêtes sur le thread principal. Pour ce TP, lors de la construction de la base de données, ajoutez `.allowMainThreadQueries()` juste avant `.build()`. C'est une **mauvaise pratique** pour une vraie application, mais cela nous permet de nous concentrer sur Room avant d'aborder l'asynchronisme.
    *   Dans `onCreate`, appelez `loadNotes()`.
    *   Dans le `onClickListener` du bouton "Ajouter" :
        *   Créez un nouvel objet `Note` à partir des `EditText`.
        *   Insérez-le dans la base de données : `db.noteDao().insert(newNote)`.
        *   Appelez à nouveau `loadNotes()` pour rafraîchir la liste.
5.  **Testez :** Ajoutez quelques notes. Fermez complètement l'application. Relancez-la. Vos notes doivent toujours être là !
</procedure>

---

### Auto-évaluation

**1. Quelle annotation est utilisée pour marquer une `data class` comme une table de base de données dans Room ? (QCM)**

* A) `@Dao`
* B) `@Table`
* C) `@Entity`
* D) `@Database`

**2. Quel est le rôle principal d'une interface annotée avec `@Dao` ? (QCM)**

* A) Définir la structure de la base de données, y compris la version.
* B) Servir de point d'entrée unique (Singleton) pour accéder à la base de données.
* C) Représenter une ligne de données dans une table.
* D) Définir les méthodes d'accès aux données (requêtes SQL).

**3. Que se passe-t-il si vous écrivez une requête SQL avec une erreur de syntaxe dans une annotation `@Query` ? (QCM)**

* A) L'application plantera au moment où la requête sera exécutée.
* B) Le projet ne compilera pas, et Android Studio signalera une erreur.
* C) La requête sera ignorée silencieusement.
* D) Room essaiera de corriger l'erreur automatiquement.

**4. Qu'est-ce que le pattern "Singleton" et pourquoi est-il important pour la classe `@Database` ? (Question ouverte)**

**5. Pourquoi Room interdit-il par défaut l'exécution des requêtes sur le thread principal ? (Question ouverte)**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Quelle annotation marque une `data class` comme une table ?**

* **Réponse : C) `@Entity`**
* **Justification :** L'annotation `@Entity` indique à Room que cette classe doit être transformée en une table dans la
  base de données SQLite.

**2. Quel est le rôle principal d'une interface `@Dao` ?**

* **Réponse : D) Définir les méthodes d'accès aux données (requêtes SQL).**
* **Justification :** Le DAO (Data Access Object) est le contrat qui définit toutes les opérations possibles sur les
  données, comme l'insertion, la sélection, la mise à jour et la suppression.

**3. Que se passe-t-il en cas d'erreur de syntaxe SQL ?**

* **Réponse : B) Le projet ne compilera pas, et Android Studio signalera une erreur.**
* **Justification :** C'est l'un des plus grands avantages de Room. Il vérifie la validité de vos requêtes SQL au moment
  de la compilation, ce qui vous permet de corriger les erreurs avant même de lancer l'application.

**4. Qu'est-ce que le pattern "Singleton" et pourquoi est-il important pour la classe `@Database` ?**

* **Réponse type :** Un Singleton est un design pattern qui garantit qu'il n'existe qu'une seule instance d'une classe
  pour toute l'application. C'est important pour la classe `@Database` car la création d'une connexion à une base de
  données est une opération "coûteuse" en termes de ressources. En utilisant un Singleton, on s'assure de ne créer cette
  connexion qu'une seule fois et de réutiliser la même instance partout, ce qui est beaucoup plus performant et évite
  les conflits d'accès.

**5. Pourquoi Room interdit-il les requêtes sur le thread principal ?**

* **Réponse type :** Les opérations sur une base de données impliquent des lectures/écritures sur le disque de
  l'appareil, ce qui peut être lent (de quelques millisecondes à plusieurs secondes pour de grosses requêtes). Si une
  telle opération était effectuée sur le thread principal (UI Thread), elle bloquerait toute l'interface utilisateur
  pendant sa durée, rendant l'application non réactive ("freeze"). L'utilisateur aurait une très mauvaise expérience et
  le système Android pourrait même fermer l'application (erreur "Application Not Responding" - ANR). Room nous force
  donc à adopter de bonnes pratiques en exécutant ces tâches longues sur un thread d'arrière-plan.

---

### Conclusion du module

Vous avez construit votre première base de données locale ! Vous savez maintenant comment modéliser vos données, définir
des opérations pour les manipuler et les structurer dans une base de données robuste avec `Room`. C'est une compétence
fondamentale pour toute application qui doit gérer des données structurées.

Cependant, nous avons dû "tricher" en autorisant les requêtes sur le thread principal. C'est une dette technique que
nous devons maintenant rembourser. Comment exécuter ces opérations de base de données (et bientôt, de réseau) de manière
asynchrone, sans jamais geler notre interface ? La réponse se trouve dans le prochain module, avec l'un des outils les
plus puissants de Kotlin : les **Coroutines**.
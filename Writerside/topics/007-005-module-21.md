# Module 21 : Intégrer les Capacités Natives du Téléphone

### **Introduction**

Les applications modernes tirent leur puissance de leur capacité à interagir avec le matériel du téléphone. Permettre à
un utilisateur de prendre une photo, de trouver sa position sur une carte ou de taguer une localisation sont des
fonctionnalités qui créent une expérience riche et engageante.

Dans ce module, nous allons explorer comment intégrer trois des fonctionnalités natives les plus courantes : l'appareil
photo, la géolocalisation et la cartographie. Nous mettrons l'accent sur les bibliothèques Jetpack et les API modernes
qui simplifient ces tâches complexes.

### **Prérequis**

* Connaissance de Kotlin et des principes de base du développement Android (Activity, Fragment).
* Compréhension du cycle de vie des composants Android.
* Android Studio configuré.

### **Objectifs d'Apprentissage**

À la fin de ce module, vous serez capable de :

* Demander les permissions d'exécution (runtime permissions) de manière propre.
* Prendre une photo en utilisant une `Intent` ou la bibliothèque CameraX.
* Obtenir la position GPS de l'utilisateur avec le `FusedLocationProviderClient`.
* Afficher une carte Google Maps et y placer un marqueur.

---

### **1. Le Pilier Fondamental : Gérer les Permissions**

Avant toute chose, l'accès à l'appareil photo et à la géolocalisation requiert l'autorisation explicite de l'
utilisateur. Depuis Android 6.0 (API 23), ces permissions sont demandées à l'exécution (runtime).

**Étape 1 : Déclarer les permissions dans `AndroidManifest.xml`**

```xml
<!-- Pour l'appareil photo -->
<uses-feature android:name="android.hardware.camera" android:required="true"/>
<uses-permission android:name="android.permission.CAMERA"/>

        <!-- Pour la géolocalisation -->
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
<uses-permission android:name="android.permission.ACCESS_COARSE_LOCATION"/>
```

**Étape 2 : Demander la permission à l'exécution**

La méthode moderne utilise l'**Activity Result API**. C'est une approche découplée et plus simple à gérer que l'ancienne
méthode `onRequestPermissionsResult()`.

```kotlin
// Dans votre Fragment ou Activity

// 1. Préparer le lanceur de la demande de permission
private val requestPermissionLauncher =
    registerForActivityResult(ActivityResultContracts.RequestPermission()) { isGranted: Boolean ->
        if (isGranted) {
            // Permission accordée. On peut lancer la logique (ex: prendre une photo)
            Log.d("Permission", "Permission accordée")
            launchCamera()
        } else {
            // Permission refusée. Afficher un message à l'utilisateur.
            Log.d("Permission", "Permission refusée")
            Toast.makeText(
                requireContext(),
                "Permission nécessaire pour utiliser cette fonctionnalité",
                Toast.LENGTH_SHORT
            ).show()
        }
    }

// 2. Créer une fonction pour vérifier et demander la permission
private fun askCameraPermission() {
    when {
        // A. La permission est déjà accordée
        ContextCompat.checkSelfPermission(
            requireContext(),
            android.Manifest.permission.CAMERA
        ) == PackageManager.PERMISSION_GRANTED -> {
            launchCamera()
        }
        // B. (Optionnel) Expliquer pourquoi la permission est nécessaire
        shouldShowRequestPermissionRationale(android.Manifest.permission.CAMERA) -> {
            // Afficher une UI expliquant le besoin (dialogue, snackbar...)
            // Puis appeler requestPermissionLauncher.launch()
        }
        // C. Demander la permission
        else -> {
            requestPermissionLauncher.launch(android.Manifest.permission.CAMERA)
        }
    }
}
```

---

### **2. L'Appareil Photo**

Il existe deux approches principales pour prendre une photo.

#### **Approche 1 : Simple avec une `Intent` (Recommandé pour les cas simples)**

Cette méthode délègue la prise de photo à l'application Appareil Photo déjà installée sur le téléphone.

```kotlin
// 1. Préparer le lanceur qui recevra l'image (un simple Bitmap)
private val takePictureLauncher =
    registerForActivityResult(ActivityResultContracts.TakePicturePreview()) { bitmap: Bitmap? ->
        if (bitmap != null) {
            myImageView.setImageBitmap(bitmap)
        }
    }

// 2. Fonction pour lancer l'appareil photo
fun launchCamera() {
    takePictureLauncher.launch()
}

// 3. Le bouton qui déclenche le tout
myButton.setOnClickListener {
    // On utilise la fonction de gestion des permissions vue plus haut
    askCameraPermission()
}
```

#### **Approche 2 : Avancée avec CameraX (Pour une UI personnalisée)**

CameraX est une bibliothèque Jetpack qui simplifie énormément l'utilisation de l'API Camera2. Elle est lifecycle-aware
et gère les spécificités de chaque appareil pour vous.

**Dépendances (`build.gradle`)**

```groovy
def camerax_version = "1.1.0" // Vérifier la dernière version
implementation "androidx.camera:camera-core:${camerax_version}"
implementation "androidx.camera:camera-camera2:${camerax_version}"
implementation "androidx.camera:camera-lifecycle:${camerax_version}"
implementation "androidx.camera:camera-view:${camerax_version}"
```

**Utilisation (conceptuelle)**
L'implémentation est plus complexe, mais voici le principe :

1. Ajouter un `<PreviewView>` à votre layout XML.
2. Dans votre code, créer des "cas d'utilisation" (`UseCase`) : `Preview`, `ImageCapture`.
3. Lier ces cas d'utilisation au cycle de vie de votre Fragment/Activity.

```kotlin
// Extrait conceptuel
fun startCamera() {
    val cameraProviderFuture = ProcessCameraProvider.getInstance(requireContext())
    cameraProviderFuture.addListener({
        val cameraProvider = cameraProviderFuture.get()

        // Use case pour l'aperçu
        val preview = Preview.Builder().build().also {
            it.setSurfaceProvider(viewFinder.surfaceProvider) // viewFinder est votre PreviewView
        }

        // Use case pour la capture d'image
        imageCapture = ImageCapture.Builder().build()

        val cameraSelector = CameraSelector.DEFAULT_BACK_CAMERA

        try {
            cameraProvider.unbindAll()
            // Lier les use cases au cycle de vie
            cameraProvider.bindToLifecycle(
                this, cameraSelector, preview, imageCapture
            )
        } catch (exc: Exception) {
            Log.e("CameraX", "Échec de la liaison", exc)
        }
    }, ContextCompat.getMainExecutor(requireContext()))
}
```

---

### **3. La Géolocalisation**

L'API recommandée est le **Fused Location Provider** des services Google Play. Elle combine intelligemment le GPS, le
Wi-Fi et les réseaux cellulaires pour fournir la meilleure position possible tout en optimisant la batterie.

**Dépendance (`build.gradle`)**

```groovy
implementation 'com.google.android.gms:play-services-location:21.0.1' // Vérifier la dernière version
```

**Utilisation**

```kotlin
// Dans votre Fragment ou Activity
private lateinit var fusedLocationClient: FusedLocationProviderClient

// Dans onCreate() ou onViewCreated()
fusedLocationClient = LocationServices.getFusedLocationProviderClient(requireActivity())

// Fonction pour obtenir la dernière position connue (rapide mais peut être nulle)
@SuppressLint("MissingPermission") // La permission est vérifiée avant l'appel
private fun getLastLocation() {
    // Vérifier les permissions (ACCESS_FINE_LOCATION) avant d'appeler cette fonction !
    fusedLocationClient.lastLocation
        .addOnSuccessListener { location: Location? ->
            if (location != null) {
                val latitude = location.latitude
                val longitude = location.longitude
                myTextView.text = "Lat: $latitude, Lon: $longitude"
            } else {
                Toast.makeText(requireContext(), "Position non disponible", Toast.LENGTH_SHORT).show()
                // Ici, on pourrait déclencher une demande de mise à jour de la position
            }
        }
}
```

**Bonne pratique :** Toujours vérifier les permissions avant d'appeler `fusedLocationClient.lastLocation`.

---

### **4. La Cartographie**

Le **SDK Google Maps pour Android** est la solution standard pour intégrer des cartes.

**Étape 1 : Configuration**

1. Allez sur la **Google Cloud Platform Console**, créez un projet et activez le "Maps SDK for Android".
2. Créez une clé d'API.
3. Ajoutez votre clé dans le fichier `local.properties` (pour la sécurité) ou directement dans `AndroidManifest.xml`.

**Étape 2 : Dépendances et Manifest**

**Dépendance (`build.gradle`)**

```groovy
implementation 'com.google.android.gms:play-services-maps:18.1.0' // Vérifier la dernière version
```

**`AndroidManifest.xml`**

```xml

<application ...>
        ...
<meta-data
android:name="com.google.android.geo.API_KEY"
android:value="VOTRE_CLE_API_ICI"/>
        </application>
```

**Étape 3 : Afficher une carte**

La méthode la plus simple est d'utiliser un `SupportMapFragment`.

**Layout XML (`activity_main.xml`)**

```xml

<androidx.fragment.app.FragmentContainerView
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:id="@+id/map"
        android:name="com.google.android.gms.maps.SupportMapFragment"
        android:layout_width="match_parent"
        android:layout_height="match_parent"/>
```

**Code (dans `MainActivity.kt`)**

```kotlin
class MainActivity : AppCompatActivity(), OnMapReadyCallback {

    private lateinit var googleMap: GoogleMap

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContentView(R.layout.activity_main)

        // Récupérer le fragment et notifier quand la carte est prête
        val mapFragment = supportFragmentManager
            .findFragmentById(R.id.map) as SupportMapFragment
        mapFragment.getMapAsync(this)
    }

    // Cette fonction est appelée quand la carte est prête à être utilisée
    override fun onMapReady(map: GoogleMap) {
        googleMap = map

        // Exemple : Ajouter un marqueur à Sydney, Australie, et déplacer la caméra
        val sydney = LatLng(-34.0, 151.0)
        googleMap.addMarker(MarkerOptions().position(sydney).title("Marqueur à Sydney"))
        googleMap.moveCamera(CameraUpdateFactory.newLatLng(sydney))
    }
}
```

---

### **Résumé et Bonnes Pratiques**

* **Permissions d'abord :** Ne jamais essayer d'accéder à une ressource sans avoir vérifié et obtenu la permission.
  Informez l'utilisateur si la permission est refusée.
* **Cycle de vie :** Utilisez des bibliothèques lifecycle-aware (comme CameraX) et assurez-vous de stopper les mises à
  jour de localisation (si vous en demandez en continu) dans `onPause()` ou `onStop()` pour préserver la batterie.
* **Thread principal :** Les opérations de caméra, de localisation et de réseau peuvent être lentes. Les API modernes
  gèrent souvent cela pour vous, mais gardez à l'esprit de ne pas bloquer le thread UI.
* **Dégradation gracieuse :** Que se passe-t-il si l'utilisateur n'a pas de GPS ? Ou refuse la permission ? Votre
  application doit continuer à fonctionner de manière prévisible.

### **Exercices Pratiques**

1. **"Photo Taggée" :** Créez une application avec un bouton. Quand on clique :
    * Demandez les permissions pour la caméra et la localisation.
    * Obtenez la position GPS actuelle.
    * Lancez l'appareil photo.
    * Affichez la photo prise avec, en dessous, les coordonnées (latitude, longitude) où elle a été prise.

2. **"Carte de Souvenirs" :** Améliorez l'exercice 1.
    * Affichez une carte Google Maps.
    * Après avoir pris une photo, placez un marqueur sur la carte à l'endroit où la photo a été prise.
    * (Bonus) Quand l'utilisateur clique sur le marqueur, affichez la photo correspondante dans une petite fenêtre
      d'information.
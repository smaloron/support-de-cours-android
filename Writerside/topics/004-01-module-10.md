# Module 10 : Persistance des Données Simples (`SharedPreferences`)

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Identifier les cas d'usage appropriés pour les `SharedPreferences`.
* Lire et écrire des données simples (clé-valeur) de manière synchrone.
* Comprendre la différence entre `commit()` et `apply()`.

### Introduction

Imaginez que vous voulez noter une information très simple, comme le score le plus élevé d'un joueur ou si l'utilisateur
préfère le mode sombre. Vous n'allez pas créer une base de données complexe pour ça. Vous allez simplement prendre un
post-it et l'écrire dessus.

Les `SharedPreferences` sont exactement cela : le "post-it" numérique de votre application. C'est un mécanisme simple et
efficace pour stocker de petites quantités de données primitives (booléens, chaînes de caractères, nombres) sous forme
de paires clé-valeur. C'est la solution parfaite pour les préférences utilisateur, les réglages, ou de petites données
d'état.

### Notions abordées

* Cas d'usage des SharedPreferences
* Lecture et Écriture

---

### Cas d'usage des SharedPreferences

#### Introduction à la notion

Savoir quand utiliser le bon outil est essentiel. Vous n'utilisez pas un marteau-piqueur pour planter un clou. De la
même manière, `SharedPreferences` est un outil léger pour des besoins légers.

#### Explication de la notion

Les `SharedPreferences` sont idéales pour stocker :

* **Des réglages utilisateur :** Mode sombre (Boolean), langue préférée (String), notifications activées (Boolean).
* **Des données d'état simples :** Le score le plus élevé (Int), le nom du dernier utilisateur connecté (String), si le
  tutoriel a déjà été montré (Boolean).
* **Des jetons d'authentification simples.**

Elles ne sont **PAS** faites pour :

* Stocker des données complexes ou structurées (listes d'objets, etc.).
* Stocker de grandes quantités de données.
* Stocker des données relationnelles.

Pour ces cas, nous utiliserons la base de données `Room` (Module 11).

---

### Lecture et Écriture

#### Introduction à la notion {id="introduction-la-notion_1"}

Interagir avec le "post-it" (`SharedPreferences`) se fait en deux étapes très simples : pour écrire, on demande la
permission d'éditer, on écrit nos paires clé-valeur, et on valide. Pour lire, on demande simplement à voir le post-it et
on lit la valeur associée à une clé, en prévoyant une valeur par défaut au cas où rien n'est écrit.

#### Explication de la notion {id="explication-de-la-notion_1"}

Le système gère un fichier XML pour votre application où ces données sont stockées. L'accès se fait via l'objet
`Context`.

**1. Obtenir une instance de SharedPreferences**

```kotlin
// Dans une Activity ou un Fragment, `this` ou `requireContext()` est un Context
val sharedPref = activity?.getSharedPreferences(
    "fr.formation.myapp.PREFERENCE_FILE_KEY", // Nom unique pour votre fichier de prefs
    Context.MODE_PRIVATE // Mode privé: seul votre app peut y accéder
)
```

**2. Écrire des données**
L'écriture se fait via un `Editor`.

```kotlin
val editor = sharedPref.edit()
editor.putString("username_key", "Alice")
editor.putInt("highscore_key", 1000)
editor.putBoolean("dark_mode_enabled_key", true)

// Pour valider les changements
editor.apply() // Asynchrone, recommandé
// ou
// editor.commit() // Synchrone, plus rare, renvoie un boolean
```

* **`apply()`** : Modifie les SharedPreferences en mémoire immédiatement mais écrit sur le disque de manière *
  *asynchrone**. Ne renvoie pas de confirmation. C'est la méthode à privilégier dans 99% des cas car elle ne bloque pas
  le thread principal.
* **`commit()`** : Écrit les données sur le disque de manière **synchrone**. Bloque le thread principal jusqu'à ce que
  l'écriture soit terminée. Renvoie `true` si l'écriture a réussi. À n'utiliser que si vous avez besoin de savoir
  immédiatement si l'écriture a fonctionné.

**3. Lire des données**
La lecture est directe. Il faut toujours fournir une **valeur par défaut** au cas où la clé n'existe pas.

```kotlin
val username = sharedPref.getString("username_key", "Guest") // "Guest" si la clé n'existe pas
val highscore = sharedPref.getInt("highscore_key", 0)
val isDarkMode = sharedPref.getBoolean("dark_mode_enabled_key", false)
```

```plantuml
@startuml
title Flux d'écriture et lecture dans SharedPreferences

actor User
participant Fragment
participant SharedPreferences as SP

User -> Fragment : Coche "Mode Sombre"
activate Fragment
Fragment -> SP : getSharedPreferences()
Fragment -> SP : edit()
Fragment -> SP : putBoolean("dark_mode", true)
Fragment -> SP : apply()
deactivate Fragment

... plus tard ...

User -> Fragment : Relance l'application
activate Fragment
Fragment -> SP : getSharedPreferences()
Fragment -> SP : getBoolean("dark_mode", false)
SP --> Fragment : Renvoie `true`
deactivate Fragment
@enduml
```

#### Exercice 1 : Sauvegarder et restaurer le nom de l'utilisateur

**Énoncé :**
Créez une interface simple avec un `EditText`, un bouton "Sauvegarder", et un `TextView`.

1. Quand l'utilisateur clique sur "Sauvegarder", sauvegardez le nom entré dans les `SharedPreferences`.
2. Au démarrage de l'application (`onCreate`), lisez le nom depuis les `SharedPreferences` et, s'il existe, affichez-le
   dans le `TextView` avec un message de bienvenue.

##### **Correction exercice 1** {collapsible='true'}

**1. `activity_main.xml`**

```xml

<LinearLayout
        xmlns:android="http://schemas.android.com/apk/res/android"
        android:layout_width="match_parent"
        android:layout_height="match_parent"
        android:orientation="vertical"
        android:padding="16dp">

    <EditText
            android:id="@+id/nameEditText"
            android:layout_width="match_parent"
            android:layout_height="wrap_content"
            android:hint="Entrez votre nom"/>

    <Button
            android:id="@+id/saveButton"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:text="Sauvegarder"/>

    <TextView
            android:id="@+id/welcomeTextView"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginTop="20dp"
            android:text="Bienvenue !"/>
</LinearLayout>
```

**2. `MainActivity.kt`**

```kotlin
package fr.formation.sharedprefs

import android.content.Context
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import fr.formation.sharedprefs.databinding.ActivityMainBinding

// On définit nos clés comme des constantes pour éviter les fautes de frappe
private const val PREFS_NAME = "fr.formation.sharedprefs.user_prefs"
private const val KEY_USERNAME = "username"

class MainActivity : AppCompatActivity() {
    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // On charge les préférences au démarrage
        loadData()

        binding.saveButton.setOnClickListener {
            saveData()
        }
    }

    private fun saveData() {
        // 1. Obtenir une instance de SharedPreferences
        val sharedPref = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        // 2. Écrire les données
        with(sharedPref.edit()) {
            putString(KEY_USERNAME, binding.nameEditText.text.toString())
            apply() // On utilise apply()
        }
    }

    private fun loadData() {
        // 1. Obtenir une instance de SharedPreferences
        val sharedPref = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        // 2. Lire la donnée avec une valeur par défaut
        val savedUsername = sharedPref.getString(KEY_USERNAME, null)

        // 3. Mettre à jour l'UI si une valeur a été trouvée
        if (savedUsername != null) {
            binding.welcomeTextView.text = "Bienvenue, $savedUsername !"
            binding.nameEditText.setText(savedUsername)
        }
    }
}
```

---

## TP 10 : Un interrupteur de réglages persistants

**Objectif :** Créer un écran de réglages simple avec un interrupteur (Switch) pour activer/désactiver une
fonctionnalité (par exemple, les notifications). L'état de l'interrupteur doit être sauvegardé et restauré à chaque
lancement de l'application.

<procedure>

1. **Créez le layout :**
    * Utilisez un `androidx.appcompat.widget.SwitchCompat` dans votre layout.
    * Ajoutez un `TextView` à côté pour décrire le réglage ("Activer les notifications").
2. **Dans `onCreate` :**
    * Appelez une fonction `loadSettings()` qui va lire la valeur booléenne associée à l'état des notifications depuis
      les `SharedPreferences`. La valeur par défaut doit être `true` (activé).
    * Utilisez cette valeur pour définir l'état initial de votre `SwitchCompat` (`mySwitch.isChecked = savedValue`).
3. **Gérez l'interaction :**
    * Ajoutez un écouteur sur le `SwitchCompat` avec `setOnCheckedChangeListener`.
    * À l'intérieur de cet écouteur, appelez une fonction `saveSettings(isChecked: Boolean)` qui sauvegarde le nouvel
      état de l'interrupteur dans les `SharedPreferences`.
4. **Testez :**
    * Lancez l'application. L'interrupteur est activé.
    * Désactivez-le.
    * Fermez complètement l'application (en la "swipant" depuis les applications récentes).
    * Relancez l'application. L'interrupteur doit être resté dans l'état désactivé.

</procedure>

## Correction du TP 10 {collapsible="true"}


#### Étape 1 : Le Layout (`activity_main.xml`)

On utilise un `LinearLayout` horizontal pour placer le `TextView` et le `SwitchCompat` côte à côte. Le `layout_weight="1"` sur le `TextView` garantit qu'il prendra tout l'espace disponible, poussant l'interrupteur à droite.

**Fichier : `res/layout/activity_main.xml`**
```xml
<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:tools="http://schemas.android.com/tools"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:orientation="horizontal"
    android:padding="16dp"
    android:gravity="center_vertical"
    tools:context=".MainActivity">

    <!-- Le libellé pour décrire le réglage -->
    <TextView
        android:id="@+id/settingsLabelTextView"
        android:layout_width="0dp"
        android:layout_height="wrap_content"
        android:layout_weight="1"
        android:text="Activer les notifications"
        android:textSize="18sp" />

    <!-- L'interrupteur pour activer/désactiver le réglage -->
    <androidx.appcompat.widget.SwitchCompat
        android:id="@+id/notificationSwitch"
        android:layout_width="wrap_content"
        android:layout_height="wrap_content" />

</LinearLayout>
```

---

#### Étape 2 & 3 : L'Activité (`MainActivity.kt`) et la Logique

Voici le code complet de `MainActivity.kt`. Il contient la logique pour charger, sauvegarder et réagir aux changements de l'interrupteur.

**Fichier : `MainActivity.kt`**
```kotlin
package com.example.yourapplication // Remplacez par votre package

import android.content.Context
import android.content.SharedPreferences
import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import com.example.yourapplication.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private lateinit var sharedPreferences: SharedPreferences

    // C'est une bonne pratique de définir les noms et les clés comme constantes
    // pour éviter les fautes de frappe.
    companion object {
        const val PREFS_NAME = "MyAppSettingsPrefs"
        const val KEY_NOTIFICATIONS_ENABLED = "key_notifications_enabled"
    }

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Initialiser SharedPreferences une seule fois
        sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)

        // 1. Charger les réglages au démarrage
        loadSettings()

        // 2. Écouter les changements sur l'interrupteur
        // Le premier paramètre de setOnCheckedChangeListener 
        // représente la vue modifiée
        // Ici nous n'en avons pas besoin et kotlin nous permet de remplacer
        // les arguments inutilisés par un _
        binding.notificationSwitch.setOnCheckedChangeListener { _, isChecked ->
            // `isChecked` est un Boolean fourni par le listener.
            // Il représente le nouvel état de l'interrupteur.
            saveSettings(isChecked)
        }
    }

    /**
     * Lit la valeur depuis SharedPreferences et met à jour l'interface utilisateur.
     */
    private fun loadSettings() {
        // On lit la valeur booléenne associée à notre clé.
        // Si la clé n'existe pas (premier lancement), on utilise la valeur par défaut : `true`.
        val isNotificationsEnabled = sharedPreferences.getBoolean(KEY_NOTIFICATIONS_ENABLED, true)

        // On met à jour l'état de l'interrupteur avec la valeur chargée.
        binding.notificationSwitch.isChecked = isNotificationsEnabled
    }

    /**
     * Sauvegarde la valeur de l'interrupteur dans SharedPreferences.
     * @param isChecked Le nouvel état à sauvegarder.
     */
    private fun saveSettings(isChecked: Boolean) {
        // Pour écrire dans les SharedPreferences, 
        // nous avons besoin d'un Editor.
        val editor = sharedPreferences.edit()

        // On met la valeur booléenne dans l'éditeur avec notre clé.
        editor.putBoolean(KEY_NOTIFICATIONS_ENABLED, isChecked)

        // Très important : on applique les changements.
        // .apply() est asynchrone et recommandé 
        // pour les opérations sur le thread UI.
        editor.apply()
    }
}
```

---

#### Explications Détaillées du Code

##### 1. `SharedPreferences` : Qu'est-ce que c'est ?
C'est un mécanisme de stockage simple fourni par Android pour sauvegarder des paires **clé-valeur** de types primitifs (Boolean, Int, String, etc.). C'est idéal pour stocker des préférences utilisateur, des réglages simples ou des petits drapeaux (`flags`).

##### 2. Les Constantes (`companion object`)
```kotlin
companion object {
    const val PREFS_NAME = "MyAppSettingsPrefs"
    const val KEY_NOTIFICATIONS_ENABLED = "key_notifications_enabled"
}
```
*   **`PREFS_NAME`** : C'est le nom du fichier XML où Android stockera physiquement vos données (dans le stockage interne de l'application). Utiliser un nom unique permet d'isoler les préférences de différentes parties de votre application.
*   **`KEY_NOTIFICATIONS_ENABLED`** : C'est la **clé** unique pour notre valeur. C'est comme le nom d'une variable. Utiliser des constantes évite les erreurs de frappe entre la sauvegarde (`saveSettings`) et la lecture (`loadSettings`).

##### 3. Obtenir une instance de `SharedPreferences`
```kotlin
sharedPreferences = getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)
```
*   `getSharedPreferences()` est une méthode de `Context`.
*   `Context.MODE_PRIVATE` signifie que le fichier de préférences ne sera accessible que par votre application, ce qui est le comportement souhaité dans 99% des cas.

##### 4. La Lecture (`loadSettings`)
```kotlin
val isNotificationsEnabled = sharedPreferences.getBoolean(KEY_NOTIFICATIONS_ENABLED, true)
```
*   `getBoolean()` prend deux arguments :
    1.  La **clé** de la valeur que vous voulez récupérer.
    2.  La **valeur par défaut**. C'est crucial : si la clé n'est pas encore présente dans les `SharedPreferences` (ce qui est le cas au tout premier lancement de l'application), cette valeur par défaut sera retournée. Ici, on retourne `true`, comme demandé.

##### 5. L'Écriture (`saveSettings`)
L'écriture se fait en 3 étapes :
```kotlin
// 1. Obtenir un objet Editor
val editor = sharedPreferences.edit()

// 2. Mettre des valeurs dans l'éditeur
editor.putBoolean(KEY_NOTIFICATIONS_ENABLED, isChecked)

// 3. Appliquer les changements
editor.apply()
```
*   **`.edit()`** : Vous ne pouvez pas modifier les `SharedPreferences` directement. Vous devez passer par un `Editor`.
*   **`.putBoolean()`** : Vous ajoutez ou modifiez la valeur associée à une clé. Si la clé existe, sa valeur est écrasée ; sinon, elle est créée.
*   **`.apply()` vs `.commit()`** :
    *   **`.apply()`** : Sauvegarde les données en arrière-plan (asynchrone). Il ne bloque pas le thread principal (UI) et n'indique pas si la sauvegarde a réussi. **C'est la méthode recommandée.**
    *   **`.commit()`** : Sauvegarde les données immédiatement sur le même thread (synchrone). Il bloque le thread jusqu'à ce que la sauvegarde soit terminée et retourne un booléen indiquant le succès. À n'utiliser que si vous avez absolument besoin de savoir si l'écriture a réussi avant de continuer.

En suivant ces étapes, le cycle de vie de la donnée est complet :
1.  **Au démarrage (`onCreate`)**, `loadSettings` lit la dernière valeur sauvegardée (ou la valeur par défaut) et met à jour l'UI.
2.  **Quand l'utilisateur interagit**, le listener se déclenche et `saveSettings` écrit immédiatement le nouvel état sur le disque.
3.  **Au prochain démarrage**, ce nouvel état est lu, et le cycle recommence.

---

## Auto-évaluation

**1. Dans quel cas est-il préférable d'utiliser `SharedPreferences` plutôt qu'une base de données `Room` ? (QCM)**

* A) Pour stocker une liste de 10 000 produits.
* B) Pour stocker la préférence de l'utilisateur pour le mode sombre.
* C) Pour stocker les messages d'une conversation de chat.
* D) Pour stocker des données qui ont des relations entre elles.

**2. Quelle est la principale différence entre `editor.commit()` et `editor.apply()` ? (QCM)**

* A) `commit()` est asynchrone, `apply()` est synchrone.
* B) `commit()` est la méthode moderne, `apply()` est obsolète.
* C) `commit()` bloque le thread principal, `apply()` ne le bloque pas.
* D) `commit()` ne peut sauvegarder que des `String`, `apply()` peut tout sauvegarder.

**3. Qu'est-ce que le deuxième argument de la méthode `sharedPref.getString("ma_cle", "valeur_par_defaut")` ? (QCM)**

* A) La valeur à sauvegarder.
* B) Le nom du fichier de préférences.
* C) La valeur à retourner si la clé "ma_cle" n'est pas trouvée.
* D) Un message d'erreur à afficher.

**4. Pourquoi est-il considéré comme une bonne pratique de définir les clés des SharedPreferences (`"username_key"`)
comme des constantes ? (Question ouverte)**

**5. Si vous deviez sauvegarder la date et l'heure de la dernière ouverture de l'application, quel type de donnée
utiliseriez-vous et comment le stockeriez-vous dans les SharedPreferences ? (Question ouverte)**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Quand utiliser `SharedPreferences` ?**

* **Réponse : B) Pour stocker la préférence de l'utilisateur pour le mode sombre.**
* **Justification :** C'est une donnée simple, une paire clé-valeur (ex: "dark_mode_enabled": true), ce qui est le cas
  d'usage parfait pour les `SharedPreferences`. Les autres options impliquent des données complexes ou volumineuses, qui
  nécessitent une base de données.

**2. Différence entre `commit()` et `apply()` ?**

* **Réponse : C) `commit()` bloque le thread principal, `apply()` ne le bloque pas.**
* **Justification :** `commit()` est synchrone et effectue l'écriture sur le disque sur le même thread, ce qui peut
  causer des freezes de l'UI. `apply()` est asynchrone, l'écriture se fait en arrière-plan, ce qui est beaucoup plus sûr
  pour les performances de l'application.

**3. Que représente le deuxième argument de `getString()` ?**

* **Réponse : C) La valeur à retourner si la clé "ma_cle" n'est pas trouvée.**
* **Justification :** C'est la valeur par défaut. C'est une mesure de sécurité essentielle pour éviter de recevoir
  `null` et de provoquer un `NullPointerException` si on essaie de lire une préférence qui n'a pas encore été
  sauvegardée.

**4. Pourquoi utiliser des constantes pour les clés ?**

* **Réponse type :** Pour éviter les erreurs de frappe. Si vous écrivez `"username_key"` à un endroit et
  `"user_name_key"` à un autre, le système les traitera comme deux clés différentes. En utilisant une constante (
  `private const val KEY_USERNAME = "username_key"`), vous êtes sûr d'utiliser exactement la même chaîne partout, et si
  vous devez la changer, vous n'avez qu'un seul endroit à modifier.

**5. Comment sauvegarder la date et l'heure ?**

* **Réponse type :** Les `SharedPreferences` ne peuvent pas stocker directement un objet `Date`. La meilleure approche
  est de convertir la date/heure en un type de donnée primitif. Le plus courant est de la stocker sous forme de `Long`
  représentant le nombre de millisecondes depuis l'époque Unix (timestamp). On obtiendrait ce timestamp avec
  `System.currentTimeMillis()`, puis on le sauvegarderait avec `editor.putLong("last_open_timestamp", timestamp)`. Pour
  le relire, on récupérerait le `Long` et on le reconvertirait en objet `Date`.

---

## Conclusion du module

Vous savez maintenant comment donner une mémoire à court terme et pour des données simples à votre application. Les
`SharedPreferences` sont un outil que vous utiliserez constamment pour gérer les petits détails qui rendent une
application personnalisée et agréable à utiliser.

Cependant, le "post-it" a ses limites. Que se passe-t-il lorsque nous devons gérer une collection d'objets structurés,
comme une liste de contacts, de produits ou de notes ? Pour cela, il nous faut une solution plus robuste et organisée :
une base de données. Dans le prochain module, nous allons découvrir `Room`, la bibliothèque recommandée par Google pour
gérer une base de données SQL locale de manière simple et moderne.
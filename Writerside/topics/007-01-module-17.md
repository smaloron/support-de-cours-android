# Module 17 : Injection de Dépendances (Hilt & Koin)

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Expliquer le principe de l'Inversion de Contrôle et de l'Injection de Dépendances (DI).
* Comprendre les problèmes liés à l'instanciation manuelle des dépendances.
* Mettre en place Hilt, la solution de DI recommandée par Google, pour injecter des objets.
* Utiliser les annotations Hilt de base (`@HiltAndroidApp`, `@AndroidEntryPoint`, `@HiltViewModel`, `@Inject`).
* (Alternative) Comprendre les bases de Koin comme solution de DI pure Kotlin.

### Introduction

Imaginez que vous construisez une voiture. Jusqu'à présent, à chaque fois que vous aviez besoin d'un moteur, vous le
construisiez vous-même à partir de zéro, directement à l'intérieur du châssis. Puis vous construisiez la transmission,
puis les roues... C'est ce que nous avons fait en écrivant `val dao = AppDatabase.getDatabase(..).noteDao()` ou
`val repository = NoteRepository(dao)`. C'est **l'objet lui-même qui crée les composants dont il dépend**. C'est long,
répétitif, et si le plan du moteur change, vous devez le modifier partout où vous en construisez un.

L'**Injection de Dépendances (DI)**, c'est comme avoir une usine de fabrication ultra-moderne. Vous ne construisez plus
rien vous-même. Vous déclarez simplement : "Pour cette voiture, j'ai besoin d'un moteur V8 et d'une transmission
automatique". L'usine (le framework de DI) sait exactement comment construire ces composants, comment ils s'assemblent,
et vous les livre "clés en main" au bon endroit, au bon moment. Votre travail n'est plus de fabriquer, mais d'assembler
des pièces déjà fournies.

### Notions abordées

* Le principe de l'Injection de Dépendances
* Hilt : La solution standard recommandée par Google
* Koin : L'alternative pure Kotlin

---

### Le principe de l'Injection de Dépendances

#### Introduction à la notion

Le cœur de la DI est un principe appelé **Inversion de Contrôle (Inversion of Control - IoC)**. Au lieu que votre
objet (`ViewModel`) contrôle la création de ses dépendances (`Repository`), vous inversez ce contrôle et le déléguez à
un système externe (le framework de DI).

#### Explication de la notion

**Sans DI (ce que nous avons fait jusqu'à présent) :**

```kotlin
// Le ViewModel est responsable de la création du Repository.
// C'est un couplage fort.
class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: NoteRepository

    init {
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao) // <-- CRÉATION MANUELLE
    }
}
```

**Problèmes :**

* **Couplage fort :** `NoteViewModel` est étroitement lié à la manière de construire `NoteRepository`.
* **Difficulté à tester :** Comment tester `NoteViewModel` sans une vraie base de données ? On ne peut pas facilement
  lui fournir un "faux" `NoteRepository` pour les tests.
* **Code répétitif (`Boilerplate`) :** Vous devez réécrire cette logique d'initialisation partout.

**Avec DI :**

```kotlin
// Le ViewModel déclare ce dont il a besoin, mais ne le crée pas.
// Hilt fournira le Repository automatiquement.
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository // <-- DÉPENDANCE INJECTÉE
) : ViewModel() {
    // ...
}
```

**Avantages :**

* **Découplage :** Le `ViewModel` ne sait plus comment le `Repository` est créé.
* **Testabilité :** En test, on peut facilement demander au framework de DI de fournir une version "mock" (factice) du
  `Repository`.
* **Centralisation :** La logique de création des objets est définie à un seul endroit.

---

### Hilt : La solution standard recommandée par Google

#### Introduction à la notion {id="introduction-la-notion_1"}

Hilt est la solution d'injection de dépendances officielle pour Android. Il est construit sur une base très puissante (
Dagger) mais la simplifie énormément pour le contexte Android. Hilt utilise des annotations et de la génération de code
pour créer et "câbler" vos dépendances à la **compilation**. Cela le rend très performant et sûr (une erreur de
configuration empêchera votre application de compiler).

#### Mise en place

<procedure title="Configuration de Hilt">

1. **Ajouter les plugins Gradle :**
    * Dans `build.gradle.kts` (niveau **projet**) :
   ```kotlin
   plugins {
       // ...
       id("com.google.dagger.hilt.android") version "2.51" apply false
   }
   ```
    * Dans `build.gradle.kts` (niveau **module :app**) :
   ```kotlin
   plugins {
       // ...
       id("com.google.dagger.hilt.android")
       id("com.google.devtools.ksp") // Hilt utilise KSP
   }
   ```
2. **Ajouter les dépendances :**
    * Dans `build.gradle.kts` (niveau **module :app**) :
   ```kotlin
   dependencies {
       implementation("com.google.dagger:hilt-android:2.51")
       ksp("com.google.dagger:hilt-compiler:2.51")
   }
   ```
3. **Annoter la classe Application :**
    * Créez une classe qui hérite de `Application` et annotez-la avec `@HiltAndroidApp`.
    * N'oubliez pas de la déclarer dans votre `AndroidManifest.xml`.
   ```kotlin
   // Dans MyApp.kt
   @HiltAndroidApp
   class MyApp : Application() {}

   // Dans AndroidManifest.xml
   <application
       android:name=".MyApp"
       ... >
   ```

</procedure>

#### Utilisation

1. **`@AndroidEntryPoint`** : Annotez vos classes Android (Activities, Fragments) pour que Hilt puisse y injecter des
   dépendances.
2. **`@Inject constructor`** : Annotez le constructeur d'une de vos classes (ex: `NoteRepository`) pour apprendre à Hilt
   comment la créer.
3. **`@HiltViewModel`** : Annotez votre `ViewModel` pour que Hilt le gère. La dépendance est ensuite injectée via le
   constructeur.
4. **Modules Hilt (`@Module` et `@Provides`)** : Pour les choses que vous ne possédez pas (comme une interface ou une
   classe d'une bibliothèque externe comme Room ou Retrofit), vous devez créer un "module" pour apprendre à Hilt comment
   les fournir.

#### Exemple : Refactoriser notre application de notes avec Hilt

**1. `AppModule.kt` (Le "mode d'emploi" pour Hilt)**

```kotlin
package fr.formation.notes.di

import android.content.Context
import androidx.room.Room
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import fr.formation.notes.data.AppDatabase
import fr.formation.notes.data.NoteDao
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class) // Ces dépendances vivront aussi longtemps que l'app
object AppModule {

    @Provides
    @Singleton // On veut une seule instance de la BDD
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "notes_database"
        ).build()
    }

    @Provides
    fun provideNoteDao(appDatabase: AppDatabase): NoteDao {
        // Hilt sait comment créer AppDatabase (grâce à la méthode au-dessus),
        // il peut donc l'utiliser pour fournir le NoteDao.
        return appDatabase.noteDao()
    }
}
```

**2. `NoteRepository.kt`**

```kotlin
// Hilt sait maintenant comment créer NoteDao, il peut donc l'injecter ici.
class NoteRepository @Inject constructor(private val noteDao: NoteDao) {
    // ...
}
```

**3. `NoteViewModel.kt`**

```kotlin
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository
) : ViewModel() {
    // ...
}
```

**4. `MainActivity.kt`**

```kotlin
@AndroidEntryPoint // Indique que Hilt doit injecter des dépendances ici
class MainActivity : AppCompatActivity() {
    // L'instanciation est toujours déléguée, mais maintenant gérée par Hilt.
    private val viewModel: NoteViewModel by viewModels()
    // ...
}
```

Et voilà ! Plus aucune création manuelle. Le code est propre, découplé et testable.

---

### Koin : L'alternative pure Kotlin

#### Introduction à la notion {id="introduction-la-notion_2"}

Koin est une autre bibliothèque de DI très populaire. Sa philosophie est différente : elle n'utilise pas de génération
de code. C'est un framework pur Kotlin, souvent considéré comme plus simple à apprendre et à configurer. Il fonctionne à
l'**exécution** (runtime), ce qui le rend moins performant que Hilt mais plus flexible.

#### Utilisation {id="utilisation_1"}

1. **Définir un module :** Vous créez un "module" Koin où vous décrivez comment créer vos objets.
   ```kotlin
   val appModule = module {
       // Crée une seule instance (Singleton) de AppDatabase
       single { AppDatabase.getDatabase(androidContext()) }
       // Crée une instance de NoteDao à chaque fois qu'elle est demandée (factory)
       factory { get<AppDatabase>().noteDao() }
       // Crée un singleton du Repository
       single { NoteRepository(get()) } // `get()` résout la dépendance (NoteDao)

       // Déclaration spéciale pour un ViewModel
       viewModel { NoteViewModel(get()) } // `get()` résout NoteRepository
   }
   ```
2. **Démarrer Koin** dans la classe `Application` :
   ```kotlin
   class MyApp : Application() {
       override fun onCreate() {
           super.onCreate()
           startKoin {
               androidContext(this@MyApp)
               modules(appModule)
           }
       }
   }
   ```
3. **Injecter dans les classes Android :**
   ```kotlin
   class MainActivity : AppCompatActivity() {
       // Injection du ViewModel gérée par Koin
       private val viewModel: NoteViewModel by viewModel()
       // ...
   }
   ```

#### Hilt vs. Koin : Le choix

| Caractéristique       | Hilt (Dagger)                               | Koin                                        |
|-----------------------|---------------------------------------------|---------------------------------------------|
| **Vérification**      | À la **compilation** (plus sûr)             | À l'**exécution** (plus de risques d'erreurs) |
| **Performance**       | Plus rapide (pas de réflexion au runtime)   | Moins rapide (utilise la réflexion)         |
| **Configuration**     | Plus complexe (plugins, annotations...)     | Très simple (une dépendance, un module)     |
| **Écosystème**        | Standard de Google, intégré à Jetpack       | Communauté forte, pure Kotlin               |
| **"Magie"**           | Beaucoup de génération de code "magique"    | Plus explicite et facile à déboguer         |

**Conclusion :** Pour les débutants et les projets où la simplicité prime, Koin peut être un excellent choix. Pour les
projets professionnels, à grande échelle et où la performance et la sécurité à la compilation sont critiques, **Hilt est
le standard de l'industrie**.

---

### TP 17 : Refactoriser l'application "Dog Facts" avec Hilt

**Objectif :** Reprendre le TP du module 13 et le refactoriser pour utiliser Hilt pour injecter le service Retrofit et
le ViewModel.

<procedure>

1. **Configurez Hilt** dans le projet (plugins, dépendances, classe `Application`).
2. **Créez un module Hilt** (`NetworkModule.kt`) pour apprendre à Hilt comment fournir l'instance de Retrofit et l'
   `ApiService`.
   ```kotlin
   @Module
   @InstallIn(SingletonComponent::class)
   object NetworkModule {

       @Provides
       @Singleton
       fun provideRetrofit(): Retrofit {
           // ... votre code de création de Retrofit ...
       }

       @Provides
       @Singleton
       fun provideApiService(retrofit: Retrofit): ApiService {
           return retrofit.create(ApiService::class.java)
       }
   }
   ```
3. **Créez un `DogFactRepository`** qui prendra `ApiService` en dépendance (via `@Inject constructor`). Sa seule méthode
   sera `suspend fun getNewFact()`.
4. **Refactorisez votre `DogFactViewModel`** pour qu'il soit annoté avec `@HiltViewModel` et qu'il injecte le
   `DogFactRepository` dans son constructeur. La logique d'appel réseau doit maintenant se trouver dans le ViewModel.
5. **Annotez votre `MainActivity`** avec `@AndroidEntryPoint`.
6. **Supprimez toute création manuelle** de `RetrofitClient`, `Repository` ou `ViewModel`. L'Activity doit simplement
   obtenir le ViewModel via `by viewModels()`.

</procedure>

---

### Auto-évaluation

**1. Quel est le principe de l'Inversion de Contrôle ? (QCM)**

* A) La View contrôle le ViewModel.
* B) Une classe ne crée pas ses propres dépendances, mais les reçoit d'une source externe.
* C) Les dépendances sont créées au moment de l'exécution plutôt qu'à la compilation.
* D) Le code est exécuté dans l'ordre inverse de son écriture.

**2. Quelle annotation Hilt doit-on mettre sur une Activity ou un Fragment pour activer l'injection ? (QCM)**

* A) `@HiltActivity`
* B) `@Inject`
* C) `@AndroidEntryPoint`
* D) `@Module`

**3. Dans Koin, quelle fonction du DSL utilise-t-on pour déclarer une dépendance qui doit être une instance unique (
Singleton) ? (QCM)**

* A) `factory { ... }`
* B) `singleton { ... }`
* C) `single { ... }`
* D) `viewModel { ... }`

**4. Expliquez pourquoi l'injection de dépendances rend le code plus facile à tester. (Question ouverte)**

**5. Quel est, selon vous, le principal compromis à faire lorsque l'on choisit Koin plutôt que Hilt ? (Question ouverte)
**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Quel est le principe de l'Inversion de Contrôle ?**

* **Réponse : B) Une classe ne crée pas ses propres dépendances, mais les reçoit d'une source externe.**
* **Justification :** C'est la définition même de l'IoC. Le "contrôle" de l'instanciation est inversé, passant de
  l'objet lui-même au framework de DI.

**2. Quelle annotation Hilt pour activer l'injection dans une Activity/Fragment ?**

* **Réponse : C) `@AndroidEntryPoint`**
* **Justification :** Cette annotation signale à Hilt que cette classe Android est un "point d'entrée" où des
  dépendances devront être injectées. Hilt génère alors le code nécessaire pour le faire.

**3. Quelle fonction Koin pour un Singleton ?**

* **Réponse : C) `single { ... }`**
* **Justification :** `single` est la fonction du DSL de Koin pour déclarer qu'une seule et même instance de l'objet
  doit être créée et réutilisée pour toute la durée de vie de l'application.

**4. Pourquoi la DI facilite-t-elle les tests ?**

* **Réponse type :** Parce qu'elle permet de substituer facilement les vraies dépendances par des fausses (des "mocks"
  ou "fakes"). Par exemple, pour tester un `ViewModel` qui dépend d'un `Repository`, on peut configurer le framework de
  DI pour qu'il injecte un `FakeRepository` qui renvoie des données en mémoire au lieu de faire un vrai appel réseau ou
  BDD. Cela rend les tests rapides, fiables et isolés, car on ne teste que la logique du `ViewModel` sans dépendre de
  systèmes externes (comme un serveur qui pourrait être en panne).

**5. Quel est le principal compromis en choisissant Koin plutôt que Hilt ?**

* **Réponse type :** Le principal compromis est de sacrifier la **sécurité à la compilation** pour la **simplicité de
  configuration**. Avec Koin, si vous oubliez de déclarer une dépendance dans un module, vous ne le découvrirez qu'à l'
  exécution, lorsque l'application plantera. Avec Hilt, le même oubli provoquerait une erreur de compilation, vous
  forçant à corriger le problème avant même de pouvoir lancer l'application. On échange donc de la robustesse et de la
  performance contre une courbe d'apprentissage et une mise en place plus douces.
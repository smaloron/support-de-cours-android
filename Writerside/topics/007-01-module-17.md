# Module 17 : Injection de Dépendances (Hilt & Koin)

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Expliquer le principe de l'Inversion de Contrôle et de l'Injection de Dépendances (DI).
* Comprendre les problèmes liés à l'instanciation manuelle des dépendances.
* Mettre en place Hilt, la solution de DI recommandée par Google, pour injecter des objets.
* Utiliser les annotations Hilt de base (`@HiltAndroidApp`, `@AndroidEntryPoint`, `@HiltViewModel`, `@Inject`).
* (Alternative) Comprendre les bases de Koin comme solution de DI pure Kotlin.

### Introduction

Imaginez que vous construisez une voiture. Jusqu'à présent, à chaque fois que vous aviez besoin d'un moteur, vous le
construisiez vous-même à partir de zéro, directement à l'intérieur du châssis. Puis vous construisiez la transmission,
puis les roues... C'est ce que nous avons fait en écrivant `val dao = AppDatabase.getDatabase(..).noteDao()` ou
`val repository = NoteRepository(dao)`. C'est **l'objet lui-même qui crée les composants dont il dépend**. C'est long,
répétitif, et si le plan du moteur change, vous devez le modifier partout où vous en construisez un.

L'**Injection de Dépendances (DI)**, c'est comme avoir une usine de fabrication ultra-moderne. Vous ne construisez plus
rien vous-même. Vous déclarez simplement : "Pour cette voiture, j'ai besoin d'un moteur V8 et d'une transmission
automatique". L'usine (le framework de DI) sait exactement comment construire ces composants, comment ils s'assemblent,
et vous les livre "clés en main" au bon endroit, au bon moment. Votre travail n'est plus de fabriquer, mais d'assembler
des pièces déjà fournies.

### Notions abordées

* Le principe de l'Injection de Dépendances
* Hilt : La solution standard recommandée par Google
* Koin : L'alternative pure Kotlin

---

### Le principe de l'Injection de Dépendances

#### Introduction à la notion

Le cœur de la DI est un principe appelé **Inversion de Contrôle (Inversion of Control - IoC)**. Au lieu que votre
objet (`ViewModel`) contrôle la création de ses dépendances (`Repository`), vous inversez ce contrôle et le déléguez à
un système externe (le framework de DI).

#### Explication de la notion

**Sans DI (ce que nous avons fait jusqu'à présent) :**

```kotlin
// Le ViewModel est responsable de la création du Repository.
// C'est un couplage fort.
class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: NoteRepository

    init {
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao) // <-- CRÉATION MANUELLE
    }
}
```

**Problèmes :**

* **Couplage fort :** `NoteViewModel` est étroitement lié à la manière de construire `NoteRepository`.
* **Difficulté à tester :** Comment tester `NoteViewModel` sans une vraie base de données ? On ne peut pas facilement
  lui fournir un "faux" `NoteRepository` pour les tests.
* **Code répétitif (`Boilerplate`) :** Vous devez réécrire cette logique d'initialisation partout.

**Avec DI :**

```kotlin
// Le ViewModel déclare ce dont il a besoin, mais ne le crée pas.
// Hilt fournira le Repository automatiquement.
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository // <-- DÉPENDANCE INJECTÉE
) : ViewModel() {
    // ...
}
```

**Avantages :**

* **Découplage :** Le `ViewModel` ne sait plus comment le `Repository` est créé.
* **Testabilité :** En test, on peut facilement demander au framework de DI de fournir une version "mock" (factice) du
  `Repository`.
* **Centralisation :** La logique de création des objets est définie à un seul endroit.

---

### Hilt : La solution standard recommandée par Google

#### Introduction à la notion {id="introduction-la-notion_1"}

Hilt est la solution d'injection de dépendances officielle pour Android. Il est construit sur une base très puissante (
Dagger) mais la simplifie énormément pour le contexte Android. Hilt utilise des annotations et de la génération de code
pour créer et "câbler" vos dépendances à la **compilation**. Cela le rend très performant et sûr (une erreur de
configuration empêchera votre application de compiler).

#### Mise en place

<procedure title="Configuration de Hilt">

1. **Ajouter les plugins Gradle :**
    * Dans `build.gradle.kts` (niveau **projet**) :
   ```kotlin
   plugins {
       // ...
       id("com.google.dagger.hilt.android") version "2.51" apply false
   }
   ```
    * Dans `build.gradle.kts` (niveau **module :app**) :
   ```kotlin
   plugins {
       // ...
       id("com.google.dagger.hilt.android")
       id("com.google.devtools.ksp") // Hilt utilise KSP
   }
   ```
2. **Ajouter les dépendances :**
    * Dans `build.gradle.kts` (niveau **module :app**) :
   ```kotlin
   dependencies {
       implementation("com.google.dagger:hilt-android:2.51")
       ksp("com.google.dagger:hilt-compiler:2.51")
   }
   ```
3. **Annoter la classe Application :**
    * Créez une classe qui hérite de `Application` et annotez-la avec `@HiltAndroidApp`.
    * N'oubliez pas de la déclarer dans votre `AndroidManifest.xml`.
   ```kotlin
   // Dans MyApp.kt
   @HiltAndroidApp
   class MyApp : Application() {}

   // Dans AndroidManifest.xml
   <application
       android:name=".MyApp"
       ... >
   ```

</procedure>

#### Utilisation

1. **`@AndroidEntryPoint`** : Annotez vos classes Android (Activities, Fragments) pour que Hilt puisse y injecter des
   dépendances.
2. **`@Inject constructor`** : Annotez le constructeur d'une de vos classes (ex: `NoteRepository`) pour apprendre à Hilt
   comment la créer.
3. **`@HiltViewModel`** : Annotez votre `ViewModel` pour que Hilt le gère. La dépendance est ensuite injectée via le
   constructeur.
4. **Modules Hilt (`@Module` et `@Provides`)** : Pour les choses que vous ne possédez pas (comme une interface ou une
   classe d'une bibliothèque externe comme Room ou Retrofit), vous devez créer un "module" pour apprendre à Hilt comment
   les fournir.

#### Exemple : Refactoriser notre application de notes avec Hilt

**1. `AppModule.kt` (Le "mode d'emploi" pour Hilt)**

```kotlin
package fr.formation.notes.di

import android.content.Context
import androidx.room.Room
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import fr.formation.notes.data.AppDatabase
import fr.formation.notes.data.NoteDao
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class) // Ces dépendances vivront aussi longtemps que l'app
object AppModule {

    @Provides
    @Singleton // On veut une seule instance de la BDD
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            "notes_database"
        ).build()
    }

    @Provides
    fun provideNoteDao(appDatabase: AppDatabase): NoteDao {
        // Hilt sait comment créer AppDatabase (grâce à la méthode au-dessus),
        // il peut donc l'utiliser pour fournir le NoteDao.
        return appDatabase.noteDao()
    }
}
```

**2. `NoteRepository.kt`**

```kotlin
// Hilt sait maintenant comment créer NoteDao, il peut donc l'injecter ici.
class NoteRepository @Inject constructor(private val noteDao: NoteDao) {
    // ...
}
```

**3. `NoteViewModel.kt`**

```kotlin
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository
) : ViewModel() {
    // ...
}
```

**4. `MainActivity.kt`**

```kotlin
@AndroidEntryPoint // Indique que Hilt doit injecter des dépendances ici
class MainActivity : AppCompatActivity() {
    // L'instanciation est toujours déléguée, mais maintenant gérée par Hilt.
    private val viewModel: NoteViewModel by viewModels()
    // ...
}
```

Et voilà ! Plus aucune création manuelle. Le code est propre, découplé et testable.

---

### Koin : L'alternative pure Kotlin

#### Introduction à la notion {id="introduction-la-notion_2"}

Koin est une autre bibliothèque de DI très populaire. Sa philosophie est différente : elle n'utilise pas de génération
de code. C'est un framework pur Kotlin, souvent considéré comme plus simple à apprendre et à configurer. Il fonctionne à
l'**exécution** (runtime), ce qui le rend moins performant que Hilt mais plus flexible.

#### Utilisation {id="utilisation_1"}

1. **Définir un module :** Vous créez un "module" Koin où vous décrivez comment créer vos objets.
   ```kotlin
   val appModule = module {
       // Crée une seule instance (Singleton) de AppDatabase
       single { AppDatabase.getDatabase(androidContext()) }
       // Crée une instance de NoteDao à chaque fois qu'elle est demandée (factory)
       factory { get<AppDatabase>().noteDao() }
       // Crée un singleton du Repository
       single { NoteRepository(get()) } // `get()` résout la dépendance (NoteDao)

       // Déclaration spéciale pour un ViewModel
       viewModel { NoteViewModel(get()) } // `get()` résout NoteRepository
   }
   ```
2. **Démarrer Koin** dans la classe `Application` :
   ```kotlin
   class MyApp : Application() {
       override fun onCreate() {
           super.onCreate()
           startKoin {
               androidContext(this@MyApp)
               modules(appModule)
           }
       }
   }
   ```
3. **Injecter dans les classes Android :**
   ```kotlin
   class MainActivity : AppCompatActivity() {
       // Injection du ViewModel gérée par Koin
       private val viewModel: NoteViewModel by viewModel()
       // ...
   }
   ```

#### Hilt vs. Koin : Le choix

| Caractéristique       | Hilt (Dagger)                               | Koin                                        |
|-----------------------|---------------------------------------------|---------------------------------------------|
| **Vérification**      | À la **compilation** (plus sûr)             | À l'**exécution** (plus de risques d'erreurs) |
| **Performance**       | Plus rapide (pas de réflexion au runtime)   | Moins rapide (utilise la réflexion)         |
| **Configuration**     | Plus complexe (plugins, annotations...)     | Très simple (une dépendance, un module)     |
| **Écosystème**        | Standard de Google, intégré à Jetpack       | Communauté forte, pure Kotlin               |
| **"Magie"**           | Beaucoup de génération de code "magique"    | Plus explicite et facile à déboguer         |

**Conclusion :** Pour les débutants et les projets où la simplicité prime, Koin peut être un excellent choix. Pour les
projets professionnels, à grande échelle et où la performance et la sécurité à la compilation sont critiques, **Hilt est
le standard de l'industrie**.

---

## TP 17 : Refactoriser l'application "Dog Facts" avec Hilt

**Objectif :** Reprendre le TP du module 13 et le refactoriser pour utiliser Hilt pour injecter le service Retrofit et
le ViewModel.

<procedure>

1. **Configurez Hilt** dans le projet (plugins, dépendances, classe `Application`).
2. **Créez un module Hilt** (`NetworkModule.kt`) pour apprendre à Hilt comment fournir l'instance de Retrofit et l'
   `ApiService`.
   ```kotlin
   @Module
   @InstallIn(SingletonComponent::class)
   object NetworkModule {

       @Provides
       @Singleton
       fun provideRetrofit(): Retrofit {
           // ... votre code de création de Retrofit ...
       }

       @Provides
       @Singleton
       fun provideApiService(retrofit: Retrofit): ApiService {
           return retrofit.create(ApiService::class.java)
       }
   }
   ```
3. **Créez un `DogFactRepository`** qui prendra `ApiService` en dépendance (via `@Inject constructor`). Sa seule méthode
   sera `suspend fun getNewFact()`.
4. **Refactorisez votre `DogFactViewModel`** pour qu'il soit annoté avec `@HiltViewModel` et qu'il injecte le
   `DogFactRepository` dans son constructeur. La logique d'appel réseau doit maintenant se trouver dans le ViewModel.
5. **Annotez votre `MainActivity`** avec `@AndroidEntryPoint`.
6. **Supprimez toute création manuelle** de `RetrofitClient`, `Repository` ou `ViewModel`. L'Activity doit simplement
   obtenir le ViewModel via `by viewModels()`.

</procedure>

## Correction du TP 17 {collapsible="true"}

### Prérequis : Code de départ

On part du code du TP sur Retrofit, qui contenait :
*   `ApiService.kt`
*   `DogFactResponse.kt`
*   `RetrofitInstance.kt` (qu'on va supprimer)
*   `MainActivity.kt` (qui faisait tout le travail)

---

### Étape 1 : Configuration de Hilt

#### 1a. Plugins et Dépendances
Modifiez vos fichiers `build.gradle.kts`.

**Fichier `build.gradle.kts` (au niveau du projet) :**
```kotlin
plugins {
    // ...
    id("com.google.dagger.hilt.android") version "2.51.1" apply false
    id("com.google.devtools.ksp") version "1.9.22-1.0.17" apply false
}
```

**Fichier `build.gradle.kts` (au niveau du module) :**
```kotlin
plugins {
    // ...
    id("com.google.dagger.hilt.android")
    id("com.google.devtools.ksp")
}

android { /* ... */ }

dependencies {
    // ...
    
    // Hilt
    implementation("com.google.dagger:hilt-android:2.51.1")
    ksp("com.google.dagger:hilt-compiler:2.51.1")

    // ViewModel
    implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0")
    // Pour l'obtention du ViewModel dans l'activité
    implementation("androidx.activity:activity-ktx:1.9.0")
}
```
**N'oubliez pas de synchroniser** votre projet avec Gradle après ces modifications.

#### 1b. Classe Application
Créez une nouvelle classe qui hérite de `Application` et annotez-la avec `@HiltAndroidApp`.

**Fichier `MyDogApp.kt` :**
```kotlin
package com.example.yourapplication // Adaptez le package

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class MyDogApp : Application()
```

#### 1c. Mettre à jour l'`AndroidManifest.xml`
Déclarez cette nouvelle classe dans votre manifeste.

**Fichier `AndroidManifest.xml` :**
```xml
<application
    android:name=".MyDogApp"
    ...>
    <!-- ... -->
</application>
```
La configuration de base de Hilt est terminée.

---

### Étape 2 : Créer le Module Hilt pour le Réseau

Créez un nouveau fichier `NetworkModule.kt`. Ce module va expliquer à Hilt comment construire nos objets liés au réseau.
**On peut supprimer le fichier `RetrofitInstance.kt`**, car ce module le remplace entièrement.

**Fichier `NetworkModule.kt` :**
```kotlin
package com.example.yourapplication.di // C'est une bonne pratique de mettre les modules dans un package 'di'

import com.example.yourapplication.data.remote.ApiService
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    private const val BASE_URL = "https://dog-api.kinduff.com/"

    @Provides
    @Singleton
    fun provideMoshi(): Moshi {
        return Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(moshi: Moshi): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .build()
    }

    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
```
**Explications :**
*   `@Module` et `@InstallIn(SingletonComponent::class)` : Indique à Hilt que ce module fournit des dépendances qui vivront aussi longtemps que l'application.
*   `@Provides` : Marque une fonction qui "fournit" une dépendance.
*   `@Singleton` : Indique que Hilt ne doit créer qu'une seule instance de cet objet.
*   **Chaîne de dépendances :** Remarquez comment `provideRetrofit` prend `Moshi` en paramètre et `provideApiService` prend `Retrofit`. Hilt comprend cette chaîne et sait dans quel ordre appeler les fonctions pour construire les objets.

---

### Étape 3 : Créer le `DogFactRepository`

Ce repository encapsule la source de données (notre `ApiService`).

**Fichier `DogFactRepository.kt` :**
```kotlin
package com.example.yourapplication.data.repository // Bonnes pratiques pour les packages

import com.example.yourapplication.data.remote.ApiService
import javax.inject.Inject

class DogFactRepository @Inject constructor(
    private val apiService: ApiService
) {
    /**
     * Appelle l'API pour obtenir une nouvelle information.
     * Gère la transformation de la réponse pour ne retourner que le texte.
     */
    suspend fun getNewFact(): Result<String> {
        return try {
            val response = apiService.getDogFact()
            if (response.facts.isNotEmpty()) {
                Result.success(response.facts.first())
            } else {
                Result.failure(Exception("Aucun fait n'a été trouvé."))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
```
**Explications :**
*   `@Inject constructor(...)` : C'est la magie de Hilt. On dit à Hilt : "Pour créer un `DogFactRepository`, tu as besoin d'un `ApiService`. Trouve comment le fournir (via `NetworkModule`) et injecte-le ici."
*   **`Result<String>`** : C'est une excellente pratique pour la gestion d'erreurs. La couche Repository retourne soit un succès avec la donnée (`String`), soit un échec avec l'exception. Le ViewModel n'a plus besoin de bloc `try-catch`.

---

### Étape 4 : Refactoriser le `DogFactViewModel`

Le ViewModel devient le chef d'orchestre. Il ne connaît que le Repository.

**Fichier `DogFactViewModel.kt` :**
```kotlin
package com.example.yourapplication.ui // Mettez les ViewModels dans un package 'ui' ou 'presentation'

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.yourapplication.data.repository.DogFactRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class DogFactViewModel @Inject constructor(
    private val repository: DogFactRepository
) : ViewModel() {

    // L'état de l'UI est exposé via LiveData (ou StateFlow) pour être observé
    private val _dogFact = MutableLiveData<String>()
    val dogFact: LiveData<String> = _dogFact

    private val _isLoading = MutableLiveData<Boolean>()
    val isLoading: LiveData<Boolean> = _isLoading

    init {
        // Charger un premier fait au démarrage du ViewModel
        fetchNewFact()
    }

    fun fetchNewFact() {
        viewModelScope.launch {
            _isLoading.value = true // Indiquer le début du chargement
            val result = repository.getNewFact()
            result.onSuccess { fact ->
                _dogFact.value = fact
            }.onFailure { error ->
                _dogFact.value = "Erreur de chargement: ${error.message}"
            }
            _isLoading.value = false // Indiquer la fin du chargement
        }
    }
}
```
**Explications :**
*   `@HiltViewModel` : Permet à Hilt d'injecter des dépendances dans ce ViewModel.
*   `@Inject constructor(...)` : Comme pour le repository, Hilt va fournir automatiquement une instance de `DogFactRepository`.
*   **`LiveData`** : Le ViewModel expose l'état de l'UI (`_dogFact`, `_isLoading`) via `LiveData`. L'Activity va observer ces `LiveData` et se mettra à jour automatiquement.
*   La logique d'appel (via `repository.getNewFact()`) et la gestion du succès/échec sont entièrement contenues ici.

---

### Étape 5 & 6 : Mettre à jour `MainActivity`

L'activité devient très simple. Son seul rôle est d'observer le ViewModel et de réagir aux changements d'état.

**Fichier `MainActivity.kt` :**
```kotlin
package com.example.yourapplication

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import androidx.activity.viewModels
import com.example.yourapplication.databinding.ActivityMainBinding
import com.example.yourapplication.ui.DogFactViewModel
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    
    // Obtenir une instance du ViewModel gérée par Hilt. C'est tout !
    private val viewModel: DogFactViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // L'UI écoute les changements du ViewModel
        setupObservers()

        binding.newFactButton.setOnClickListener {
            // L'UI notifie le ViewModel d'une action utilisateur
            viewModel.fetchNewFact()
        }
    }

    private fun setupObservers() {
        viewModel.dogFact.observe(this) { fact ->
            binding.factTextView.text = fact
        }

        viewModel.isLoading.observe(this) { isLoading ->
            binding.progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
            binding.newFactButton.isEnabled = !isLoading
        }
    }
}
```
**Explications :**
*   `@AndroidEntryPoint` : Indique à Hilt que cette classe peut recevoir des dépendances.
*   `private val viewModel: DogFactViewModel by viewModels()` : C'est la seule ligne nécessaire pour obtenir une instance du `DogFactViewModel`. Hilt s'occupe de toute la construction en arrière-plan.
*   **Flux unidirectionnel :**
    1.  **Action UI :** L'utilisateur clique sur le bouton, l'activité appelle `viewModel.fetchNewFact()`.
    2.  **Mise à jour de l'état :** Le ViewModel fait son travail et met à jour ses `LiveData` (`_isLoading`, `_dogFact`).
    3.  **Observation :** Les `observers` dans `MainActivity` détectent les changements et mettent à jour l'UI en conséquence.

L'application a maintenant une architecture propre, découplée et facilement testable.

---

## Auto-évaluation

**1. Quel est le principe de l'Inversion de Contrôle ? (QCM)**

* A) La View contrôle le ViewModel.
* B) Une classe ne crée pas ses propres dépendances, mais les reçoit d'une source externe.
* C) Les dépendances sont créées au moment de l'exécution plutôt qu'à la compilation.
* D) Le code est exécuté dans l'ordre inverse de son écriture.

**2. Quelle annotation Hilt doit-on mettre sur une Activity ou un Fragment pour activer l'injection ? (QCM)**

* A) `@HiltActivity`
* B) `@Inject`
* C) `@AndroidEntryPoint`
* D) `@Module`

**3. Dans Koin, quelle fonction du DSL utilise-t-on pour déclarer une dépendance qui doit être une instance unique (
Singleton) ? (QCM)**

* A) `factory { ... }`
* B) `singleton { ... }`
* C) `single { ... }`
* D) `viewModel { ... }`

**4. Expliquez pourquoi l'injection de dépendances rend le code plus facile à tester. (Question ouverte)**

**5. Quel est, selon vous, le principal compromis à faire lorsque l'on choisit Koin plutôt que Hilt ? (Question ouverte)
**

### Correction de l'auto-évaluation {collapsible="true"}

**1. Quel est le principe de l'Inversion de Contrôle ?**

* **Réponse : B) Une classe ne crée pas ses propres dépendances, mais les reçoit d'une source externe.**
* **Justification :** C'est la définition même de l'IoC. Le "contrôle" de l'instanciation est inversé, passant de
  l'objet lui-même au framework de DI.

**2. Quelle annotation Hilt pour activer l'injection dans une Activity/Fragment ?**

* **Réponse : C) `@AndroidEntryPoint`**
* **Justification :** Cette annotation signale à Hilt que cette classe Android est un "point d'entrée" où des
  dépendances devront être injectées. Hilt génère alors le code nécessaire pour le faire.

**3. Quelle fonction Koin pour un Singleton ?**

* **Réponse : C) `single { ... }`**
* **Justification :** `single` est la fonction du DSL de Koin pour déclarer qu'une seule et même instance de l'objet
  doit être créée et réutilisée pour toute la durée de vie de l'application.

**4. Pourquoi la DI facilite-t-elle les tests ?**

* **Réponse type :** Parce qu'elle permet de substituer facilement les vraies dépendances par des fausses (des "mocks"
  ou "fakes"). Par exemple, pour tester un `ViewModel` qui dépend d'un `Repository`, on peut configurer le framework de
  DI pour qu'il injecte un `FakeRepository` qui renvoie des données en mémoire au lieu de faire un vrai appel réseau ou
  BDD. Cela rend les tests rapides, fiables et isolés, car on ne teste que la logique du `ViewModel` sans dépendre de
  systèmes externes (comme un serveur qui pourrait être en panne).

**5. Quel est le principal compromis en choisissant Koin plutôt que Hilt ?**

* **Réponse type :** Le principal compromis est de sacrifier la **sécurité à la compilation** pour la **simplicité de
  configuration**. Avec Koin, si vous oubliez de déclarer une dépendance dans un module, vous ne le découvrirez qu'à l'
  exécution, lorsque l'application plantera. Avec Hilt, le même oubli provoquerait une erreur de compilation, vous
  forçant à corriger le problème avant même de pouvoir lancer l'application. On échange donc de la robustesse et de la
  performance contre une courbe d'apprentissage et une mise en place plus douces.
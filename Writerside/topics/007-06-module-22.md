# Module 22 : Afficher des Images Locales (Bitmaps)

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Identifier le dossier `drawable` comme l'emplacement pour les ressources graphiques.
* Comprendre l'utilité des dossiers de densité (mdpi, hdpi, etc.).
* Utiliser le widget `ImageView` pour afficher des images dans un layout.
* Charger une image depuis les ressources de manière statique (en XML) et dynamique (en Kotlin).
* Comprendre la différence entre les attributs `android:src` et `android:background`.

### Introduction

Imaginez votre application comme une galerie d'art. Pour l'instant, vous savez peindre les murs (`colors.xml`), écrire
des descriptions sur des cartels (`TextView`), et installer des interrupteurs (`Button`). Mais une galerie sans tableaux
est un peu triste ! Ce module va vous apprendre à gérer votre collection d'œuvres d'art (vos images).

Nous allons découvrir où stocker vos toiles en toute sécurité (le dossier **`drawable`**), comment choisir le bon cadre
pour les exposer (le widget **`ImageView`**), et enfin, comment accrocher un tableau au mur, que ce soit de manière
permanente ou en permettant de le changer dynamiquement. Maîtriser l'affichage d'images est la clé pour rendre vos
applications visuellement riches et attrayantes.

### Notions abordées

* Le dossier `drawable` : Le coffre à images
* L'`ImageView` : Le cadre d'exposition
* Chargement d'une image : Statique (XML) vs. Dynamique (Kotlin)
* Différence entre `src` et `background`

---

### Le dossier `drawable` : Le coffre à images

#### Introduction à la notion

Le dossier `res/drawable` est le coffre-fort des ressources visuelles de votre application. C'est ici que vous stockez
toutes les images, icônes, et autres graphismes que vous souhaitez utiliser. Android organise ce coffre-fort de manière
très intelligente pour s'adapter à la multitude d'écrans existants.

#### Explication de la notion

Le dossier `res/drawable` est l'emplacement principal pour vos images bitmap (comme les `.png`, `.jpg`, `.webp`) et vos
graphiques vectoriels (`.xml`).

Pour ajouter une image à votre projet, il suffit de la faire glisser depuis l'explorateur de fichiers de votre
ordinateur et de la déposer directement dans le dossier `drawable` dans Android Studio.

**Les dossiers de densité**

Vous remarquerez peut-être des dossiers comme `drawable-mdpi`, `drawable-hdpi`, `drawable-xhdpi`, etc. Ces dossiers
permettent de fournir différentes versions d'une même image pour différentes densités de pixels d'écran.

| Suffixe   | Densité          | Résolution (baseline)   |
|-----------|------------------|-------------------------|
| `mdpi`    | Medium dpi       | ~160 dpi                |
| `hdpi`    | High dpi         | ~240 dpi                |
| `xhdpi`   | Extra High dpi   | ~320 dpi (très courant) |
| `xxhdpi`  | Extra Extra High | ~480 dpi (très courant) |
| `xxxhdpi` | Extra... High    | ~640 dpi                |

**Pourquoi est-ce important ?** Si vous fournissez une image `logo.png` dans chacun de ces dossiers, Android choisira
automatiquement la version la plus appropriée pour l'appareil de l'utilisateur. Cela garantit que votre image est nette
sans gaspiller de mémoire avec une image inutilement grande sur un écran de faible résolution.

<tip title="Bonne Pratique">
Pour commencer, vous pouvez placer toutes vos images dans le dossier `drawable` simple. Android s'en accommodera. Cependant, pour une application de production, fournir des ressources pour au moins `xhdpi` et `xxhdpi` est une bonne pratique. Pour les icônes simples, préférez les **Vector Drawables** (des fichiers `.xml` qui décrivent une image) car ils s'adaptent à n'importe quelle taille sans perte de qualité.
</tip>

---

### L'`ImageView` : Le cadre d'exposition

#### Introduction à la notion {id="introduction-la-notion_1"}

Maintenant que votre toile est dans la réserve, il vous faut un cadre sur le mur pour l'exposer. L'`ImageView` est ce
cadre. C'est un composant d'interface spécialisé dont l'unique rôle est d'afficher une ressource graphique.

#### Explication de la notion {id="explication-de-la-notion_1"}

L'`ImageView` est un widget (`View`) que vous ajoutez à vos fichiers de layout XML. Il possède plusieurs attributs
clés :

* `android:id` : Pour pouvoir le manipuler en Kotlin.
* `android:layout_width`, `android:layout_height` : Pour définir sa taille.
* `android:src` : Pour spécifier la source de l'image (le "tableau" à mettre dans le cadre).
* **`android:contentDescription`** : **Essentiel pour l'accessibilité.** C'est une description textuelle de l'image qui
  sera lue par les lecteurs d'écran pour les utilisateurs malvoyants. Ne l'oubliez jamais !
* **`android:scaleType`** : Définit comment l'image doit être redimensionnée ou positionnée si ses dimensions ne
  correspondent pas exactement à celles de l'`ImageView`.
    * `fitCenter` : Redimensionne l'image (en gardant ses proportions) pour qu'elle tienne entièrement à l'intérieur de
      l'ImageView, en la centrant.
    * `centerCrop` : Redimensionne l'image (en gardant ses proportions) pour qu'elle remplisse entièrement l'ImageView,
      en rognant (crop) les parties qui dépassent.
    * `centerInside` : Centre l'image sans la redimensionner si elle est plus petite que l'ImageView.

**Exemple de `ImageView` dans un layout :**

```xml

<ImageView
        android:id="@+id/profileAvatar"
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:src="@drawable/default_avatar"
        android:scaleType="centerCrop"
        android:contentDescription="@string/description_avatar_utilisateur"/>
```

---

### Chargement d'une image : Statique (XML) vs. Dynamique (Kotlin)

#### Introduction à la notion {id="introduction-la-notion_2"}

Il y a deux façons d'accrocher votre tableau :

1. **Statique :** Vous décidez au moment de la construction du mur (le layout XML) que ce cadre contiendra toujours ce
   tableau précis.
2. **Dynamique :** Vous installez un cadre vide et, plus tard, en fonction des circonstances (une action de
   l'utilisateur), vous changez le tableau qui y est exposé.

#### Explication de la notion {id="explication-de-la-notion_2"}

**1. Chargement Statique (via XML)**
C'est la méthode la plus simple, pour les images qui ne changent pas (comme un logo dans un en-tête). Vous utilisez
l'attribut `android:src`.

```xml
<!-- Le nom du fichier dans le dossier drawable est `app_logo.png` -->
<ImageView
        ...
        android:src="@drawable/app_logo"
        ... />
```

**2. Chargement Dynamique (via Kotlin)**
C'est la méthode à utiliser lorsque l'image doit changer en fonction de la logique de votre application. Vous utilisez
la méthode `setImageResource()` de l'objet `ImageView`.

```kotlin
// Dans votre Fragment ou Activity, après avoir initialisé View Binding

// L'image change en fonction d'une condition
if (user.isOnline) {
    binding.statusIcon.setImageResource(R.drawable.ic_status_online)
} else {
    binding.statusIcon.setImageResource(R.drawable.ic_status_offline)
}
```

`R.drawable.nom_de_l_image` est la référence générée par Android pour accéder à votre ressource depuis le code Kotlin.

#### Exercice 1 : Changer d'image au clic

**Énoncé :**
Créez une interface avec une `ImageView` au centre et deux `Button` en dessous. Le premier bouton affiche un logo
Android, le second un logo Kotlin.

1. Trouvez deux images (par exemple, `android_logo.png` et `kotlin_logo.png`) et ajoutez-les à votre dossier `drawable`.
2. Créez le layout XML.
3. Dans votre `MainActivity.kt`, utilisez View Binding et `setOnClickListener` pour que chaque bouton change l'image
   affichée dans l'`ImageView`.

**Correction exercice 1** {collapsible='true'}

**1. Ajouter les images :**
Faites glisser `android_logo.png` et `kotlin_logo.png` dans le dossier `res/drawable`.

**2. `activity_main.xml`**

```xml

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical"
              android:gravity="center">

    <ImageView
            android:id="@+id/logoImageView"
            android:layout_width="150dp"
            android:layout_height="150dp"
            android:src="@drawable/android_logo"
            android:contentDescription="Logo affiché"
            android:scaleType="fitCenter"/>

    <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="20dp">

        <Button
                android:id="@+id/androidButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Android"/>

        <Button
                android:id="@+id/kotlinButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:text="Kotlin"/>
    </LinearLayout>
</LinearLayout>
```

**3. `MainActivity.kt`**

```kotlin
package fr.formation.images

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import fr.formation.images.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.androidButton.setOnClickListener {
            // Charge dynamiquement l'image du logo Android
            binding.logoImageView.setImageResource(R.drawable.android_logo)
        }

        binding.kotlinButton.setOnClickListener {
            // Charge dynamiquement l'image du logo Kotlin
            binding.logoImageView.setImageResource(R.drawable.kotlin_logo)
        }
    }
}
```

---

### Différence entre `src` et `background`

<tip title="src vs. background">
Il est important de ne pas confondre `android:src` et `android:background`.

* **`src` :** C'est le **contenu** de l'ImageView. L'image sera affichée en respectant le `scaleType`. C'est le tableau
  dans le cadre.
* **`background` :** C'est l'**arrière-plan** de la vue `ImageView` elle-même. L'image sera étirée ou répétée pour
  remplir la totalité des dimensions de la vue, sans tenir compte du `scaleType`. C'est le papier peint sur le mur
  derrière le cadre.

Utilisez `src` dans 99% des cas pour une `ImageView`.
</tip>

---

## TP 21 : Mini-galerie photo

**Objectif :** Créer une galerie simple où l'utilisateur peut changer une image principale en cliquant sur des
miniatures.

<procedure>

1. **Préparez vos ressources :** Trouvez trois images de votre choix (ex: `image_1.jpg`, `image_2.jpg`, `image_3.jpg`)
   et ajoutez-les au dossier `drawable`.
2. **Créez le layout :**
    * Utilisez un `LinearLayout` vertical.
    * En haut, placez une grande `ImageView` qui prendra une bonne partie de l'écran (ex: 300dp de hauteur). Donnez-lui
      l'ID `mainImageView`.
    * En bas, placez un `LinearLayout` horizontal.
    * À l'intérieur de ce `LinearLayout` horizontal, placez trois petites `ImageView` (ex: 80dp x 80dp) qui serviront de
      miniatures. Donnez-leur les ID `thumb1`, `thumb2`, `thumb3`.
    * Affichez statiquement chaque image dans sa miniature correspondante (`thumb1` affiche `image_1`, etc.).
3. **Dans `MainActivity.kt` :**
    * Configurez trois `setOnClickListener` distincts, un pour chaque miniature (`thumb1`, `thumb2`, `thumb3`).
    * Dans le listener de `thumb1`, appelez `binding.mainImageView.setImageResource(R.drawable.image_1)`.
    * Faites de même pour les deux autres miniatures.
4. **Testez :** L'application doit afficher une image principale. Cliquer sur les différentes miniatures en bas doit
   changer l'image principale.

</procedure>

## Correction du TP 22 {collapsible="true"}


### Étape 1 : Préparation du Projet (Configuration Gradle)

C'est l'étape la plus importante. Assurez-vous que votre projet est correctement configuré.

**1. Fichier `build.gradle.kts` (au niveau du projet/racine) :**
```kotlin
// Top-level build file where you can add configuration options common to all sub-projects/modules.
plugins {
    id("com.android.application") version "8.4.0" apply false
    id("org.jetbrains.kotlin.android") version "2.0.0" apply false
    id("com.google.dagger.hilt.android") version "2.51.1" apply false // Hilt plugin
    id("com.google.devtools.ksp") version "2.0.0-1.0.22" apply false // KSP
}
```

**2. Fichier `build.gradle.kts` (au niveau du module `app`) :**
```kotlin
plugins {
    id("com.android.application")
    id("org.jetbrains.kotlin.android")
    id("com.google.dagger.hilt.android") // Appliquer le plugin Hilt
    id("com.google.devtools.ksp")       // Appliquer KSP
}

android {
    // ...
    buildFeatures {
        compose = true // Activer Compose
    }
    composeOptions {
        kotlinCompilerExtensionVersion = "1.5.14"
    }
}

dependencies {
    // Compose
    implementation(platform("androidx.compose:compose-bom:2024.05.00"))
    implementation("androidx.compose.ui:ui")
    implementation("androidx.compose.ui:ui-graphics")
    implementation("androidx.compose.ui:ui-tooling-preview")
    implementation("androidx.compose.material3:material3")

    // Intégration ViewModel & Lifecycle avec Compose
    implementation("androidx.lifecycle:lifecycle-runtime-ktx:2.8.0")
    implementation("androidx.activity:activity-compose:1.9.0")
    implementation("androidx.lifecycle:lifecycle-viewmodel-compose:2.8.0")
    implementation("androidx.lifecycle:lifecycle-runtime-compose:2.8.0")

    // Hilt - Injection de Dépendances
    implementation("com.google.dagger:hilt-android:2.51.1")
    ksp("com.google.dagger:hilt-compiler:2.51.1")
    implementation("androidx.hilt:hilt-navigation-compose:1.2.0")
}
```

---

### Étape 2 : Configuration de Hilt

Hilt a besoin d'une classe `Application` pour s'initialiser.

**1. Créez une classe `ImageGalleryApp.kt` :**
```kotlin
package com.example.imagegallery // Adaptez le package

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class ImageGalleryApp : Application()
```

**2. Mettez à jour votre `AndroidManifest.xml` :**
Ajoutez l'attribut `android:name` à votre balise `<application>`.
```xml
<application
    android:name=".ImageGalleryApp"
    ... >
    <!-- ... -->
</application>
```

---

### Étape 3 : Le ViewModel (Le cerveau de l'application)

Le ViewModel va contenir la logique : quelle image est actuellement sélectionnée ?

```kotlin
package com.example.imagegallery

import androidx.lifecycle.ViewModel
import com.example.imagegallery.R // Assurez-vous d'importer votre R
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update
import javax.inject.Inject

// Le state de notre UI : quelle image est sélectionnée et la liste des miniatures
data class ImageGalleryUiState(
    val selectedImageResId: Int = R.drawable.image_1,
    val thumbnails: List<Int> = listOf(R.drawable.image_1, R.drawable.image_2, R.drawable.image_3)
)

@HiltViewModel
class ImageGalleryViewModel @Inject constructor() : ViewModel() {

    // Un StateFlow pour contenir l'état de l'UI.
    // _uiState est privé et modifiable uniquement par le ViewModel.
    private val _uiState = MutableStateFlow(ImageGalleryUiState())
    
    // uiState est public et non modifiable (read-only), exposé à l'UI.
    val uiState = _uiState.asStateFlow()

    /**
     * Cet événement est appelé par l'UI quand une miniature est cliquée.
     * Le ViewModel met à jour son état en conséquence.
     */
    fun onThumbnailClick(imageResId: Int) {
        _uiState.update { currentState ->
            currentState.copy(selectedImageResId = imageResId)
        }
    }
}
```

---

### Étape 4 : L'Interface Utilisateur (Jetpack Compose)

Nous allons créer un écran qui observe le `ViewModel`. Nous séparons la logique de l'affichage en deux composables : un "intelligent" (stateful) et un "bête" (stateless).

```kotlin
package com.example.imagegallery

import androidx.annotation.DrawableRes
import androidx.compose.foundation.Image
import androidx.compose.foundation.border
import androidx.compose.foundation.clickable
import androidx.compose.foundation.layout.*
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.layout.ContentScale
import androidx.compose.ui.res.painterResource
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import com.example.imagegallery.ui.theme.ImageGalleryTheme

/**
 * Composable "intelligent" (Stateful).
 * Il se connecte au ViewModel et gère l'état.
 */
@Composable
fun ImageGalleryScreen(
    viewModel: ImageGalleryViewModel = hiltViewModel() // Obtient le ViewModel via Hilt
) {
    // On collecte l'état du ViewModel.
    // À chaque changement de l'état, ce composable sera recomposé.
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    // On passe les données et les événements au composable "bête".
    ImageGalleryContent(
        uiState = uiState,
        onThumbnailClick = viewModel::onThumbnailClick // Référence à la fonction du ViewModel
    )
}

/**
 * Composable "bête" (Stateless).
 * Il ne fait qu'afficher des données et remonter des événements.
 * Facile à prévisualiser et à réutiliser.
 */
@Composable
fun ImageGalleryContent(
    uiState: ImageGalleryUiState,
    onThumbnailClick: (Int) -> Unit,
    modifier: Modifier = Modifier
) {
    Column(
        modifier = modifier.fillMaxSize(),
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        // Image Principale
        Image(
            painter = painterResource(id = uiState.selectedImageResId),
            contentDescription = "Image principale",
            modifier = Modifier
                .fillMaxWidth()
                .height(300.dp),
            contentScale = ContentScale.Crop
        )

        Spacer(modifier = Modifier.height(16.dp))

        // Ligne des miniatures
        Row(
            modifier = Modifier.fillMaxWidth(),
            horizontalArrangement = Arrangement.SpaceEvenly // Espace les miniatures
        ) {
            uiState.thumbnails.forEach { thumbnailResId ->
                Thumbnail(
                    imageResId = thumbnailResId,
                    isSelected = thumbnailResId == uiState.selectedImageResId,
                    onClick = { onThumbnailClick(thumbnailResId) }
                )
            }
        }
    }
}

@Composable
private fun Thumbnail(
    @DrawableRes imageResId: Int,
    isSelected: Boolean,
    onClick: () -> Unit
) {
    val borderModifier = if (isSelected) {
        Modifier.border(2.dp, Color.Blue) // Ajoute une bordure si l'image est sélectionnée
    } else {
        Modifier
    }

    Image(
        painter = painterResource(id = imageResId),
        contentDescription = "Miniature",
        modifier = Modifier
            .size(80.dp)
            .then(borderModifier) // Applique la bordure
            .clickable(onClick = onClick), // Rend l'image cliquable
        contentScale = ContentScale.Crop
    )
}


@Preview(showBackground = true)
@Composable
fun ImageGalleryContentPreview() {
    ImageGalleryTheme {
        ImageGalleryContent(
            uiState = ImageGalleryUiState(
                selectedImageResId = R.drawable.image_2,
                thumbnails = listOf(R.drawable.image_1, R.drawable.image_2, R.drawable.image_3)
            ),
            onThumbnailClick = {}
        )
    }
}
```

---

### Étape 5 : L'Activité (`MainActivity.kt`)

Grâce à Hilt et Compose, l'activité devient extrêmement simple.

```kotlin
package com.example.imagegallery

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.ui.Modifier
import com.example.imagegallery.ui.theme.ImageGalleryTheme
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint // Hilt a besoin de cette annotation
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            ImageGalleryTheme {
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    ImageGalleryScreen()
                }
            }
        }
    }
}
```

### Comment ça fonctionne ? (Le flux de données)

1.  **L'utilisateur clique** sur une `Thumbnail`. Le `Modifier.clickable` appelle le lambda `onClick`.
2.  Ce `onClick` exécute la fonction `onThumbnailClick(id)` qui a été passée au `ImageGalleryContent`.
3.  Cette fonction est en réalité une référence à la méthode `viewModel::onThumbnailClick`. L'événement **remonte** donc de l'UI vers le ViewModel.
4.  Le **ViewModel** reçoit l'ID de l'image cliquée. Il met à jour son `_uiState` en créant une nouvelle copie du `State` avec la nouvelle `selectedImageResId`.
5.  Le `StateFlow` **émet** ce nouvel état.
6.  Dans `ImageGalleryScreen`, le `collectAsStateWithLifecycle` reçoit le nouvel état.
7.  Jetpack Compose détecte que l'état a changé et **recompose** intelligemment les parties de l'UI qui dépendent de cet état (l'image principale et la bordure des miniatures).

C'est ce qu'on appelle un **flux de données unidirectionnel**, et c'est le cœur de l'architecture moderne sur Android.

---

## Conclusion et Prochaines Étapes

Vous savez maintenant comment intégrer des ressources graphiques dans vos applications, une compétence indispensable
pour créer des interfaces attrayantes. Vous maîtrisez le stockage dans le dossier `drawable`, l'affichage via
`ImageView`, et la mise à jour statique et dynamique.

**Pour aller plus loin :**
Pour charger des images depuis **Internet**, ou pour gérer de manière optimisée un grand nombre d'images locales (comme
dans une galerie), on n'utilise **jamais** `setImageResource` directement. Cette méthode ne gère ni le cache, ni
l'optimisation de la mémoire, ni le décodage en arrière-plan.

L'étape suivante, pour toute application réelle, est d'utiliser une **bibliothèque de chargement d'images**. Les deux
plus populaires sont :

* **[Glide](https://github.com/bumptech/glide)**
* **[Coil](https://coil-kt.github.io/coil/)** (100% Kotlin et moderne)

Ces bibliothèques simplifient le code et gèrent toute la complexité pour vous :

```kotlin
// Charger une image locale avec Coil
binding.myImageView.load(R.drawable.my_image)

// Charger une image depuis internet avec Coil
binding.myImageView.load("https://www.example.com/image.jpg")
```

Elles sont indispensables et nous vous encourageons à les explorer dès que vous êtes à l'aise avec les bases que nous
avons vues aujourd'hui.
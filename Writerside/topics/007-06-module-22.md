# Module 22 : Afficher des Images Locales (Bitmaps)

### Objectifs pédagogiques

À la fin de ce module, vous serez capable de :

* Identifier le dossier `drawable` comme l'emplacement pour les ressources graphiques.
* Comprendre l'utilité des dossiers de densité (mdpi, hdpi, etc.).
* Utiliser le widget `ImageView` pour afficher des images dans un layout.
* Charger une image depuis les ressources de manière statique (en XML) et dynamique (en Kotlin).
* Comprendre la différence entre les attributs `android:src` et `android:background`.

### Introduction

Imaginez votre application comme une galerie d'art. Pour l'instant, vous savez peindre les murs (`colors.xml`), écrire
des descriptions sur des cartels (`TextView`), et installer des interrupteurs (`Button`). Mais une galerie sans tableaux
est un peu triste ! Ce module va vous apprendre à gérer votre collection d'œuvres d'art (vos images).

Nous allons découvrir où stocker vos toiles en toute sécurité (le dossier **`drawable`**), comment choisir le bon cadre
pour les exposer (le widget **`ImageView`**), et enfin, comment accrocher un tableau au mur, que ce soit de manière
permanente ou en permettant de le changer dynamiquement. Maîtriser l'affichage d'images est la clé pour rendre vos
applications visuellement riches et attrayantes.

### Notions abordées

* Le dossier `drawable` : Le coffre à images
* L'`ImageView` : Le cadre d'exposition
* Chargement d'une image : Statique (XML) vs. Dynamique (Kotlin)
* Différence entre `src` et `background`

---

### Le dossier `drawable` : Le coffre à images

#### Introduction à la notion

Le dossier `res/drawable` est le coffre-fort des ressources visuelles de votre application. C'est ici que vous stockez
toutes les images, icônes, et autres graphismes que vous souhaitez utiliser. Android organise ce coffre-fort de manière
très intelligente pour s'adapter à la multitude d'écrans existants.

#### Explication de la notion

Le dossier `res/drawable` est l'emplacement principal pour vos images bitmap (comme les `.png`, `.jpg`, `.webp`) et vos
graphiques vectoriels (`.xml`).

Pour ajouter une image à votre projet, il suffit de la faire glisser depuis l'explorateur de fichiers de votre
ordinateur et de la déposer directement dans le dossier `drawable` dans Android Studio.

**Les dossiers de densité**

Vous remarquerez peut-être des dossiers comme `drawable-mdpi`, `drawable-hdpi`, `drawable-xhdpi`, etc. Ces dossiers
permettent de fournir différentes versions d'une même image pour différentes densités de pixels d'écran.

| Suffixe   | Densité          | Résolution (baseline)   |
|-----------|------------------|-------------------------|
| `mdpi`    | Medium dpi       | ~160 dpi                |
| `hdpi`    | High dpi         | ~240 dpi                |
| `xhdpi`   | Extra High dpi   | ~320 dpi (très courant) |
| `xxhdpi`  | Extra Extra High | ~480 dpi (très courant) |
| `xxxhdpi` | Extra... High    | ~640 dpi                |

**Pourquoi est-ce important ?** Si vous fournissez une image `logo.png` dans chacun de ces dossiers, Android choisira
automatiquement la version la plus appropriée pour l'appareil de l'utilisateur. Cela garantit que votre image est nette
sans gaspiller de mémoire avec une image inutilement grande sur un écran de faible résolution.

<tip title="Bonne Pratique">
Pour commencer, vous pouvez placer toutes vos images dans le dossier `drawable` simple. Android s'en accommodera. Cependant, pour une application de production, fournir des ressources pour au moins `xhdpi` et `xxhdpi` est une bonne pratique. Pour les icônes simples, préférez les **Vector Drawables** (des fichiers `.xml` qui décrivent une image) car ils s'adaptent à n'importe quelle taille sans perte de qualité.
</tip>

---

### L'`ImageView` : Le cadre d'exposition

#### Introduction à la notion {id="introduction-la-notion_1"}

Maintenant que votre toile est dans la réserve, il vous faut un cadre sur le mur pour l'exposer. L'`ImageView` est ce
cadre. C'est un composant d'interface spécialisé dont l'unique rôle est d'afficher une ressource graphique.

#### Explication de la notion {id="explication-de-la-notion_1"}

L'`ImageView` est un widget (`View`) que vous ajoutez à vos fichiers de layout XML. Il possède plusieurs attributs
clés :

* `android:id` : Pour pouvoir le manipuler en Kotlin.
* `android:layout_width`, `android:layout_height` : Pour définir sa taille.
* `android:src` : Pour spécifier la source de l'image (le "tableau" à mettre dans le cadre).
* **`android:contentDescription`** : **Essentiel pour l'accessibilité.** C'est une description textuelle de l'image qui
  sera lue par les lecteurs d'écran pour les utilisateurs malvoyants. Ne l'oubliez jamais !
* **`android:scaleType`** : Définit comment l'image doit être redimensionnée ou positionnée si ses dimensions ne
  correspondent pas exactement à celles de l'`ImageView`.
    * `fitCenter` : Redimensionne l'image (en gardant ses proportions) pour qu'elle tienne entièrement à l'intérieur de
      l'ImageView, en la centrant.
    * `centerCrop` : Redimensionne l'image (en gardant ses proportions) pour qu'elle remplisse entièrement l'ImageView,
      en rognant (crop) les parties qui dépassent.
    * `centerInside` : Centre l'image sans la redimensionner si elle est plus petite que l'ImageView.

**Exemple de `ImageView` dans un layout :**

```xml

<ImageView
        android:id="@+id/profileAvatar"
        android:layout_width="120dp"
        android:layout_height="120dp"
        android:src="@drawable/default_avatar"
        android:scaleType="centerCrop"
        android:contentDescription="@string/description_avatar_utilisateur"/>
```

---

### Chargement d'une image : Statique (XML) vs. Dynamique (Kotlin)

#### Introduction à la notion {id="introduction-la-notion_2"}

Il y a deux façons d'accrocher votre tableau :

1. **Statique :** Vous décidez au moment de la construction du mur (le layout XML) que ce cadre contiendra toujours ce
   tableau précis.
2. **Dynamique :** Vous installez un cadre vide et, plus tard, en fonction des circonstances (une action de
   l'utilisateur), vous changez le tableau qui y est exposé.

#### Explication de la notion {id="explication-de-la-notion_2"}

**1. Chargement Statique (via XML)**
C'est la méthode la plus simple, pour les images qui ne changent pas (comme un logo dans un en-tête). Vous utilisez
l'attribut `android:src`.

```xml
<!-- Le nom du fichier dans le dossier drawable est `app_logo.png` -->
<ImageView
        ...
        android:src="@drawable/app_logo"
        ... />
```

**2. Chargement Dynamique (via Kotlin)**
C'est la méthode à utiliser lorsque l'image doit changer en fonction de la logique de votre application. Vous utilisez
la méthode `setImageResource()` de l'objet `ImageView`.

```kotlin
// Dans votre Fragment ou Activity, après avoir initialisé View Binding

// L'image change en fonction d'une condition
if (user.isOnline) {
    binding.statusIcon.setImageResource(R.drawable.ic_status_online)
} else {
    binding.statusIcon.setImageResource(R.drawable.ic_status_offline)
}
```

`R.drawable.nom_de_l_image` est la référence générée par Android pour accéder à votre ressource depuis le code Kotlin.

#### Exercice 1 : Changer d'image au clic

**Énoncé :**
Créez une interface avec une `ImageView` au centre et deux `Button` en dessous. Le premier bouton affiche un logo
Android, le second un logo Kotlin.

1. Trouvez deux images (par exemple, `android_logo.png` et `kotlin_logo.png`) et ajoutez-les à votre dossier `drawable`.
2. Créez le layout XML.
3. Dans votre `MainActivity.kt`, utilisez View Binding et `setOnClickListener` pour que chaque bouton change l'image
   affichée dans l'`ImageView`.

**Correction exercice 1** {collapsible='true'}

**1. Ajouter les images :**
Faites glisser `android_logo.png` et `kotlin_logo.png` dans le dossier `res/drawable`.

**2. `activity_main.xml`**

```xml

<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
              android:layout_width="match_parent"
              android:layout_height="match_parent"
              android:orientation="vertical"
              android:gravity="center">

    <ImageView
            android:id="@+id/logoImageView"
            android:layout_width="150dp"
            android:layout_height="150dp"
            android:src="@drawable/android_logo"
            android:contentDescription="Logo affiché"
            android:scaleType="fitCenter"/>

    <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:orientation="horizontal"
            android:layout_marginTop="20dp">

        <Button
                android:id="@+id/androidButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:text="Android"/>

        <Button
                android:id="@+id/kotlinButton"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginStart="16dp"
                android:text="Kotlin"/>
    </LinearLayout>
</LinearLayout>
```

**3. `MainActivity.kt`**

```kotlin
package fr.formation.images

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import fr.formation.images.databinding.ActivityMainBinding

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        binding.androidButton.setOnClickListener {
            // Charge dynamiquement l'image du logo Android
            binding.logoImageView.setImageResource(R.drawable.android_logo)
        }

        binding.kotlinButton.setOnClickListener {
            // Charge dynamiquement l'image du logo Kotlin
            binding.logoImageView.setImageResource(R.drawable.kotlin_logo)
        }
    }
}
```

---

### Différence entre `src` et `background`

<tip title="src vs. background">
Il est important de ne pas confondre `android:src` et `android:background`.

* **`src` :** C'est le **contenu** de l'ImageView. L'image sera affichée en respectant le `scaleType`. C'est le tableau
  dans le cadre.
* **`background` :** C'est l'**arrière-plan** de la vue `ImageView` elle-même. L'image sera étirée ou répétée pour
  remplir la totalité des dimensions de la vue, sans tenir compte du `scaleType`. C'est le papier peint sur le mur
  derrière le cadre.

Utilisez `src` dans 99% des cas pour une `ImageView`.
</tip>

---

## TP 21 : Mini-galerie photo

**Objectif :** Créer une galerie simple où l'utilisateur peut changer une image principale en cliquant sur des
miniatures.

<procedure>

1. **Préparez vos ressources :** Trouvez trois images de votre choix (ex: `image_1.jpg`, `image_2.jpg`, `image_3.jpg`)
   et ajoutez-les au dossier `drawable`.
2. **Créez le layout :**
    * Utilisez un `LinearLayout` vertical.
    * En haut, placez une grande `ImageView` qui prendra une bonne partie de l'écran (ex: 300dp de hauteur). Donnez-lui
      l'ID `mainImageView`.
    * En bas, placez un `LinearLayout` horizontal.
    * À l'intérieur de ce `LinearLayout` horizontal, placez trois petites `ImageView` (ex: 80dp x 80dp) qui serviront de
      miniatures. Donnez-leur les ID `thumb1`, `thumb2`, `thumb3`.
    * Affichez statiquement chaque image dans sa miniature correspondante (`thumb1` affiche `image_1`, etc.).
3. **Dans `MainActivity.kt` :**
    * Configurez trois `setOnClickListener` distincts, un pour chaque miniature (`thumb1`, `thumb2`, `thumb3`).
    * Dans le listener de `thumb1`, appelez `binding.mainImageView.setImageResource(R.drawable.image_1)`.
    * Faites de même pour les deux autres miniatures.
4. **Testez :** L'application doit afficher une image principale. Cliquer sur les différentes miniatures en bas doit
   changer l'image principale.

</procedure>

---

## Conclusion et Prochaines Étapes

Vous savez maintenant comment intégrer des ressources graphiques dans vos applications, une compétence indispensable
pour créer des interfaces attrayantes. Vous maîtrisez le stockage dans le dossier `drawable`, l'affichage via
`ImageView`, et la mise à jour statique et dynamique.

**Pour aller plus loin :**
Pour charger des images depuis **Internet**, ou pour gérer de manière optimisée un grand nombre d'images locales (comme
dans une galerie), on n'utilise **jamais** `setImageResource` directement. Cette méthode ne gère ni le cache, ni
l'optimisation de la mémoire, ni le décodage en arrière-plan.

L'étape suivante, pour toute application réelle, est d'utiliser une **bibliothèque de chargement d'images**. Les deux
plus populaires sont :

* **[Glide](https://github.com/bumptech/glide)**
* **[Coil](https://coil-kt.github.io/coil/)** (100% Kotlin et moderne)

Ces bibliothèques simplifient le code et gèrent toute la complexité pour vous :

```kotlin
// Charger une image locale avec Coil
binding.myImageView.load(R.drawable.my_image)

// Charger une image depuis internet avec Coil
binding.myImageView.load("https://www.example.com/image.jpg")
```

Elles sont indispensables et nous vous encourageons à les explorer dès que vous êtes à l'aise avec les bases que nous
avons vues aujourd'hui.
<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-11-07T11:34:39.748595"><title>Module 15 : Communication R&eacute;active avec `LiveData` et `StateFlow` | Android</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"notions-abord-es","level":0,"title":"Notions abordées","anchor":"#notions-abord-es"},{"id":"le-pattern-observer","level":0,"title":"Le Pattern \"Observer\"","anchor":"#le-pattern-observer"},{"id":"livedata-observable-et-conscient-du-cycle-de-vie","level":0,"title":"LiveData : Observable et conscient du cycle de vie","anchor":"#livedata-observable-et-conscient-du-cycle-de-vie"},{"id":"stateflow-l-alternative-moderne-de-kotlin-coroutines","level":0,"title":"StateFlow : L\u0027alternative moderne de Kotlin Coroutines","anchor":"#stateflow-l-alternative-moderne-de-kotlin-coroutines"},{"id":"mise-en-pratique-rendre-le-compteur-r-actif","level":0,"title":"Mise en pratique : Rendre le compteur réactif","anchor":"#mise-en-pratique-rendre-le-compteur-r-actif"},{"id":"tp-15-application-de-notes-r-active","level":0,"title":"TP 15 : Application de Notes réactive","anchor":"#tp-15-application-de-notes-r-active"},{"id":"correction-du-tp-15","level":0,"title":"Correction du TP 15","anchor":"#correction-du-tp-15"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"conclusion-de-la-partie","level":0,"title":"Conclusion de la partie","anchor":"#conclusion-de-la-partie"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 15 : Communication R&eacute;active avec `LiveData` et `StateFlow` | Android"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Android Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/005-02-module-15.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 15 : Communication R&eacute;active avec `LiveData` et `StateFlow` | Android"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/005-02-module-15.html#webpage",
    "url": "writerside-documentation/005-02-module-15.html",
    "name": "Module 15 : Communication R&eacute;active avec `LiveData` et `StateFlow` | Android",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Android Help"
}</script><!-- End Schema.org --></head><body data-id="005-02-module-15" data-main-title="Module 15 : Communication Réactive avec `LiveData` et `StateFlow`" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="005-partie-05.md|Partie 5 : Architecture et Finalisation"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Android  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="005-02-module-15" id="005-02-module-15.md">Module 15 : Communication Réactive avec `LiveData` et `StateFlow`</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="z12zq7i_16">&Agrave; la fin de ce module, vous serez capable de :</p><ul class="list _bullet" id="z12zq7i_17"><li class="list__item" id="z12zq7i_18"><p id="z12zq7i_23">Comprendre le pattern &quot;Observer&quot; et son int&eacute;r&ecirc;t dans l'architecture MVVM.</p></li><li class="list__item" id="z12zq7i_19"><p id="z12zq7i_24">Utiliser <code class="code" id="z12zq7i_25">LiveData</code> pour exposer des donn&eacute;es observables depuis un ViewModel.</p></li><li class="list__item" id="z12zq7i_20"><p id="z12zq7i_26">&quot;Observer&quot; un <code class="code" id="z12zq7i_27">LiveData</code> depuis une View (Fragment/Activity) pour mettre &agrave; jour l'UI automatiquement.</p></li><li class="list__item" id="z12zq7i_21"><p id="z12zq7i_28">Comprendre le concept de <code class="code" id="z12zq7i_29">StateFlow</code> comme alternative moderne issue des Coroutines.</p></li><li class="list__item" id="z12zq7i_22"><p id="z12zq7i_30">Appliquer le principe de l'UI r&eacute;active pour d&eacute;coupler compl&egrave;tement la View du ViewModel.</p></li></ul></section><section class="chapter"><h2 id="introduction" data-toc="introduction">Introduction</h2><p id="z12zq7i_31">Revenons &agrave; notre exemple du compteur en MVVM. Chaque fois que nous cliquions sur le bouton, nous devions faire deux choses :</p><ol class="list _decimal" id="z12zq7i_32" type="1"><li class="list__item" id="z12zq7i_35"><p id="z12zq7i_37"><code class="code" id="z12zq7i_38">viewModel.increment()</code> (Notifier le ViewModel de l'action)</p></li><li class="list__item" id="z12zq7i_36"><p id="z12zq7i_39"><code class="code" id="z12zq7i_40">updateUi()</code> (Demander au ViewModel son nouvel &eacute;tat et mettre &agrave; jour l'UI)</p></li></ol><p id="z12zq7i_33">C'est un peu comme si, pour savoir si vous avez re&ccedil;u un nouvel e-mail, vous deviez cliquer manuellement sur le bouton &quot; Rafra&icirc;chir&quot; toutes les 30 secondes. C'est inefficace et fastidieux.</p><p id="z12zq7i_34">La communication <span class="control" id="z12zq7i_41">r&eacute;active</span> change compl&egrave;tement la donne. C'est comme s'abonner &agrave; une notification. Vous dites au service de messagerie : &quot;Pr&eacute;venez-moi <span class="control" id="z12zq7i_42">d&egrave;s qu'un nouvel e-mail arrive</span> &quot;. Vous n'avez plus besoin de v&eacute;rifier constamment. L'information vient &agrave; vous automatiquement. <code class="code" id="z12zq7i_43">LiveData</code> et <code class="code" id="z12zq7i_44">StateFlow</code> sont ces syst&egrave;mes de notification pour votre application. Le ViewModel expose un &eacute;tat, et la View s'y &quot;abonne&quot;. D&egrave;s que l'&eacute;tat change dans le ViewModel, la View est notifi&eacute;e et se met &agrave; jour toute seule.</p></section><section class="chapter"><h2 id="notions-abord-es" data-toc="notions-abord-es">Notions abord&eacute;es</h2><ul class="list _bullet" id="z12zq7i_45"><li class="list__item" id="z12zq7i_47"><p id="z12zq7i_51">Le Pattern &quot;Observer&quot;</p></li><li class="list__item" id="z12zq7i_48"><p id="z12zq7i_52"><code class="code" id="z12zq7i_53">LiveData</code>: Observable et conscient du cycle de vie</p></li><li class="list__item" id="z12zq7i_49"><p id="z12zq7i_54"><code class="code" id="z12zq7i_55">StateFlow</code>: L'alternative moderne de Kotlin Coroutines</p></li><li class="list__item" id="z12zq7i_50"><p id="z12zq7i_56">Mise en pratique : Rendre le compteur r&eacute;actif</p></li></ul></section><section class="chapter"><h2 id="le-pattern-observer" data-toc="le-pattern-observer">Le Pattern &quot;Observer&quot;</h2><section class="chapter"><h3 id="introduction-la-notion" data-toc="introduction-la-notion">Introduction &agrave; la notion</h3><p id="z12zq7i_59">Le pattern Observer, c'est comme s'abonner &agrave; une cha&icirc;ne YouTube. Vous (l' <span class="control" id="z12zq7i_60">Observer</span>) vous abonnez &agrave; la cha&icirc;ne d'un cr&eacute;ateur (le <span class="control" id="z12zq7i_61">Sujet</span> ou <span class="control" id="z12zq7i_62">Observable</span>). Vous n'allez pas v&eacute;rifier sa page toutes les heures. Quand le cr&eacute;ateur publie une nouvelle vid&eacute;o, YouTube vous envoie une notification. C'est le Sujet qui informe activement ses Observers d'un changement d'&eacute;tat.</p></section><section class="chapter"><h3 id="explication-de-la-notion" data-toc="explication-de-la-notion">Explication de la notion</h3><p id="z12zq7i_63">Ce design pattern d&eacute;finit une relation de d&eacute;pendance &quot;un-&agrave;-plusieurs&quot; entre des objets.</p><ul class="list _bullet" id="z12zq7i_64"><li class="list__item" id="z12zq7i_70"><p id="z12zq7i_72">Le <span class="control" id="z12zq7i_73">Sujet (Observable)</span> maintient une liste de ses d&eacute;pendants, les <span class="control" id="z12zq7i_74">Observers</span>.</p></li><li class="list__item" id="z12zq7i_71"><p id="z12zq7i_75">Quand l'&eacute;tat du Sujet change, il parcourt sa liste d'Observers et appelle une m&eacute;thode de notification sur chacun d' eux.</p></li></ul><p id="z12zq7i_65">Dans notre architecture MVVM :</p><ul class="list _bullet" id="z12zq7i_66"><li class="list__item" id="z12zq7i_76"><p id="z12zq7i_78">Le <span class="control" id="z12zq7i_79">ViewModel</span> contient le Sujet (le <code class="code" id="z12zq7i_80">LiveData</code> ou le <code class="code" id="z12zq7i_81">StateFlow</code>).</p></li><li class="list__item" id="z12zq7i_77"><p id="z12zq7i_82">La <span class="control" id="z12zq7i_83">View</span> (Fragment/Activity) est l'Observer.</p></li></ul><p id="z12zq7i_67">Cette approche permet un <span class="control" id="z12zq7i_84">d&eacute;couplage fort</span>: le ViewModel ne sait pas qui l'observe (il pourrait y avoir un, deux, ou z&eacute;ro observers). Il se contente de mettre &agrave; jour son &eacute;tat. La View, elle, ne sait pas pourquoi les donn&eacute;es ont chang&eacute;, elle se contente de r&eacute;agir &agrave; la notification.</p><style>.theme-dark .plantuml > svg {filter: hue-rotate(180deg) invert(0.9);}div.plantuml {overflow-x: auto;}</style><div class="plantuml"><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="304px" preserveAspectRatio="none" style="width:526px;height:304px;background:#FFFFFF;" version="1.1" viewBox="0 0 526 304" width="526px" zoomAndPan="magnify"><defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="122" x="195" y="23.5352">Pattern Observer</text><!--class ViewModel--><g id="elem_ViewModel"><rect codeLine="4" fill="#F1F1F1" height="80.9766" id="ViewModel" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="187" x="7" y="58.2405"/><ellipse cx="59.25" cy="74.2405" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M62.2231,79.8835 Q61.6421,80.1824 61.0029,80.3318 Q60.3638,80.4812 59.6582,80.4812 Q57.1514,80.4812 55.8315,78.8293 Q54.5117,77.1775 54.5117,74.0564 Q54.5117,70.927 55.8315,69.2751 Q57.1514,67.6233 59.6582,67.6233 Q60.3638,67.6233 61.0112,67.7727 Q61.6587,67.9221 62.2231,68.2209 L62.2231,70.9436 Q61.5923,70.3625 60.9988,70.0928 Q60.4053,69.823 59.7744,69.823 Q58.4297,69.823 57.7449,70.8896 Q57.0601,71.9563 57.0601,74.0564 Q57.0601,76.1482 57.7449,77.2148 Q58.4297,78.2815 59.7744,78.2815 Q60.4053,78.2815 60.9988,78.0117 Q61.5923,77.7419 62.2231,77.1609 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="74" x="79.75" y="79.5315">ViewModel</text><line style="stroke:#181818;stroke-width:0.5;" x1="8" x2="193" y1="90.2405" y2="90.2405"/><rect fill="none" height="6" style="stroke:#C82930;stroke-width:1.0;" width="6" x="15" y="100.9846"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="161" x="27" y="107.7756">state: LiveData&lt;String&gt;</text><line style="stroke:#181818;stroke-width:0.5;" x1="8" x2="193" y1="114.7287" y2="114.7287"/><ellipse cx="18" cy="128.4729" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="154" x="27" y="132.2639">updateState(newState)</text></g><!--class Fragment--><g id="elem_Fragment"><rect codeLine="9" fill="#F1F1F1" height="64.4883" id="Fragment" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="183" x="336" y="66.4805"/><ellipse cx="390.25" cy="82.4805" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M393.2231,88.1235 Q392.6421,88.4224 392.0029,88.5718 Q391.3638,88.7212 390.6582,88.7212 Q388.1514,88.7212 386.8315,87.0693 Q385.5117,85.4175 385.5117,82.2964 Q385.5117,79.167 386.8315,77.5151 Q388.1514,75.8633 390.6582,75.8633 Q391.3638,75.8633 392.0112,76.0127 Q392.6587,76.1621 393.2231,76.4609 L393.2231,79.1836 Q392.5923,78.6025 391.9988,78.3328 Q391.4053,78.063 390.7744,78.063 Q389.4297,78.063 388.7449,79.1296 Q388.0601,80.1963 388.0601,82.2964 Q388.0601,84.3882 388.7449,85.4548 Q389.4297,86.5215 390.7744,86.5215 Q391.4053,86.5215 391.9988,86.2517 Q392.5923,85.9819 393.2231,85.4009 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="66" x="410.75" y="87.7715">Fragment</text><line style="stroke:#181818;stroke-width:0.5;" x1="337" x2="518" y1="98.4805" y2="98.4805"/><line style="stroke:#181818;stroke-width:0.5;" x1="337" x2="518" y1="106.4805" y2="106.4805"/><ellipse cx="347" cy="120.2246" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="157" x="356" y="124.0156">onStateChanged(state)</text></g><!--class Subject--><g id="elem_Subject"><rect fill="#F1F1F1" height="97.4648" id="Subject" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="167" x="17" y="200.2205"/><ellipse cx="71.25" cy="216.2205" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M74.2231,221.8635 Q73.6421,222.1624 73.0029,222.3118 Q72.3638,222.4612 71.6582,222.4612 Q69.1514,222.4612 67.8315,220.8093 Q66.5117,219.1575 66.5117,216.0364 Q66.5117,212.907 67.8315,211.2551 Q69.1514,209.6033 71.6582,209.6033 Q72.3638,209.6033 73.0112,209.7527 Q73.6587,209.9021 74.2231,210.2009 L74.2231,212.9236 Q73.5923,212.3425 72.9988,212.0728 Q72.4053,211.803 71.7744,211.803 Q70.4297,211.803 69.7449,212.8696 Q69.0601,213.9363 69.0601,216.0364 Q69.0601,218.1282 69.7449,219.1948 Q70.4297,220.2615 71.7744,220.2615 Q72.4053,220.2615 72.9988,219.9917 Q73.5923,219.7219 74.2231,219.1409 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="50" x="91.75" y="221.5115">Subject</text><line style="stroke:#181818;stroke-width:0.5;" x1="18" x2="183" y1="232.2205" y2="232.2205"/><line style="stroke:#181818;stroke-width:0.5;" x1="18" x2="183" y1="240.2205" y2="240.2205"/><ellipse cx="28" cy="253.9646" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="123" x="37" y="257.7556">register(observer)</text><ellipse cx="28" cy="270.4529" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="141" x="37" y="274.2439">unregister(observer)</text><ellipse cx="28" cy="286.9412" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="118" x="37" y="290.7322">notifyObservers()</text></g><!--class Observer--><g id="elem_Observer"><rect fill="#F1F1F1" height="64.4883" id="Observer" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="94" x="380.5" y="216.7005"/><ellipse cx="395.5" cy="232.7005" fill="#ADD1B2" rx="11" ry="11" style="stroke:#181818;stroke-width:1.0;"/><path d="M398.4731,238.3435 Q397.8921,238.6424 397.2529,238.7918 Q396.6138,238.9412 395.9082,238.9412 Q393.4014,238.9412 392.0815,237.2893 Q390.7617,235.6375 390.7617,232.5164 Q390.7617,229.387 392.0815,227.7351 Q393.4014,226.0833 395.9082,226.0833 Q396.6138,226.0833 397.2612,226.2327 Q397.9087,226.3821 398.4731,226.6809 L398.4731,229.4036 Q397.8423,228.8225 397.2488,228.5528 Q396.6553,228.283 396.0244,228.283 Q394.6797,228.283 393.9949,229.3496 Q393.3101,230.4163 393.3101,232.5164 Q393.3101,234.6082 393.9949,235.6748 Q394.6797,236.7415 396.0244,236.7415 Q396.6553,236.7415 397.2488,236.4717 Q397.8423,236.2019 398.4731,235.6209 Z " fill="#000000"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="62" x="409.5" y="237.9915">Observer</text><line style="stroke:#181818;stroke-width:0.5;" x1="381.5" x2="473.5" y1="248.7005" y2="248.7005"/><line style="stroke:#181818;stroke-width:0.5;" x1="381.5" x2="473.5" y1="256.7005" y2="256.7005"/><ellipse cx="391.5" cy="270.4446" fill="#84BE84" rx="3" ry="3" style="stroke:#038048;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="58" x="400.5" y="274.2356">update()</text></g><!--link ViewModel to Subject--><g id="link_ViewModel_Subject"><path codeLine="13" d="M100.5,139.4505 C100.5,158.0605 100.5,162.3805 100.5,181.9305 " fill="none" id="ViewModel-to-Subject" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="none" points="100.5,199.9305,106.5,181.9305,94.5,181.9305,100.5,199.9305" style="stroke:#181818;stroke-width:1.0;"/></g><!--link Fragment to Observer--><g id="link_Fragment_Observer"><path codeLine="14" d="M427.5,131.1605 C427.5,156.2305 427.5,173.1805 427.5,198.3005 " fill="none" id="Fragment-to-Observer" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="none" points="427.5,216.3005,433.5,198.3005,421.5,198.3005,427.5,216.3005" style="stroke:#181818;stroke-width:1.0;"/></g><!--link ViewModel to Fragment--><g id="link_ViewModel_Fragment"><path codeLine="22" d="M194.21,98.7305 C238.65,98.7305 285.57,98.7305 329.76,98.7305 " fill="none" id="ViewModel-to-Fragment" style="stroke:#181818;stroke-width:1.0;"/><polygon fill="#181818" points="335.76,98.7305,326.76,94.7305,330.76,98.7305,326.76,102.7305,335.76,98.7305" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="41" x="244.5" y="57.2988">notifie</text><path d="M216.5,66.041 L216.5,91.041 L313.5,91.041 L313.5,76.041 L303.5,66.041 L216.5,66.041 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M303.5,66.041 L303.5,76.041 L313.5,76.041 L303.5,66.041 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="76" x="222.5" y="83.6094">via LiveData</text></g><!--SRC=[VP3F3e8m3CRlUueU8OGN88QBnfD64nBl0ofMiJDRWHZrtOM5FvuyhUkl_TglGb8Z7BK8MeP3xj2sQ9KgQkqSd0YxlIcnXfS2Y9remGHsrE96YrvbOechj4THyoXxbWq50MFdWr1z9g6jrTKTMRnEPDZpzKLpXMNWvk9bNXo_KyYQ_8g5gBdRPvSbHmu9H1OhShs7m8mq_AKD_-TiXCxFITW5eLBJnxTxSqFsPy5qCPM05o1K_OjW66hYMm8jwVbONm00]--></g></svg></div></section></section><section class="chapter"><h2 id="livedata-observable-et-conscient-du-cycle-de-vie" data-toc="livedata-observable-et-conscient-du-cycle-de-vie"><code class="code" id="z12zq7i_89">LiveData</code>: Observable et conscient du cycle de vie</h2><section class="chapter"><h3 id="introduction-la-notion_1" data-toc="introduction-la-notion_1">Introduction &agrave; la notion</h3><p id="z12zq7i_90"><code class="code" id="z12zq7i_91">LiveData</code> est un syst&egrave;me de notification intelligent. Il ne vous envoie des notifications que si vous &ecirc;tes &quot; disponible&quot;. Si vous mettez votre t&eacute;l&eacute;phone en mode &quot;Ne pas d&eacute;ranger&quot; (votre application est en arri&egrave;re-plan), <code class="code" id="z12zq7i_92">LiveData</code> garde les notifications pour lui et vous les d&eacute;livre d&egrave;s que vous d&eacute;sactivez ce mode.</p></section><section class="chapter"><h3 id="explication-de-la-notion_1" data-toc="explication-de-la-notion_1">Explication de la notion</h3><p id="z12zq7i_93"><code class="code" id="z12zq7i_97">LiveData</code> est un conteneur de donn&eacute;es observable fourni par Android Jetpack. Il a deux caract&eacute;ristiques magiques :</p><ol class="list _decimal" id="z12zq7i_94" type="1"><li class="list__item" id="z12zq7i_98"><p id="z12zq7i_100"><span class="control" id="z12zq7i_101">Observable :</span> Comme nous l'avons vu, on peut s'y abonner pour &ecirc;tre notifi&eacute; des changements.</p></li><li class="list__item" id="z12zq7i_99"><p id="z12zq7i_102"><span class="control" id="z12zq7i_104">Conscient du cycle de vie (Lifecycle-Aware) :</span> C'est son plus grand avantage. <code class="code" id="z12zq7i_105">LiveData</code> ne notifie les observers (votre UI) que s'ils sont dans un &eacute;tat de cycle de vie actif (<code class="code" id="z12zq7i_106">STARTED</code> ou <code class="code" id="z12zq7i_107">RESUMED</code>).</p><ul class="list _bullet" id="z12zq7i_103"><li class="list__item" id="z12zq7i_108"><p id="z12zq7i_111">Si votre Fragment est en arri&egrave;re-plan (<code class="code" id="z12zq7i_112">STOPPED</code>), il ne recevra pas la mise &agrave; jour, &eacute;vitant ainsi des crashs potentiels.</p></li><li class="list__item" id="z12zq7i_109"><p id="z12zq7i_113">Quand le Fragment revient au premier plan, <code class="code" id="z12zq7i_114">LiveData</code> lui d&eacute;livre imm&eacute;diatement la derni&egrave;re valeur disponible.</p></li><li class="list__item" id="z12zq7i_110"><p id="z12zq7i_115">Quand votre Fragment est d&eacute;truit (<code class="code" id="z12zq7i_116">DESTROYED</code>), <code class="code" id="z12zq7i_117">LiveData</code> supprime automatiquement l'abonnement pour vous, &eacute;vitant les fuites de m&eacute;moire.</p></li></ul></li></ol><p id="z12zq7i_95"><span class="control" id="z12zq7i_118">MutableLiveData vs LiveData</span> Pour respecter le principe d'encapsulation, la pratique courante est d'utiliser :</p><ul class="list _bullet" id="z12zq7i_96"><li class="list__item" id="z12zq7i_119"><p id="z12zq7i_121">Un <code class="code" id="z12zq7i_122">MutableLiveData</code> <span class="control" id="z12zq7i_123">priv&eacute;</span> dans le ViewModel. Seul le ViewModel peut modifier sa valeur (<code class="code" id="z12zq7i_124">_myState.value = ...</code> ou <code class="code" id="z12zq7i_125">_myState.postValue(...)</code>).</p></li><li class="list__item" id="z12zq7i_120"><p id="z12zq7i_126">Un <code class="code" id="z12zq7i_127">LiveData</code> <span class="control" id="z12zq7i_128">public</span> qui expose la version &quot;lecture seule&quot; du <code class="code" id="z12zq7i_129">MutableLiveData</code> &agrave; la View.</p></li></ul></section><section class="chapter"><h3 id="exemple-de-code" data-toc="exemple-de-code">Exemple de code</h3><p id="z12zq7i_130"><span class="control" id="z12zq7i_136">Dans le ViewModel :</span></p><div class="code-block" data-lang="kotlin">
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

class MyViewModel : ViewModel() {

    // 1. Version privée, modifiable, pour l'intérieur du ViewModel
    private val _username = MutableLiveData&lt;String&gt;()

    // 2. Version publique, lecture seule, pour l'extérieur (la View)
    val username: LiveData&lt;String&gt;
        get() = _username

    fun fetchUser() {
        // Simule un chargement de données
        _username.value = &quot;John Doe&quot;
    }
}
</div><p id="z12zq7i_132"><span class="control" id="z12zq7i_137">Dans le Fragment (la View) :</span></p><div class="code-block" data-lang="kotlin">
// Dans onViewCreated du Fragment
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    // 1. On s'abonne (observe) au LiveData du ViewModel
    viewModel.username.observe(viewLifecycleOwner) { newName -&gt;
        // 2. Ce bloc de code (lambda) est appelé à chaque changement
        // et aussi une fois lors de la création de l'abonnement.
        binding.usernameTextView.text = newName
    }

    // Le bouton demande juste au ViewModel de faire son travail.
    // Il ne se soucie pas de la mise à jour de l'UI.
    binding.loadUserButton.setOnClickListener {
        viewModel.fetchUser()
    }
}
</div><aside class="prompt" data-type="tip" data-title="" id="z12zq7i_134"><p>L'argument `viewLifecycleOwner` est crucial. Il indique &agrave; `LiveData` qu'il doit suivre le cycle de vie de la **vue** du Fragment, et non du Fragment lui-m&ecirc;me, pour g&eacute;rer l'abonnement.</p></aside></section></section><section class="chapter"><h2 id="stateflow-l-alternative-moderne-de-kotlin-coroutines" data-toc="stateflow-l-alternative-moderne-de-kotlin-coroutines"><code class="code" id="z12zq7i_142">StateFlow</code>: L'alternative moderne de Kotlin Coroutines</h2><section class="chapter"><h3 id="introduction-la-notion_2" data-toc="introduction-la-notion_2">Introduction &agrave; la notion</h3><p id="z12zq7i_143">Si <code class="code" id="z12zq7i_144">LiveData</code> est le service de notification standard, <code class="code" id="z12zq7i_145">StateFlow</code> est une version plus moderne et plus puissante qui vient du monde des Coroutines. Il fonctionne de mani&egrave;re tr&egrave;s similaire mais est 100% Kotlin et s'int&egrave;gre encore mieux dans un flux de donn&eacute;es asynchrones complexe. C'est un peu comme passer de SMS &agrave; une application de messagerie instantan&eacute;e.</p></section><section class="chapter"><h3 id="explication-de-la-notion_2" data-toc="explication-de-la-notion_2">Explication de la notion</h3><p id="z12zq7i_146"><code class="code" id="z12zq7i_151">StateFlow</code> est un type sp&eacute;cial de <code class="code" id="z12zq7i_152">Flow</code> (un flux de donn&eacute;es asynchrones en Kotlin) qui est optimis&eacute; pour repr&eacute;senter un &eacute;tat.</p><ul class="list _bullet" id="z12zq7i_147"><li class="list__item" id="z12zq7i_153"><p id="z12zq7i_156">Il a toujours une valeur initiale.</p></li><li class="list__item" id="z12zq7i_154"><p id="z12zq7i_157">Il ne rediffuse sa valeur que si elle a chang&eacute; (<code class="code" id="z12zq7i_158">distinctUntilChanged</code>).</p></li><li class="list__item" id="z12zq7i_155"><p id="z12zq7i_159">Il est &quot;chaud&quot; (<code class="code" id="z12zq7i_160">hot</code>), ce qui signifie qu'il reste actif et maintient sa valeur m&ecirc;me si personne ne l'&eacute;coute.</p></li></ul><p id="z12zq7i_148">L'utilisation est tr&egrave;s similaire &agrave; <code class="code" id="z12zq7i_161">LiveData</code>:</p><ul class="list _bullet" id="z12zq7i_149"><li class="list__item" id="z12zq7i_162"><p id="z12zq7i_164"><code class="code" id="z12zq7i_165">MutableStateFlow</code> priv&eacute; dans le ViewModel.</p></li><li class="list__item" id="z12zq7i_163"><p id="z12zq7i_166"><code class="code" id="z12zq7i_167">StateFlow</code> public et en lecture seule expos&eacute; &agrave; la View.</p></li></ul><p id="z12zq7i_150">La mani&egrave;re d'observer est un peu diff&eacute;rente. On utilise g&eacute;n&eacute;ralement <code class="code" id="z12zq7i_168">lifecycleScope.launch</code> et on &quot;collecte&quot; le flux.</p></section><section class="chapter"><h3 id="exemple-de-code_1" data-toc="exemple-de-code_1">Exemple de code</h3><p id="z12zq7i_169"><span class="control" id="z12zq7i_175">Dans le ViewModel :</span></p><div class="code-block" data-lang="kotlin">
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow

class MyViewModel : ViewModel() {
    private val _username = MutableStateFlow(&quot;Guest&quot;) // Doit avoir une valeur initiale
    val username: StateFlow&lt;String&gt; = _username.asStateFlow()

    fun fetchUser() {
        _username.value = &quot;Jane Doe&quot;
    }
}
</div><p id="z12zq7i_171"><span class="control" id="z12zq7i_176">Dans le Fragment :</span></p><div class="code-block" data-lang="kotlin">
// Dans onViewCreated du Fragment
override fun onViewCreated(view: View, savedInstanceState: Bundle?) {
    super.onViewCreated(view, savedInstanceState)

    // On lance une coroutine qui vivra aussi longtemps que la vue
    viewLifecycleOwner.lifecycleScope.launch {
        // repeatOnLifecycle garantit que la collecte s'arrête
        // quand la vue est en arrière-plan et reprend quand elle revient.
        viewLifecycleOwner.repeatOnLifecycle(Lifecycle.State.STARTED) {
            // On &quot;collecte&quot; les mises à jour du StateFlow
            viewModel.username.collect { newName -&gt;
                binding.usernameTextView.text = newName
            }
        }
    }
}
</div><aside class="prompt" data-type="note" data-title="" id="z12zq7i_173"><p>Aujourd'hui, `StateFlow` est souvent pr&eacute;f&eacute;r&eacute; dans les projets 100% Kotlin pour sa meilleure int&eacute;gration avec les coroutines. `LiveData` reste une solution tr&egrave;s simple et robuste, surtout pour les d&eacute;butants.</p></aside></section></section><section class="chapter"><h2 id="mise-en-pratique-rendre-le-compteur-r-actif" data-toc="mise-en-pratique-rendre-le-compteur-r-actif">Mise en pratique : Rendre le compteur r&eacute;actif</h2><section class="chapter"><h3 id="exercice-1-refactoriser-le-compteur-avec-livedata" data-toc="exercice-1-refactoriser-le-compteur-avec-livedata">Exercice 1 : Refactoriser le compteur avec <code class="code" id="z12zq7i_187">LiveData</code></h3><p id="z12zq7i_179"><span class="control" id="z12zq7i_188">&Eacute;nonc&eacute; :</span> Reprenez le code de l'exercice du module 14 (le compteur en MVVM). Modifiez-le pour que l'Activity n'ait plus besoin d'appeler <code class="code" id="z12zq7i_189">updateUi()</code> manuellement. L'UI doit se mettre &agrave; jour automatiquement gr&acirc;ce &agrave; <code class="code" id="z12zq7i_190">LiveData</code>.</p><p id="z12zq7i_180"><span class="control" id="z12zq7i_191">Correction exercice 1</span></p><p id="z12zq7i_181"><span class="control" id="z12zq7i_192">1. <code class="code" id="z12zq7i_193">CounterViewModel.kt</code></span></p><div class="code-block" data-lang="kotlin">
package fr.formation.compteurapp.viewmodel

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel

class CounterViewModel : ViewModel() {

    // On expose maintenant l'état via LiveData
    private val _count = MutableLiveData&lt;Int&gt;(0) // Valeur initiale à 0
    val count: LiveData&lt;Int&gt;
        get() = _count

    fun incrementCounter() {
        // On met à jour la valeur du LiveData.
        // Les observers seront notifiés automatiquement.
        _count.value = (_count.value ?: 0) + 1
    }
}
</div><p id="z12zq7i_183"><span class="control" id="z12zq7i_194">2. <code class="code" id="z12zq7i_195">MainActivity.kt</code></span></p><div class="code-block" data-lang="kotlin">
package fr.formation.compteurapp

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.activity.viewModels
import fr.formation.compteurapp.databinding.ActivityMainBinding
import fr.formation.compteurapp.viewmodel.CounterViewModel

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private val viewModel: CounterViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // L'Activity ne fait plus que notifier le ViewModel des actions
        binding.incrementButton.setOnClickListener {
            viewModel.incrementCounter()
        }

        // Et s'abonner aux changements d'état
        viewModel.count.observe(this) { newCount -&gt;
            // Ce bloc est appelé automatiquement quand la valeur de 'count' change
            binding.counterTextView.text = newCount.toString()
        }
    }
}
</div><p id="z12zq7i_185">L'Activity est maintenant compl&egrave;tement d&eacute;coupl&eacute;e de la logique de mise &agrave; jour. Elle ne fait que d&eacute;clarer &quot;quand cette donn&eacute;e change, fais cette action&quot;.</p></section></section><section class="chapter"><h2 id="tp-15-application-de-notes-r-active" data-toc="tp-15-application-de-notes-r-active">TP 15 : Application de Notes r&eacute;active</h2><p id="z12zq7i_196"><span class="control" id="z12zq7i_198">Objectif :</span> Finaliser notre application de notes en impl&eacute;mentant une architecture MVVM compl&egrave;te et r&eacute;active avec <code class="code" id="z12zq7i_199">LiveData</code>.</p><section class="procedure-steps" id="z12zq7i_197"><ol class="list _decimal" id="z12zq7i_200" type="1"><li class="list__item" id="z12zq7i_201"><p id="z12zq7i_206"><span class="control" id="z12zq7i_207">Reprenez le TP du module 14</span> o&ugrave; nous avions cr&eacute;&eacute; <code class="code" id="z12zq7i_208">NoteRepository</code> et <code class="code" id="z12zq7i_209">NoteViewModel</code>.</p></li><li class="list__item" id="z12zq7i_202"><p id="z12zq7i_210"><span class="control" id="z12zq7i_212">Modifiez le <code class="code" id="z12zq7i_215">NoteRepository</code>:</span> Changez la m&eacute;thode <code class="code" id="z12zq7i_213">getAllNotes()</code> pour qu'elle retourne un <code class="code" id="z12zq7i_214">LiveData&lt;List&lt;Note&gt;&gt;</code> directement depuis le DAO. Room a une int&eacute;gration magique pour &ccedil;a !</p><div class="code-block" data-lang="kotlin">
// Dans NoteDao.kt
@Query(&quot;SELECT * FROM notes&quot;)
fun getAllNotes(): LiveData&lt;List&lt;Note&gt;&gt; // Room gère la mise à jour auto !

// Dans NoteRepository.kt
class NoteRepository(private val noteDao: NoteDao) {
    val allNotes: LiveData&lt;List&lt;Note&gt;&gt; = noteDao.getAllNotes()

    suspend fun insert(note: Note) {
        noteDao.insert(note)
    }
}
</div></li><li class="list__item" id="z12zq7i_203"><p id="z12zq7i_216"><span class="control" id="z12zq7i_220">Modifiez le <code class="code" id="z12zq7i_221">NoteViewModel</code>:</span></p><ul class="list _bullet" id="z12zq7i_217"><li class="list__item" id="z12zq7i_222"><p id="z12zq7i_224">Il doit exposer le <code class="code" id="z12zq7i_225">LiveData&lt;List&lt;Note&gt;&gt;</code> du Repository.</p></li><li class="list__item" id="z12zq7i_223"><p id="z12zq7i_226">Il doit avoir une m&eacute;thode <code class="code" id="z12zq7i_227">insert(note: Note)</code> qui lance une coroutine (<code class="code" id="z12zq7i_228">viewModelScope.launch</code>) pour appeler la m&eacute;thode <code class="code" id="z12zq7i_229">suspend</code> du Repository.</p></li></ul><div class="code-block" data-lang="kotlin">
class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: NoteRepository
    val allNotes: LiveData&lt;List&lt;Note&gt;&gt;

    init {
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao)
        allNotes = repository.allNotes
    }

    fun insert(note: Note) = viewModelScope.launch {
        repository.insert(note)
    }
}
</div><p id="z12zq7i_219">(On utilise <code class="code" id="z12zq7i_230">AndroidViewModel</code> pour avoir acc&egrave;s au <code class="code" id="z12zq7i_231">Context</code> n&eacute;cessaire pour la base de donn&eacute;es).</p></li><li class="list__item" id="z12zq7i_204"><p id="z12zq7i_232"><span class="control" id="z12zq7i_234">Modifiez la <code class="code" id="z12zq7i_235">MainActivity</code> (la View) :</span></p><ul class="list _bullet" id="z12zq7i_233"><li class="list__item" id="z12zq7i_236"><p id="z12zq7i_240">Elle ne doit plus contenir de logique de BDD.</p></li><li class="list__item" id="z12zq7i_237"><p id="z12zq7i_241">Dans <code class="code" id="z12zq7i_242">onCreate</code>, observez le <code class="code" id="z12zq7i_243">viewModel.allNotes</code>.</p></li><li class="list__item" id="z12zq7i_238"><p id="z12zq7i_244">Dans le lambda de l'observer, mettez &agrave; jour votre <code class="code" id="z12zq7i_245">NoteAdapter</code> avec la nouvelle liste de notes.</p></li><li class="list__item" id="z12zq7i_239"><p id="z12zq7i_246">Le <code class="code" id="z12zq7i_247">onClickListener</code> du bouton &quot;Ajouter&quot; doit simplement cr&eacute;er une <code class="code" id="z12zq7i_248">Note</code> et appeler <code class="code" id="z12zq7i_249">viewModel.insert(newNote)</code>.</p></li></ul></li><li class="list__item" id="z12zq7i_205"><p id="z12zq7i_250"><span class="control" id="z12zq7i_251">Testez :</span> Quand vous ajoutez une note, elle doit appara&icirc;tre dans la liste <span class="control" id="z12zq7i_252">automatiquement</span> sans que vous ayez besoin de rafra&icirc;chir manuellement la liste. C'est la magie de Room + LiveData !</p></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="correction-du-tp-15" data-toc="correction-du-tp-15">Correction du TP 15</h2></div><div class="collapse__content"><section class="chapter"><h3 id="tape-1-pr-requis-code-de-d-part" data-toc="tape-1-pr-requis-code-de-d-part">&Eacute;tape 1 : Pr&eacute;requis (Code de d&eacute;part)</h3><p id="z12zq7i_258">Nous repartons des classes du module pr&eacute;c&eacute;dent, que nous allons modifier.</p><ul class="list _bullet" id="z12zq7i_259"><li class="list__item" id="z12zq7i_261"><p id="z12zq7i_267"><span class="control" id="z12zq7i_268"><code class="code" id="z12zq7i_269">Note.kt</code></span> (Entit&eacute;, reste inchang&eacute;e)</p></li><li class="list__item" id="z12zq7i_262"><p id="z12zq7i_270"><span class="control" id="z12zq7i_271"><code class="code" id="z12zq7i_272">NoteDao.kt</code></span> (Interface d'acc&egrave;s aux donn&eacute;es)</p></li><li class="list__item" id="z12zq7i_263"><p id="z12zq7i_273"><span class="control" id="z12zq7i_274"><code class="code" id="z12zq7i_275">AppDatabase.kt</code></span> (Classe de la base de donn&eacute;es)</p></li><li class="list__item" id="z12zq7i_264"><p id="z12zq7i_276"><span class="control" id="z12zq7i_277"><code class="code" id="z12zq7i_278">NoteRepository.kt</code></span> (Couche d'abstraction des donn&eacute;es)</p></li><li class="list__item" id="z12zq7i_265"><p id="z12zq7i_279"><span class="control" id="z12zq7i_280"><code class="code" id="z12zq7i_281">NoteViewModel.kt</code></span> (Logique m&eacute;tier et &eacute;tat de l'UI)</p></li><li class="list__item" id="z12zq7i_266"><p id="z12zq7i_282"><span class="control" id="z12zq7i_283"><code class="code" id="z12zq7i_284">MainActivity.kt</code></span> (La vue)</p></li></ul></section><section class="chapter"><h3 id="tape-2-modification-du-dao-et-du-repository" data-toc="tape-2-modification-du-dao-et-du-repository">&Eacute;tape 2 : Modification du DAO et du Repository</h3><p id="z12zq7i_285">C'est ici que la magie commence. Room va automatiquement g&eacute;rer la mise &agrave; jour du <code class="code" id="z12zq7i_288">LiveData</code>.</p><section class="chapter"><h4 id="notedao-kt" data-toc="notedao-kt"><code class="code" id="z12zq7i_292">NoteDao.kt</code></h4><p id="z12zq7i_290">On change le type de retour de <code class="code" id="z12zq7i_293">getAllNotes</code> pour <code class="code" id="z12zq7i_294">LiveData&lt;List&lt;Note&gt;&gt;</code> et on s'assure que <code class="code" id="z12zq7i_295">insert</code> est une fonction <code class="code" id="z12zq7i_296">suspend</code>.</p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.data

import androidx.lifecycle.LiveData
import androidx.room.Dao
import androidx.room.Insert
import androidx.room.OnConflictStrategy
import androidx.room.Query

@Dao
interface NoteDao {
    // MODIFICATION CLÉ : Le type de retour est maintenant LiveData.
    // Room va automatiquement exécuter cette requête sur un thread de fond
    // et notifier les observateurs quand les données de 'note_table' changent.
    @Query(&quot;SELECT * FROM note_table ORDER BY id DESC&quot;)
    fun getAllNotes(): LiveData&lt;List&lt;Note&gt;&gt;

    // L'insertion reste une opération 'suspend' car c'est une action ponctuelle.
    @Insert(onConflict = OnConflictStrategy.IGNORE)
    suspend fun insert(note: Note)
}
</div></section><section class="chapter"><h4 id="noterepository-kt" data-toc="noterepository-kt"><code class="code" id="z12zq7i_301">NoteRepository.kt</code></h4><p id="z12zq7i_298">Le repository devient beaucoup plus simple pour la lecture. Il expose directement le <code class="code" id="z12zq7i_302">LiveData</code> du DAO.</p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.data

import androidx.lifecycle.LiveData

/**
 * Le Repository expose maintenant une source de données observable (LiveData)
 * et des méthodes pour les actions de modification (insert, update, delete).
 */
class NoteRepository(private val noteDao: NoteDao) {

    // On ne l'appelle plus via une fonction, on expose directement la propriété LiveData.
    val allNotes: LiveData&lt;List&lt;Note&gt;&gt; = noteDao.getAllNotes()

    // La méthode d'insertion reste la même.
    suspend fun insert(note: Note) {
        noteDao.insert(note)
    }
}
</div></section></section><section class="chapter"><h3 id="tape-3-modification-du-noteviewmodel" data-toc="tape-3-modification-du-noteviewmodel">&Eacute;tape 3 : Modification du <code class="code" id="z12zq7i_308">NoteViewModel</code></h3><p id="z12zq7i_304">Le ViewModel va maintenant s'appuyer sur le <code class="code" id="z12zq7i_309">LiveData</code> du Repository et utiliser <code class="code" id="z12zq7i_310">viewModelScope</code> pour les op&eacute;rations d'&eacute;criture.</p><p id="z12zq7i_305"><span class="emphasis" id="z12zq7i_311">N'oubliez pas d'ajouter la d&eacute;pendance <code class="code" id="z12zq7i_312">implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0&quot;)</code> si ce n'est pas d&eacute;j&agrave; fait.</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.ui

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.viewModelScope
import com.example.yourapplication.data.AppDatabase
import com.example.yourapplication.data.Note
import com.example.yourapplication.data.NoteRepository
import kotlinx.coroutines.launch

/**
 * On utilise AndroidViewModel pour pouvoir accéder au contexte de l'Application,
 * ce qui est nécessaire pour initialiser la base de données.
 */
class NoteViewModel(application: Application) : AndroidViewModel(application) {

    private val repository: NoteRepository
    val allNotes: LiveData&lt;List&lt;Note&gt;&gt;

    init {
        // Initialisation des dépendances. C'est une forme simple d'injection.
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao)
        allNotes = repository.allNotes
    }

    /**
     * Lance une nouvelle coroutine pour insérer la donnée de manière non-bloquante.
     * viewModelScope garantit que la coroutine sera annulée si le ViewModel est détruit.
     */
    fun insert(note: Note) = viewModelScope.launch {
        repository.insert(note)
    }
}
</div></section><section class="chapter"><h3 id="tape-4-modification-de-la-mainactivity-la-view" data-toc="tape-4-modification-de-la-mainactivity-la-view">&Eacute;tape 4 : Modification de la <code class="code" id="z12zq7i_318">MainActivity</code> (la View)</h3><p id="z12zq7i_314">L'activit&eacute; devient tr&egrave;s &quot;b&ecirc;te&quot;. Son r&ocirc;le se limite &agrave; :</p><ol class="list _decimal" id="z12zq7i_315" type="1"><li class="list__item" id="z12zq7i_319"><p id="z12zq7i_321">Observer les donn&eacute;es du ViewModel.</p></li><li class="list__item" id="z12zq7i_320"><p id="z12zq7i_322">Notifier le ViewModel des actions de l'utilisateur.</p></li></ol><section class="chapter"><h4 id="pr-requis-noteadapter-kt" data-toc="pr-requis-noteadapter-kt">Pr&eacute;requis : <code class="code" id="z12zq7i_326">NoteAdapter.kt</code></h4><p id="z12zq7i_324">Assurez-vous que votre adaptateur a une m&eacute;thode pour mettre &agrave; jour sa liste.</p><div class="code-block" data-lang="kotlin">
// Dans NoteAdapter.kt
class NoteAdapter(...) {
    // ...
    fun submitList(notes: List&lt;Note&gt;) {
        this.notes = notes
        notifyDataSetChanged() // Pour ce TP, c'est suffisant.
    }
}
</div></section><section class="chapter"><h4 id="mainactivity-kt" data-toc="mainactivity-kt"><code class="code" id="z12zq7i_331">MainActivity.kt</code></h4><p id="z12zq7i_328">Voici le code final de l'activit&eacute;. Toute la logique de donn&eacute;es a disparu.</p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import androidx.activity.viewModels
import androidx.recyclerview.widget.LinearLayoutManager
import com.example.yourapplication.data.Note
import com.example.yourapplication.databinding.ActivityMainBinding
import com.example.yourapplication.ui.NoteAdapter
import com.example.yourapplication.ui.NoteViewModel

class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    private lateinit var noteAdapter: NoteAdapter

    // Obtention du ViewModel de manière propre, gérée par le cycle de vie.
    private val noteViewModel: NoteViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // Initialisation du RecyclerView et de l'Adapter
        setupRecyclerView()

        // --- PARTIE CRUCIALE : OBSERVER LE LIVEDATA ---
        // L'Activity s'abonne aux changements de la liste de notes.
        noteViewModel.allNotes.observe(this) { notes -&gt;
            // Ce bloc de code sera exécuté automatiquement chaque fois
            // que la liste de notes change dans la base de données.
            notes?.let {
                noteAdapter.submitList(it)
            }
        }

        // Le listener du bouton notifie simplement le ViewModel.
        binding.addButton.setOnClickListener {
            val title = binding.titleEditText.text.toString().trim()
            val content = binding.contentEditText.text.toString().trim()

            if (title.isNotEmpty() &amp;&amp; content.isNotEmpty()) {
                val newNote = Note(title = title, content = content)
                // On demande au ViewModel d'insérer la note. C'est tout !
                // Pas besoin de rafraîchir l'UI manuellement.
                noteViewModel.insert(newNote)

                // Vider les champs pour la prochaine saisie
                binding.titleEditText.text.clear()
                binding.contentEditText.text.clear()
            }
        }
    }

    private fun setupRecyclerView() {
        noteAdapter = NoteAdapter(emptyList()) // On commence avec une liste vide
        binding.notesRecyclerView.apply {
            adapter = noteAdapter
            layoutManager = LinearLayoutManager(this@MainActivity)
        }
    }
}
</div></section></section><section class="chapter"><h3 id="le-flux-de-donn-es-r-actif-la-magie" data-toc="le-flux-de-donn-es-r-actif-la-magie">Le Flux de Donn&eacute;es R&eacute;actif (La &quot;Magie&quot;)</h3><p id="z12zq7i_332">Quand vous cliquez sur le bouton &quot;Ajouter&quot; :</p><ol class="list _decimal" id="z12zq7i_333" type="1"><li class="list__item" id="z12zq7i_336"><p id="z12zq7i_346"><span class="control" id="z12zq7i_347"><code class="code" id="z12zq7i_349">MainActivity</code></span> appelle <code class="code" id="z12zq7i_348">noteViewModel.insert(newNote)</code>.</p></li><li class="list__item" id="z12zq7i_337"><p id="z12zq7i_350"><span class="control" id="z12zq7i_351"><code class="code" id="z12zq7i_353">NoteViewModel</code></span> lance une coroutine et appelle <code class="code" id="z12zq7i_352">repository.insert(newNote)</code>.</p></li><li class="list__item" id="z12zq7i_338"><p id="z12zq7i_354"><span class="control" id="z12zq7i_355"><code class="code" id="z12zq7i_357">NoteRepository</code></span> appelle <code class="code" id="z12zq7i_356">noteDao.insert(newNote)</code>.</p></li><li class="list__item" id="z12zq7i_339"><p id="z12zq7i_358"><span class="control" id="z12zq7i_359"><code class="code" id="z12zq7i_361">NoteDao</code></span> (gr&acirc;ce &agrave; Room) ins&egrave;re la nouvelle note dans la table <code class="code" id="z12zq7i_360">note_table</code> de la base de donn&eacute;es.</p></li><li class="list__item" id="z12zq7i_340"><p id="z12zq7i_362"><span class="control" id="z12zq7i_363">Room d&eacute;tecte</span> que la table a chang&eacute;.</p></li><li class="list__item" id="z12zq7i_341"><p id="z12zq7i_364"><span class="control" id="z12zq7i_365">Room met &agrave; jour automatiquement</span> le <code class="code" id="z12zq7i_366">LiveData&lt;List&lt;Note&gt;&gt;</code> retourn&eacute; par <code class="code" id="z12zq7i_367">getAllNotes()</code> avec la nouvelle liste.</p></li><li class="list__item" id="z12zq7i_342"><p id="z12zq7i_368">Le <code class="code" id="z12zq7i_369">LiveData</code> notifie tous ses observateurs actifs. Le seul observateur est dans notre <span class="control" id="z12zq7i_370"><code class="code" id="z12zq7i_371">MainActivity</code></span>.</p></li><li class="list__item" id="z12zq7i_343"><p id="z12zq7i_372">Le code &agrave; l'int&eacute;rieur de <code class="code" id="z12zq7i_373">noteViewModel.allNotes.observe(...)</code> est ex&eacute;cut&eacute; avec la nouvelle liste.</p></li><li class="list__item" id="z12zq7i_344"><p id="z12zq7i_374"><code class="code" id="z12zq7i_375">noteAdapter.submitList(it)</code> est appel&eacute;.</p></li><li class="list__item" id="z12zq7i_345"><p id="z12zq7i_376">L'adaptateur met &agrave; jour le <code class="code" id="z12zq7i_377">RecyclerView</code>, et la nouvelle note appara&icirc;t &agrave; l'&eacute;cran.</p></li></ol><p id="z12zq7i_334">Tout ce processus se fait de mani&egrave;re transparente et efficace, sans aucun appel manuel pour rafra&icirc;chir les donn&eacute;es. C'est le c&oelig;ur d'une architecture r&eacute;active.</p></section></div></div></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="z12zq7i_378"><span class="control" id="z12zq7i_387">1. Quel est le principal avantage de <code class="code" id="z12zq7i_388">LiveData</code> par rapport &agrave; un simple callback ? (QCM)</span></p><ul class="list _bullet" id="z12zq7i_379"><li class="list__item" id="z12zq7i_389"><p id="z12zq7i_393">A) Il ne fonctionne qu'avec des <code class="code" id="z12zq7i_394">String</code>.</p></li><li class="list__item" id="z12zq7i_390"><p id="z12zq7i_395">B) Il est &quot;lifecycle-aware&quot; (conscient du cycle de vie), ce qui &eacute;vite les crashs et les fuites de m&eacute;moire.</p></li><li class="list__item" id="z12zq7i_391"><p id="z12zq7i_396">C) Il est plus rapide pour les op&eacute;rations math&eacute;matiques.</p></li><li class="list__item" id="z12zq7i_392"><p id="z12zq7i_397">D) Il ne peut avoir qu'un seul observer.</p></li></ul><p id="z12zq7i_380"><span class="control" id="z12zq7i_398">2. Dans le pattern MVVM avec <code class="code" id="z12zq7i_399">LiveData</code>, quelle couche est responsable de la mise &agrave; jour de la valeur du <code class="code" id="z12zq7i_400">LiveData</code>? (QCM)</span></p><ul class="list _bullet" id="z12zq7i_381"><li class="list__item" id="z12zq7i_401"><p id="z12zq7i_405">A) La View (Fragment/Activity)</p></li><li class="list__item" id="z12zq7i_402"><p id="z12zq7i_406">B) Le Model (Repository)</p></li><li class="list__item" id="z12zq7i_403"><p id="z12zq7i_407">C) Le ViewModel</p></li><li class="list__item" id="z12zq7i_404"><p id="z12zq7i_408">D) Le Layout XML</p></li></ul><p id="z12zq7i_382"><span class="control" id="z12zq7i_409">3. Pour exposer un &eacute;tat modifiable uniquement par le ViewModel mais lisible par la View, quelle est la bonne pratique ? (QCM)</span></p><ul class="list _bullet" id="z12zq7i_383"><li class="list__item" id="z12zq7i_410"><p id="z12zq7i_414">A) Utiliser un <code class="code" id="z12zq7i_415">LiveData</code> public partout.</p></li><li class="list__item" id="z12zq7i_411"><p id="z12zq7i_416">B) Utiliser un <code class="code" id="z12zq7i_417">MutableLiveData</code> public partout.</p></li><li class="list__item" id="z12zq7i_412"><p id="z12zq7i_418">C) Utiliser un <code class="code" id="z12zq7i_419">StateFlow</code> public dans le ViewModel et un <code class="code" id="z12zq7i_420">MutableStateFlow</code> priv&eacute; dans la View.</p></li><li class="list__item" id="z12zq7i_413"><p id="z12zq7i_421">D) Utiliser un <code class="code" id="z12zq7i_422">MutableLiveData</code> priv&eacute; dans le ViewModel et l'exposer en tant que <code class="code" id="z12zq7i_423">LiveData</code> public.</p></li></ul><p id="z12zq7i_384"><span class="control" id="z12zq7i_424">4. Que signifie l'expression &quot;UI r&eacute;active&quot; ? (Question ouverte)</span></p><p id="z12zq7i_385"><span class="control" id="z12zq7i_425">5. Si vous utilisez <code class="code" id="z12zq7i_426">StateFlow</code>, pourquoi est-il important d'utiliser <code class="code" id="z12zq7i_427">repeatOnLifecycle</code> lors de la collecte dans un Fragment ? (Question ouverte)</span></p><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-de-l-auto-valuation" data-toc="correction-de-l-auto-valuation">Correction de l'auto-&eacute;valuation</h3></div><div class="collapse__content"><p id="z12zq7i_428"><span class="control" id="z12zq7i_439">1. Quel est le principal avantage de <code class="code" id="z12zq7i_440">LiveData</code>?</span></p><ul class="list _bullet" id="z12zq7i_429"><li class="list__item" id="z12zq7i_441"><p id="z12zq7i_443"><span class="control" id="z12zq7i_444">R&eacute;ponse : B) Il est &quot;lifecycle-aware&quot;, ce qui &eacute;vite les crashs et les fuites de m&eacute;moire.</span></p></li><li class="list__item" id="z12zq7i_442"><p id="z12zq7i_445"><span class="control" id="z12zq7i_446">Justification :</span> Cette conscience du cycle de vie est sa caract&eacute;ristique principale. Il suspend les mises &agrave; jour lorsque l'UI n'est pas visible et nettoie automatiquement les abonnements lorsque l'UI est d&eacute;truite.</p></li></ul><p id="z12zq7i_430"><span class="control" id="z12zq7i_447">2. Quelle couche met &agrave; jour la valeur du <code class="code" id="z12zq7i_448">LiveData</code>?</span></p><ul class="list _bullet" id="z12zq7i_431"><li class="list__item" id="z12zq7i_449"><p id="z12zq7i_451"><span class="control" id="z12zq7i_452">R&eacute;ponse : C) Le ViewModel.</span></p></li><li class="list__item" id="z12zq7i_450"><p id="z12zq7i_453"><span class="control" id="z12zq7i_454">Justification :</span> Le ViewModel est le propri&eacute;taire de l'&eacute;tat de l'UI. La View ne fait que l'observer. C'est le ViewModel qui d&eacute;cide quand et comment l'&eacute;tat doit changer, en se basant sur les actions de l'utilisateur ou les donn&eacute;es du Model.</p></li></ul><p id="z12zq7i_432"><span class="control" id="z12zq7i_455">3. Quelle est la bonne pratique pour exposer un &eacute;tat ?</span></p><ul class="list _bullet" id="z12zq7i_433"><li class="list__item" id="z12zq7i_456"><p id="z12zq7i_458"><span class="control" id="z12zq7i_459">R&eacute;ponse : D) Utiliser un <code class="code" id="z12zq7i_460">MutableLiveData</code> priv&eacute; dans le ViewModel et l'exposer en tant que <code class="code" id="z12zq7i_461">LiveData</code> public.</span></p></li><li class="list__item" id="z12zq7i_457"><p id="z12zq7i_462"><span class="control" id="z12zq7i_463">Justification :</span> C'est le principe d'encapsulation. On emp&ecirc;che la View (ou toute autre classe externe) de modifier directement l'&eacute;tat. La modification de l'&eacute;tat est une responsabilit&eacute; qui doit rester &agrave; l'int&eacute;rieur du ViewModel.</p></li></ul><p id="z12zq7i_434"><span class="control" id="z12zq7i_464">4. Que signifie &quot;UI r&eacute;active&quot; ?</span></p><ul class="list _bullet" id="z12zq7i_435"><li class="list__item" id="z12zq7i_465"><p id="z12zq7i_466"><span class="control" id="z12zq7i_467">R&eacute;ponse type :</span> Une UI r&eacute;active est une interface utilisateur qui se met &agrave; jour <span class="control" id="z12zq7i_468">automatiquement</span> en r&eacute;action &agrave; des changements d'&eacute;tat sous-jacents, sans qu'il y ait besoin d'appels imp&eacute;ratifs pour la rafra&icirc;chir. Au lieu de dire &agrave; l'UI &quot;maintenant, redessine-toi avec cette nouvelle donn&eacute;e&quot;, on d&eacute;clare une relation entre un &eacute;l&eacute;ment de l'UI et une source de donn&eacute;es. Quand la source de donn&eacute;es change, l'UI &quot;r&eacute;agit&quot; et se met &agrave; jour. C'est un mod&egrave;le de programmation d&eacute;claratif plut&ocirc;t qu'imp&eacute;ratif.</p></li></ul><p id="z12zq7i_436"><span class="control" id="z12zq7i_469">5. Pourquoi utiliser <code class="code" id="z12zq7i_470">repeatOnLifecycle</code> avec <code class="code" id="z12zq7i_471">StateFlow</code>?</span></p><ul class="list _bullet" id="z12zq7i_437"><li class="list__item" id="z12zq7i_472"><p id="z12zq7i_473"><span class="control" id="z12zq7i_474">R&eacute;ponse type :</span> <code class="code" id="z12zq7i_475">StateFlow</code> n'est pas nativement conscient du cycle de vie d'Android comme <code class="code" id="z12zq7i_476">LiveData</code>. Si on lan&ccedil;ait simplement la collecte dans <code class="code" id="z12zq7i_477">lifecycleScope.launch</code>, la coroutine continuerait de recevoir des mises &agrave; jour m&ecirc;me si l'application est en arri&egrave;re-plan (&eacute;tat <code class="code" id="z12zq7i_478">STOPPED</code>), ce qui est un gaspillage de ressources et peut mener &agrave; des bugs. <code class="code" id="z12zq7i_479">repeatOnLifecycle(Lifecycle.State.STARTED)</code> cr&eacute;e une coroutine qui ne s'ex&eacute;cute que lorsque le cycle de vie est au moins &agrave; l'&eacute;tat <code class="code" id="z12zq7i_480">STARTED</code>. Elle s'arr&ecirc;te automatiquement quand l'app passe en arri&egrave;re-plan et red&eacute;marre quand elle revient au premier plan, imitant ainsi le comportement s&ucirc;r de <code class="code" id="z12zq7i_481">LiveData</code>.</p></li></ul></div></div></section></section><section class="chapter"><h2 id="conclusion-de-la-partie" data-toc="conclusion-de-la-partie">Conclusion de la partie</h2><p id="z12zq7i_482">F&eacute;licitations ! Vous avez atteint le sommet de l'architecture d'application Android moderne. Vous savez non seulement comment structurer votre application en couches logiques avec MVVM, mais aussi comment les faire communiquer de mani&egrave;re efficace, s&ucirc;re et r&eacute;active.</p><p id="z12zq7i_483">Le d&eacute;couplage entre votre logique de pr&eacute;sentation (<code class="code" id="z12zq7i_485">ViewModel</code>) et votre affichage (<code class="code" id="z12zq7i_486">View</code>) est maintenant complet. Votre code est plus propre, plus robuste, plus testable, et beaucoup plus agr&eacute;able &agrave; maintenir. Vous avez les comp&eacute;tences pour construire des applications complexes qui sont &agrave; la fois puissantes et bien con&ccedil;&eacute;es.</p><p id="z12zq7i_484">Il ne nous reste plus qu'une derni&egrave;re &eacute;tape : un r&eacute;capitulatif de tout ce que nous avons appris, et quelques pistes pour continuer votre voyage dans l'univers passionnant du d&eacute;veloppement Android.</p></section><div class="last-modified">01 novembre 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="005-01-module-14.html" class="navigation-links__prev">Module 14 : Architecture d'Application : Le Pattern MVVM</a><a href="005-03-module-16.html" class="navigation-links__next">Module 16 : D&eacute;ploiement sur le Google Play Store</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>
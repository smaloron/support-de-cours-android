<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-11-02T18:21:44.710771"><title>Module 18 : Jetpack Compose - Le Futur de l'UI sur Android | Android</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"notions-abord-es","level":0,"title":"Notions abordées","anchor":"#notions-abord-es"},{"id":"paradigme-imp-ratif-vs-d-claratif","level":0,"title":"Paradigme Impératif vs. Déclaratif","anchor":"#paradigme-imp-ratif-vs-d-claratif"},{"id":"les-piliers-de-compose","level":0,"title":"Les Piliers de Compose","anchor":"#les-piliers-de-compose"},{"id":"les-composants-de-base-et-les-layouts","level":0,"title":"Les Composants de base et les Layouts","anchor":"#les-composants-de-base-et-les-layouts"},{"id":"int-gration-avec-l-architecture-mvvm","level":0,"title":"Intégration avec l\u0027Architecture MVVM","anchor":"#int-gration-avec-l-architecture-mvvm"},{"id":"tp-18-refactoriser-le-compteur-en-jetpack-compose","level":0,"title":"TP 18 : Refactoriser le compteur en Jetpack Compose","anchor":"#tp-18-refactoriser-le-compteur-en-jetpack-compose"},{"id":"correction-du-tp-18","level":0,"title":"Correction du TP 18","anchor":"#correction-du-tp-18"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 18 : Jetpack Compose - Le Futur de l'UI sur Android | Android"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Android Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/007-02-module-18.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 18 : Jetpack Compose - Le Futur de l'UI sur Android | Android"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/007-02-module-18.html#webpage",
    "url": "writerside-documentation/007-02-module-18.html",
    "name": "Module 18 : Jetpack Compose - Le Futur de l'UI sur Android | Android",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Android Help"
}</script><!-- End Schema.org --></head><body data-id="007-02-module-18" data-main-title="Module 18 : Jetpack Compose - Le Futur de l'UI sur Android" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="007-bonus.md|Pour aller plus loin : L'Horizon du Développeur Android"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Android  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="007-02-module-18" id="007-02-module-18.md">Module 18 : Jetpack Compose - Le Futur de l'UI sur Android</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="-p6m5wz_13">&Agrave; la fin de ce module, vous serez capable de :</p><ul class="list _bullet" id="-p6m5wz_14"><li class="list__item" id="-p6m5wz_15"><p id="-p6m5wz_20">Expliquer la diff&eacute;rence fondamentale entre une approche UI <span class="control" id="-p6m5wz_21">imp&eacute;rative</span> (XML/Vues) et <span class="control" id="-p6m5wz_22">d&eacute;clarative</span> (Compose).</p></li><li class="list__item" id="-p6m5wz_16"><p id="-p6m5wz_23">Comprendre les trois concepts cl&eacute;s de Compose : Les fonctions <code class="code" id="-p6m5wz_24">@Composable</code>, la gestion de l'&eacute;tat (<code class="code" id="-p6m5wz_25">State</code>), et la * <span class="emphasis" id="-p6m5wz_26">recomposition</span>*.</p></li><li class="list__item" id="-p6m5wz_17"><p id="-p6m5wz_27">Cr&eacute;er des composants UI simples en utilisant les Composables de base (<code class="code" id="-p6m5wz_28">Text</code>, <code class="code" id="-p6m5wz_29">Button</code>, <code class="code" id="-p6m5wz_30">Column</code>, <code class="code" id="-p6m5wz_31">Row</code>).</p></li><li class="list__item" id="-p6m5wz_18"><p id="-p6m5wz_32">G&eacute;rer l'&eacute;tat d'un composant pour le rendre interactif.</p></li><li class="list__item" id="-p6m5wz_19"><p id="-p6m5wz_33">Comprendre comment Jetpack Compose s'int&egrave;gre avec l'architecture MVVM que vous avez apprise.</p></li></ul></section><section class="chapter"><h2 id="introduction" data-toc="introduction">Introduction</h2><p id="-p6m5wz_34">Imaginez que vous demandez &agrave; un artiste de peindre un portrait. L'approche <span class="control" id="-p6m5wz_37">imp&eacute;rative</span> (celle que nous avons utilis&eacute;e avec XML) consiste &agrave; lui donner des instructions pas &agrave; pas : &quot; Prends un pinceau. Trempe-le dans la peinture rouge. Dessine un cercle &agrave; ces coordonn&eacute;es pr&eacute;cises. Maintenant, change de pinceau, prends du bleu, dessine les yeux... Ah, le mod&egrave;le a souri ! Maintenant, prends une gomme, efface la bouche, et redessine-la avec un sourire.&quot; Vous devez g&eacute;rer manuellement chaque changement.</p><p id="-p6m5wz_35">L'approche <span class="control" id="-p6m5wz_38">d&eacute;clarative</span> de <span class="control" id="-p6m5wz_39">Jetpack Compose</span>, c'est compl&egrave;tement diff&eacute;rent. Vous ne donnez plus d'ordres. Vous d&eacute;crivez le r&eacute;sultat final que vous souhaitez. Vous dites &agrave; l'artiste : &quot;Je veux un portrait d'une personne qui est actuellement en train de sourire.&quot; Si l'&eacute;tat de la personne change (elle cesse de sourire), vous ne lui dites pas comment effacer et redessiner. Vous lui dites simplement : &quot;Maintenant, je veux un portrait d'une personne qui a une expression neutre.&quot; L'artiste sait comment, de la mani&egrave;re la plus efficace possible, transformer l'ancien portrait en nouveau.</p><p id="-p6m5wz_36">Jetpack Compose est ce nouvel artiste intelligent. Vous d&eacute;crivez votre UI en fonction d'un &eacute;tat, et quand l'&eacute;tat change, Compose se charge de mettre &agrave; jour l'interface de la mani&egrave;re la plus optimale possible. C'est un changement de paradigme qui rend la construction d'UI plus simple, plus rapide et moins sujette aux erreurs.</p></section><section class="chapter"><h2 id="notions-abord-es" data-toc="notions-abord-es">Notions abord&eacute;es</h2><ul class="list _bullet" id="-p6m5wz_40"><li class="list__item" id="-p6m5wz_42"><p id="-p6m5wz_46">Paradgime Imp&eacute;ratif vs. D&eacute;claratif</p></li><li class="list__item" id="-p6m5wz_43"><p id="-p6m5wz_47">Les Piliers de Compose : <code class="code" id="-p6m5wz_48">@Composable</code>, <code class="code" id="-p6m5wz_49">State</code>, et Recomposition</p></li><li class="list__item" id="-p6m5wz_44"><p id="-p6m5wz_50">Les Composants de base et les Layouts</p></li><li class="list__item" id="-p6m5wz_45"><p id="-p6m5wz_51">Int&eacute;gration avec l'Architecture MVVM</p></li></ul></section><section class="chapter"><h2 id="paradigme-imp-ratif-vs-d-claratif" data-toc="paradigme-imp-ratif-vs-d-claratif">Paradigme Imp&eacute;ratif vs. D&eacute;claratif</h2><section class="chapter"><h3 id="introduction-la-notion" data-toc="introduction-la-notion">Introduction &agrave; la notion</h3><p id="-p6m5wz_54">C'est le concept le plus fondamental &agrave; saisir. C'est la diff&eacute;rence entre le &quot;Comment&quot; et le &quot;Quoi&quot;. Le syst&egrave;me de Vues XML est focalis&eacute; sur le &quot;Comment&quot;, Compose est focalis&eacute; sur le &quot;Quoi&quot;.</p></section><section class="chapter"><h3 id="explication-de-la-notion" data-toc="explication-de-la-notion">Explication de la notion</h3><p id="-p6m5wz_55"><span class="control" id="-p6m5wz_61">Approche Imp&eacute;rative (XML + Vues Android)</span></p><ul class="list _bullet" id="-p6m5wz_56"><li class="list__item" id="-p6m5wz_62"><p id="-p6m5wz_65"><span class="control" id="-p6m5wz_66">Principe :</span> Vous manipulez manuellement les widgets. Vous &ecirc;tes responsable de leur cr&eacute;ation, de leur recherche (<code class="code" id="-p6m5wz_67">findViewById</code>, View Binding) et de leur mise &agrave; jour.</p></li><li class="list__item" id="-p6m5wz_63"><p id="-p6m5wz_68"><span class="control" id="-p6m5wz_69">Exemple :</span> &quot;Trouve le <code class="code" id="-p6m5wz_70">TextView</code> avec l'ID <code class="code" id="-p6m5wz_71">welcomeText</code>. Appelle sa m&eacute;thode <code class="code" id="-p6m5wz_72">setText()</code> avec la nouvelle valeur.&quot;</p></li><li class="list__item" id="-p6m5wz_64"><p id="-p6m5wz_73"><span class="control" id="-p6m5wz_75">Flux de travail :</span></p><ol class="list _decimal" id="-p6m5wz_74" type="1"><li class="list__item" id="-p6m5wz_76"><p id="-p6m5wz_80">On d&eacute;finit un layout statique en XML.</p></li><li class="list__item" id="-p6m5wz_77"><p id="-p6m5wz_81">On &quot;gonfle&quot; ce layout en objets <code class="code" id="-p6m5wz_82">View</code>.</p></li><li class="list__item" id="-p6m5wz_78"><p id="-p6m5wz_83">On garde des r&eacute;f&eacute;rences &agrave; ces objets.</p></li><li class="list__item" id="-p6m5wz_79"><p id="-p6m5wz_84">Quand un &eacute;v&eacute;nement se produit, on appelle des m&eacute;thodes (<code class="code" id="-p6m5wz_85">setText</code>, <code class="code" id="-p6m5wz_86">setVisibility</code>, etc.) sur ces objets pour muter leur &eacute;tat interne.</p></li></ol></li></ul><p id="-p6m5wz_57"><span class="control" id="-p6m5wz_87">Approche D&eacute;clarative (Jetpack Compose)</span></p><ul class="list _bullet" id="-p6m5wz_58"><li class="list__item" id="-p6m5wz_88"><p id="-p6m5wz_91"><span class="control" id="-p6m5wz_92">Principe :</span> Vous d&eacute;crivez &agrave; quoi votre UI doit ressembler <span class="control" id="-p6m5wz_93">pour un &eacute;tat donn&eacute;</span>. Vous ne manipulez plus les widgets directement.</p></li><li class="list__item" id="-p6m5wz_89"><p id="-p6m5wz_94"><span class="control" id="-p6m5wz_95">Exemple :</span> &quot;Je d&eacute;clare qu'il doit y avoir un <code class="code" id="-p6m5wz_96">Text</code> dont le contenu est la valeur actuelle de la variable <code class="code" id="-p6m5wz_97">username</code> .&quot;</p></li><li class="list__item" id="-p6m5wz_90"><p id="-p6m5wz_98"><span class="control" id="-p6m5wz_100">Flux de travail :</span></p><ol class="list _decimal" id="-p6m5wz_99" type="1"><li class="list__item" id="-p6m5wz_101"><p id="-p6m5wz_104">On cr&eacute;e des fonctions qui d&eacute;crivent des morceaux d'UI.</p></li><li class="list__item" id="-p6m5wz_102"><p id="-p6m5wz_105">Ces fonctions prennent un <span class="control" id="-p6m5wz_106">&eacute;tat</span> en param&egrave;tre.</p></li><li class="list__item" id="-p6m5wz_103"><p id="-p6m5wz_107">Quand l'&eacute;tat change, le framework <span class="control" id="-p6m5wz_108">re-ex&eacute;cute</span> la fonction avec le nouvel &eacute;tat et met &agrave; jour l'UI pour qu'elle corresponde &agrave; la nouvelle description.</p></li></ol></li></ul><p id="-p6m5wz_59">C'est un passage d'un contr&ocirc;le manuel &agrave; une transformation de donn&eacute;es en UI.</p></section></section><section class="chapter"><h2 id="les-piliers-de-compose" data-toc="les-piliers-de-compose">Les Piliers de Compose</h2><section class="chapter"><h3 id="introduction-la-notion_1" data-toc="introduction-la-notion_1">Introduction &agrave; la notion</h3><p id="-p6m5wz_111">Pour que cette magie d&eacute;clarative op&egrave;re, Compose repose sur un trio ins&eacute;parable :</p><ol class="list _decimal" id="-p6m5wz_112" type="1"><li class="list__item" id="-p6m5wz_113"><p id="-p6m5wz_116"><span class="control" id="-p6m5wz_117">Les fonctions <code class="code" id="-p6m5wz_118">@Composable</code>:</span> Ce sont les briques de construction. Chaque fonction est un plan pour un morceau d'UI.</p></li><li class="list__item" id="-p6m5wz_114"><p id="-p6m5wz_119"><span class="control" id="-p6m5wz_120">L'&Eacute;tat (<code class="code" id="-p6m5wz_121">State</code>) :</span> C'est le carburant. C'est n'importe quelle valeur qui peut changer dans le temps et qui doit affecter l'UI.</p></li><li class="list__item" id="-p6m5wz_115"><p id="-p6m5wz_122"><span class="control" id="-p6m5wz_123">La Recomposition :</span> C'est le moteur. C'est le processus par lequel Compose redessine intelligemment les parties de l'UI qui ont &eacute;t&eacute; affect&eacute;es par un changement d'&eacute;tat.</p></li></ol></section><section class="chapter"><h3 id="explication-de-la-notion_1" data-toc="explication-de-la-notion_1">Explication de la notion</h3><p id="-p6m5wz_124"><span class="control" id="-p6m5wz_136">1. Fonctions <code class="code" id="-p6m5wz_138">@Composable</code></span> Toute fonction qui &eacute;met de l'UI dans Compose doit &ecirc;tre annot&eacute;e avec <code class="code" id="-p6m5wz_137">@Composable</code>.</p><ul class="list _bullet" id="-p6m5wz_125"><li class="list__item" id="-p6m5wz_139"><p id="-p6m5wz_142">Elles d&eacute;crivent une partie de l'UI. Elles ne retournent rien.</p></li><li class="list__item" id="-p6m5wz_140"><p id="-p6m5wz_143">Elles peuvent appeler d'autres fonctions <code class="code" id="-p6m5wz_144">@Composable</code> pour cr&eacute;er une hi&eacute;rarchie.</p></li><li class="list__item" id="-p6m5wz_141"><p id="-p6m5wz_145">Elles doivent &ecirc;tre rapides et sans &quot;effets de bord&quot; (ne pas modifier de variables globales, par exemple), car elles peuvent &ecirc;tre appel&eacute;es tr&egrave;s fr&eacute;quemment (&agrave; chaque frame pendant une animation).</p></li></ul><div class="code-block" data-lang="kotlin">
@Composable
fun Greeting(name: String) {
    Text(text = &quot;Hello, $name!&quot;)
}
</div><p id="-p6m5wz_127"><span class="control" id="-p6m5wz_146">2. L'&Eacute;tat (<code class="code" id="-p6m5wz_148">State</code>) et <code class="code" id="-p6m5wz_149">remember</code></span> Pour qu'un changement de valeur d&eacute;clenche une mise &agrave; jour de l'UI, cette valeur doit &ecirc;tre &quot;observ&eacute;e&quot; par Compose. On utilise pour cela <code class="code" id="-p6m5wz_147">mutableStateOf</code>.</p><ul class="list _bullet" id="-p6m5wz_128"><li class="list__item" id="-p6m5wz_150"><p id="-p6m5wz_152"><code class="code" id="-p6m5wz_153">mutableStateOf(valeurInitiale)</code> cr&eacute;e un objet <code class="code" id="-p6m5wz_154">State</code> observable.</p></li><li class="list__item" id="-p6m5wz_151"><p id="-p6m5wz_155">Pour lire sa valeur, on utilise <code class="code" id="-p6m5wz_156">.value</code>.</p></li></ul><p id="-p6m5wz_129">Mais si la fonction <code class="code" id="-p6m5wz_157">@Composable</code> est r&eacute;-ex&eacute;cut&eacute;e, comment l'&eacute;tat ne revient-il pas &agrave; sa valeur initiale ? C'est le r&ocirc;le de <code class="code" id="-p6m5wz_158">remember</code>.</p><ul class="list _bullet" id="-p6m5wz_130"><li class="list__item" id="-p6m5wz_159"><p id="-p6m5wz_160"><code class="code" id="-p6m5wz_161">remember { mutableStateOf(...) }</code> dit &agrave; Compose : &quot;Cr&eacute;e cet &eacute;tat la premi&egrave;re fois, mais lors des recompositions suivantes, <span class="control" id="-p6m5wz_162">souviens-toi</span> de sa derni&egrave;re valeur.&quot;</p></li></ul><div class="code-block" data-lang="kotlin">
@Composable
fun Counter() {
    // `count` est l'état. `remember` le préserve lors des recompositions.
    var count by remember { mutableStateOf(0) } // `by` est un délégué qui simplifie l'accès à .value

    Button(onClick = { count++ }) { // La modification de `count` va déclencher la recomposition
        Text(&quot;You clicked $count times&quot;)
    }
}
</div><p id="-p6m5wz_132"><span class="control" id="-p6m5wz_163">3. La Recomposition</span> C'est le processus de r&eacute;-appeler les fonctions <code class="code" id="-p6m5wz_164">@Composable</code> lorsque leur &eacute;tat d'entr&eacute;e a chang&eacute;.</p><ul class="list _bullet" id="-p6m5wz_133"><li class="list__item" id="-p6m5wz_165"><p id="-p6m5wz_167"><span class="control" id="-p6m5wz_168">Intelligente et cibl&eacute;e :</span> Compose est tr&egrave;s malin. Il ne r&eacute;-ex&eacute;cute que les Composables qui lisent l'&eacute;tat qui a chang&eacute;, et pas toute l'interface. C'est ce qui le rend performant.</p></li><li class="list__item" id="-p6m5wz_166"><p id="-p6m5wz_169"><span class="control" id="-p6m5wz_170">D&eacute;clench&eacute;e par les lectures d'&eacute;tat :</span> C'est lorsque vous lisez la valeur d'un <code class="code" id="-p6m5wz_171">State</code> (<code class="code" id="-p6m5wz_172">count</code> dans l'exemple) que Compose sait que ce Composable d&eacute;pend de cet &eacute;tat et devra &ecirc;tre recompos&eacute; s'il change.</p></li></ul><style>.theme-dark .plantuml > svg {filter: hue-rotate(180deg) invert(0.9);}div.plantuml {overflow-x: auto;}</style><div class="plantuml"><?xml version="1.0" encoding="us-ascii" standalone="no"?><svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" contentStyleType="text/css" height="445px" preserveAspectRatio="none" style="width:521px;height:445px;background:#FFFFFF;" version="1.1" viewBox="0 0 521 445" width="521px" zoomAndPan="magnify"><defs/><g><text fill="#000000" font-family="sans-serif" font-size="14" font-weight="bold" lengthAdjust="spacing" textLength="183" x="168" y="28.5352">Flux de la Recomposition</text><rect fill="#FFFFFF" height="189.1738" style="stroke:#181818;stroke-width:1.0;" width="10" x="170.5" y="150.2871"/><rect fill="#FFFFFF" height="29.3105" style="stroke:#181818;stroke-width:1.0;" width="10" x="450.5" y="179.5977"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="23" x2="23" y1="118.9766" y2="364.4609"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="175.5" x2="175.5" y1="118.9766" y2="364.4609"/><line style="stroke:#181818;stroke-width:0.5;stroke-dasharray:5.0,5.0;" x1="455" x2="455" y1="118.9766" y2="364.4609"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="31" x="5" y="116.0234">User</text><ellipse cx="23.5" cy="50.9883" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M23.5,58.9883 L23.5,85.9883 M10.5,66.9883 L36.5,66.9883 M23.5,85.9883 L10.5,100.9883 M23.5,85.9883 L36.5,100.9883 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="31" x="5" y="376.9961">User</text><ellipse cx="23.5" cy="388.4492" fill="#E2E2F0" rx="8" ry="8" style="stroke:#181818;stroke-width:0.5;"/><path d="M23.5,396.4492 L23.5,423.4492 M10.5,404.4492 L36.5,404.4492 M23.5,423.4492 L10.5,438.4492 M23.5,423.4492 L36.5,438.4492 " fill="none" style="stroke:#181818;stroke-width:0.5;"/><rect fill="#E2E2F0" height="30.4883" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="118" x="116.5" y="87.4883"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="104" x="123.5" y="108.0234">Composable UI</text><rect fill="#E2E2F0" height="30.4883" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="118" x="116.5" y="363.4609"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="104" x="123.5" y="383.9961">Composable UI</text><rect fill="#E2E2F0" height="30.4883" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="119" x="396" y="87.4883"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="105" x="403" y="108.0234">State (`count`)</text><rect fill="#E2E2F0" height="30.4883" rx="2.5" ry="2.5" style="stroke:#181818;stroke-width:0.5;" width="119" x="396" y="363.4609"/><text fill="#000000" font-family="sans-serif" font-size="14" lengthAdjust="spacing" textLength="105" x="403" y="383.9961">State (`count`)</text><rect fill="#FFFFFF" height="189.1738" style="stroke:#181818;stroke-width:1.0;" width="10" x="170.5" y="150.2871"/><rect fill="#FFFFFF" height="29.3105" style="stroke:#181818;stroke-width:1.0;" width="10" x="450.5" y="179.5977"/><polygon fill="#181818" points="158.5,146.2871,168.5,150.2871,158.5,154.2871,162.5,150.2871" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="23.5" x2="164.5" y1="150.2871" y2="150.2871"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="128" x="30.5" y="145.5449">Clique sur le bouton</text><polygon fill="#181818" points="438.5,175.5977,448.5,179.5977,438.5,183.5977,442.5,179.5977" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="180.5" x2="444.5" y1="179.5977" y2="179.5977"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="172" x="187.5" y="174.8555">Modifie la valeur (count++)</text><polygon fill="#181818" points="191.5,204.9082,181.5,208.9082,191.5,212.9082,187.5,208.9082" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="185.5" x2="454.5" y1="208.9082" y2="208.9082"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="207" x="197.5" y="204.166">Notifie Compose du changement</text><path d="M185,221.9082 L185,276.9082 L435,276.9082 L435,231.9082 L425,221.9082 L185,221.9082 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><path d="M425,221.9082 L425,231.9082 L435,231.9082 L425,221.9082 " fill="#FEFFDD" style="stroke:#181818;stroke-width:0.5;"/><text fill="#000000" font-family="sans-serif" font-size="13" font-weight="bold" lengthAdjust="spacing" textLength="99" x="191" y="239.4766">Recomposition</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="229" x="191" y="254.7871">Compose r&#233;-ex&#233;cute le Composable</text><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="97" x="191" y="270.0977">qui lit `count`.</text><polygon fill="#181818" points="443.5,300.1504,453.5,304.1504,443.5,308.1504,447.5,304.1504" style="stroke:#181818;stroke-width:1.0;"/><line style="stroke:#181818;stroke-width:1.0;" x1="180.5" x2="449.5" y1="304.1504" y2="304.1504"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="205" x="187.5" y="299.4082">Lit la nouvelle valeur de `count`</text><line style="stroke:#181818;stroke-width:1.0;" x1="180.5" x2="222.5" y1="338.4609" y2="338.4609"/><line style="stroke:#181818;stroke-width:1.0;" x1="222.5" x2="222.5" y1="338.4609" y2="351.4609"/><line style="stroke:#181818;stroke-width:1.0;" x1="175.5" x2="222.5" y1="351.4609" y2="351.4609"/><polygon fill="#181818" points="185.5,347.4609,175.5,351.4609,185.5,355.4609,181.5,351.4609" style="stroke:#181818;stroke-width:1.0;"/><text fill="#000000" font-family="sans-serif" font-size="13" lengthAdjust="spacing" textLength="256" x="187.5" y="333.7188">Redessine le Text avec la nouvelle valeur</text><!--SRC=[RP51Ri8m44NtFiM85GJH0x3e1gaIKji59JiM66U0aOmTx76KAt4EBiR4ITI2keeL__V__34JMuGFcrge4Ao63Hf_gNqa9k-KqePzW39YKBKEJ8PgxHWcgopI1u7BzGHqbC-pueSr8qptnYV7-rdMv7zATNQmU1S4bh2oT4q8CGKGiuDFBBaIIqt7YwkeHDlRBU7BLtIaF6gZBGerpGdp-UoNwdDwPCpvzfp1VdA4Ae4vQtV22pfM5Rx0odav1pgT6VonjoYAf-qKnSwDRk5-Ms1xlvaab1rJkltit3KHM68OLl6cNYfzoftKSJurQ8KTUibx3CIWppDiiC8OoUMKBROCka7p3_-tKhb-0000]--></g></svg></div></section></section><section class="chapter"><h2 id="les-composants-de-base-et-les-layouts" data-toc="les-composants-de-base-et-les-layouts">Les Composants de base et les Layouts</h2><section class="chapter"><h3 id="introduction-la-notion_2" data-toc="introduction-la-notion_2">Introduction &agrave; la notion</h3><p id="-p6m5wz_177">Compose fournit un ensemble de briques de construction (<code class="code" id="-p6m5wz_178">@Composable</code>) pr&ecirc;tes &agrave; l'emploi, tout comme le syst&egrave;me de Vues avait ses widgets. Et tout comme nous avions <code class="code" id="-p6m5wz_179">LinearLayout</code> et <code class="code" id="-p6m5wz_180">ConstraintLayout</code>, Compose a ses propres Composables pour agencer les &eacute;l&eacute;ments.</p></section><section class="chapter"><h3 id="explication-de-la-notion_2" data-toc="explication-de-la-notion_2">Explication de la notion</h3><p id="-p6m5wz_181"><span class="control" id="-p6m5wz_187">Composants de base :</span></p><ul class="list _bullet" id="-p6m5wz_182"><li class="list__item" id="-p6m5wz_188"><p id="-p6m5wz_192"><code class="code" id="-p6m5wz_193">Text(text = &quot;...&quot;)</code>: Affiche du texte.</p></li><li class="list__item" id="-p6m5wz_189"><p id="-p6m5wz_194"><code class="code" id="-p6m5wz_195">Button(onClick = { ... }) { Text(&quot;Click Me&quot;) }</code>: Un bouton. Notez que le contenu du bouton est lui-m&ecirc;me un Composable.</p></li><li class="list__item" id="-p6m5wz_190"><p id="-p6m5wz_196"><code class="code" id="-p6m5wz_197">TextField(value = ..., onValueChange = { ... })</code>: Un champ de saisie.</p></li><li class="list__item" id="-p6m5wz_191"><p id="-p6m5wz_198"><code class="code" id="-p6m5wz_199">Image(painter = ..., contentDescription = ...)</code>: Affiche une image.</p></li></ul><p id="-p6m5wz_183"><span class="control" id="-p6m5wz_200">Layouts (agencement) :</span></p><ul class="list _bullet" id="-p6m5wz_184"><li class="list__item" id="-p6m5wz_201"><p id="-p6m5wz_205"><code class="code" id="-p6m5wz_206">Column { ... }</code>: Aligne ses enfants verticalement (&eacute;quivalent de <code class="code" id="-p6m5wz_207">LinearLayout</code> vertical).</p></li><li class="list__item" id="-p6m5wz_202"><p id="-p6m5wz_208"><code class="code" id="-p6m5wz_209">Row { ... }</code>: Aligne ses enfants horizontalement (&eacute;quivalent de <code class="code" id="-p6m5wz_210">LinearLayout</code> horizontal).</p></li><li class="list__item" id="-p6m5wz_203"><p id="-p6m5wz_211"><code class="code" id="-p6m5wz_212">Box { ... }</code>: Empile ses enfants les uns sur les autres (&eacute;quivalent de <code class="code" id="-p6m5wz_213">FrameLayout</code>).</p></li><li class="list__item" id="-p6m5wz_204"><p id="-p6m5wz_214"><code class="code" id="-p6m5wz_215">ConstraintLayout { ... }</code>: Une version Compose du puissant <code class="code" id="-p6m5wz_216">ConstraintLayout</code>, pour des agencements complexes.</p></li></ul><p id="-p6m5wz_185">Les <span class="control" id="-p6m5wz_217"><code class="code" id="-p6m5wz_218">Modifiers</code></span> sont des outils extr&ecirc;mement puissants pour d&eacute;corer et configurer les Composables. Ils sont pass&eacute;s en param&egrave;tre.</p><div class="code-block" data-lang="kotlin">
@Composable
fun StyledText() {
    Text(
        text = &quot;Hello, Compose!&quot;,
        modifier = Modifier
            .padding(16.dp) // Marge extérieure
            .background(Color.Blue) // Fond
            .clickable { /* Fait quelque chose */ } // Rend le texte cliquable
    )
}
</div></section><section class="chapter"><h3 id="exercice-1-cr-er-une-carte-de-profil-simple" data-toc="exercice-1-cr-er-une-carte-de-profil-simple">Exercice 1 : Cr&eacute;er une carte de profil simple</h3><p id="-p6m5wz_219"><span class="control" id="-p6m5wz_220">&Eacute;nonc&eacute; :</span> Cr&eacute;ez un Composable <code class="code" id="-p6m5wz_221">@Composable fun ProfileCard()</code> qui affiche une carte de profil avec une image (utilisez une ic&ocirc;ne par d&eacute;faut), un nom et un statut. Le nom et le statut doivent &ecirc;tre align&eacute;s verticalement. Le tout doit &ecirc;tre align&eacute; horizontalement.</p></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-exercice-1" data-toc="correction-exercice-1"><span class="control" id="-p6m5wz_225">Correction exercice 1</span></h3></div><div class="collapse__content"><div class="code-block" data-lang="kotlin">
import androidx.compose.foundation.Image
import androidx.compose.foundation.layout.*
import androidx.compose.material.icons.Icons
import androidx.compose.material.icons.filled.Person
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.graphics.Color
import androidx.compose.ui.text.font.FontWeight
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp

@Composable
fun ProfileCard() {
    // Row pour aligner les éléments horizontalement
    Row(
        modifier = Modifier
            .padding(16.dp)
            .fillMaxWidth(), // Prend toute la largeur
        verticalAlignment = Alignment.CenterVertically // Centre les enfants verticalement
    ) {
        // Image de profil
        Image(
            painter = Icons.Default.Person, // Icône par défaut
            contentDescription = &quot;Avatar de profil&quot;,
            modifier = Modifier.size(64.dp)
        )

        // Espace entre l'image et le texte
        Spacer(modifier = Modifier.width(16.dp))

        // Column pour aligner le nom et le statut verticalement
        Column {
            Text(
                text = &quot;Alice Dubois&quot;,
                fontWeight = FontWeight.Bold,
                fontSize = 20.sp
            )
            Text(
                text = &quot;En ligne&quot;,
                color = Color.Gray
            )
        }
    }
}
</div></div></div></section></section><section class="chapter"><h2 id="int-gration-avec-l-architecture-mvvm" data-toc="int-gration-avec-l-architecture-mvvm">Int&eacute;gration avec l'Architecture MVVM</h2><section class="chapter"><h3 id="introduction-la-notion_3" data-toc="introduction-la-notion_3">Introduction &agrave; la notion</h3><p id="-p6m5wz_229">La bonne nouvelle, c'est que tout ce que vous avez appris sur MVVM s'applique <span class="control" id="-p6m5wz_230">parfaitement</span> &agrave; Jetpack Compose. En fait, c'est encore plus naturel. L'&eacute;tat qui d&eacute;clenche la recomposition de votre UI Compose viendra directement de votre <code class="code" id="-p6m5wz_231">ViewModel</code>.</p></section><section class="chapter"><h3 id="explication-de-la-notion_3" data-toc="explication-de-la-notion_3">Explication de la notion</h3><p id="-p6m5wz_232">Le flux de donn&eacute;es reste exactement le m&ecirc;me :</p><ol class="list _decimal" id="-p6m5wz_233" type="1"><li class="list__item" id="-p6m5wz_235"><p id="-p6m5wz_240">La <span class="control" id="-p6m5wz_241">View</span> (votre Composable) observe un &eacute;tat expos&eacute; par le <code class="code" id="-p6m5wz_242">ViewModel</code>.</p></li><li class="list__item" id="-p6m5wz_236"><p id="-p6m5wz_243">La <span class="control" id="-p6m5wz_244">View</span> notifie le <code class="code" id="-p6m5wz_245">ViewModel</code> des actions de l'utilisateur.</p></li><li class="list__item" id="-p6m5wz_237"><p id="-p6m5wz_246">Le <span class="control" id="-p6m5wz_247">ViewModel</span> traite l'action, demande des donn&eacute;es au <span class="control" id="-p6m5wz_248">Repository</span> si besoin.</p></li><li class="list__item" id="-p6m5wz_238"><p id="-p6m5wz_249">Le <span class="control" id="-p6m5wz_250">ViewModel</span> met &agrave; jour son &eacute;tat.</p></li><li class="list__item" id="-p6m5wz_239"><p id="-p6m5wz_251">Le changement d'&eacute;tat est automatiquement collect&eacute; par la View, ce qui d&eacute;clenche une <span class="control" id="-p6m5wz_252">recomposition</span>.</p></li></ol><p id="-p6m5wz_234">Le <code class="code" id="-p6m5wz_253">StateFlow</code> est particuli&egrave;rement bien adapt&eacute; pour &ecirc;tre utilis&eacute; comme source de v&eacute;rit&eacute; dans le <code class="code" id="-p6m5wz_254">ViewModel</code>. On le collecte dans la couche UI avec une fonction utilitaire <code class="code" id="-p6m5wz_255">collectAsStateWithLifecycle()</code>.</p></section><section class="chapter"><h3 id="exemple-un-cran-de-profil-r-actif-avec-viewmodel" data-toc="exemple-un-cran-de-profil-r-actif-avec-viewmodel">Exemple : Un &eacute;cran de profil r&eacute;actif avec ViewModel</h3><p id="-p6m5wz_256"><span class="control" id="-p6m5wz_262">1. Le <code class="code" id="-p6m5wz_263">ProfileViewModel.kt</code></span></p><div class="code-block" data-lang="kotlin">
data class ProfileUiState(
    val name: String = &quot;Chargement...&quot;,
    val status: String = &quot;&quot;
)

@HiltViewModel
class ProfileViewModel @Inject constructor(
    private val userRepository: UserRepository
) : ViewModel() {

    private val _uiState = MutableStateFlow(ProfileUiState())
    val uiState: StateFlow&lt;ProfileUiState&gt; = _uiState.asStateFlow()

    fun loadProfile() {
        viewModelScope.launch {
            val user = userRepository.getProfile() // Fonction suspend
            _uiState.value = ProfileUiState(name = user.name, status = &quot;En ligne&quot;)
        }
    }
}
</div><p id="-p6m5wz_258"><span class="control" id="-p6m5wz_264">2. Le Composable <code class="code" id="-p6m5wz_265">ProfileScreen.kt</code> (la View)</span></p><div class="code-block" data-lang="kotlin">
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.hilt.navigation.compose.hiltViewModel
import androidx.lifecycle.compose.collectAsStateWithLifecycle

@Composable
fun ProfileScreen(
    viewModel: ProfileViewModel = hiltViewModel() // Injection du ViewModel
) {
    // `uiState` est un objet State. À chaque changement de uiState dans le ViewModel,
    // ce composable sera recomposé avec la nouvelle valeur.
    val uiState by viewModel.uiState.collectAsStateWithLifecycle()

    // On passe l'état en paramètre au composable qui fait l'affichage
    ProfileCard(name = uiState.name, status = uiState.status)
}

@Composable
fun ProfileCard(name: String, status: String) {
    // ... layout comme dans l'exercice, mais avec les paramètres `name` et `status`
}
</div><p id="-p6m5wz_260">Ce d&eacute;couplage est parfait. Le <code class="code" id="-p6m5wz_266">ProfileCard</code> est un composant &quot;stupide&quot; qui ne fait qu'afficher ce qu'on lui donne. Le <code class="code" id="-p6m5wz_267">ProfileScreen</code> connecte l'&eacute;tat du <code class="code" id="-p6m5wz_268">ViewModel</code> &agrave; l'UI. La logique reste dans le <code class="code" id="-p6m5wz_269">ViewModel</code>.</p></section></section><section class="chapter"><h2 id="tp-18-refactoriser-le-compteur-en-jetpack-compose" data-toc="tp-18-refactoriser-le-compteur-en-jetpack-compose">TP 18 : Refactoriser le compteur en Jetpack Compose</h2><p id="-p6m5wz_270"><span class="control" id="-p6m5wz_272">Objectif :</span> Recr&eacute;er notre application de compteur en utilisant Jetpack Compose et une architecture MVVM avec un <code class="code" id="-p6m5wz_273">ViewModel</code>.</p><section class="procedure-steps" id="-p6m5wz_271"><ol class="list _decimal" id="-p6m5wz_274" type="1"><li class="list__item" id="-p6m5wz_275"><p id="-p6m5wz_281"><span class="control" id="-p6m5wz_282">Cr&eacute;ez un nouveau projet</span> en choisissant le template <span class="control" id="-p6m5wz_283">&quot;Empty Activity&quot; (avec un logo Compose)</span>. Cela configure tout pour Compose.</p></li><li class="list__item" id="-p6m5wz_276"><p id="-p6m5wz_284"><span class="control" id="-p6m5wz_286">Cr&eacute;ez un <code class="code" id="-p6m5wz_287">CounterViewModel</code>:</span></p><ul class="list _bullet" id="-p6m5wz_285"><li class="list__item" id="-p6m5wz_288"><p id="-p6m5wz_291">Il doit contenir un <code class="code" id="-p6m5wz_292">StateFlow</code> pour le compteur : <code class="code" id="-p6m5wz_293">private val _count = MutableStateFlow(0)</code>.</p></li><li class="list__item" id="-p6m5wz_289"><p id="-p6m5wz_294">Exposez-le en lecture seule : <code class="code" id="-p6m5wz_295">val count: StateFlow&lt;Int&gt; = _count.asStateFlow()</code>.</p></li><li class="list__item" id="-p6m5wz_290"><p id="-p6m5wz_296">Cr&eacute;ez une fonction <code class="code" id="-p6m5wz_297">increment()</code> qui met &agrave; jour la valeur de <code class="code" id="-p6m5wz_298">_count</code>.</p></li></ul></li><li class="list__item" id="-p6m5wz_277"><p id="-p6m5wz_299"><span class="control" id="-p6m5wz_301">Dans <code class="code" id="-p6m5wz_302">MainActivity.kt</code>, supprimez le code par d&eacute;faut et cr&eacute;ez votre UI :</span></p><ul class="list _bullet" id="-p6m5wz_300"><li class="list__item" id="-p6m5wz_303"><p id="-p6m5wz_307">Instanciez le ViewModel : <code class="code" id="-p6m5wz_308">val viewModel: CounterViewModel = viewModel()</code>.</p></li><li class="list__item" id="-p6m5wz_304"><p id="-p6m5wz_309">Cr&eacute;ez un Composable <code class="code" id="-p6m5wz_310">@Composable fun CounterScreen(viewModel: CounterViewModel)</code>.</p></li><li class="list__item" id="-p6m5wz_305"><p id="-p6m5wz_311">Dans <code class="code" id="-p6m5wz_312">CounterScreen</code>, collectez l'&eacute;tat : <code class="code" id="-p6m5wz_313">val count by viewModel.count.collectAsStateWithLifecycle()</code>.</p></li><li class="list__item" id="-p6m5wz_306"><p id="-p6m5wz_314">Appelez un autre Composable, <code class="code" id="-p6m5wz_315">CounterContent(count = count, onIncrement = { viewModel.increment() })</code>.</p></li></ul></li><li class="list__item" id="-p6m5wz_278"><p id="-p6m5wz_316"><span class="control" id="-p6m5wz_318">Cr&eacute;ez le Composable <code class="code" id="-p6m5wz_319">CounterContent</code>:</span></p><ul class="list _bullet" id="-p6m5wz_317"><li class="list__item" id="-p6m5wz_320"><p id="-p6m5wz_324">Il prend en param&egrave;tre <code class="code" id="-p6m5wz_325">count: Int</code> et <code class="code" id="-p6m5wz_326">onIncrement: () -&gt; Unit</code>.</p></li><li class="list__item" id="-p6m5wz_321"><p id="-p6m5wz_327">Utilisez un <code class="code" id="-p6m5wz_328">Column</code> pour centrer un <code class="code" id="-p6m5wz_329">Text</code> et un <code class="code" id="-p6m5wz_330">Button</code>.</p></li><li class="list__item" id="-p6m5wz_322"><p id="-p6m5wz_331">Le <code class="code" id="-p6m5wz_332">Text</code> affiche la valeur de <code class="code" id="-p6m5wz_333">count</code>.</p></li><li class="list__item" id="-p6m5wz_323"><p id="-p6m5wz_334">Le <code class="code" id="-p6m5wz_335">onClick</code> du <code class="code" id="-p6m5wz_336">Button</code> appelle la lambda <code class="code" id="-p6m5wz_337">onIncrement</code>.</p></li></ul></li><li class="list__item" id="-p6m5wz_279"><p id="-p6m5wz_338"><span class="control" id="-p6m5wz_340">Assemblez le tout dans <code class="code" id="-p6m5wz_341">setContent</code> dans votre <code class="code" id="-p6m5wz_342">MainActivity</code>:</span></p><div class="code-block" data-lang="kotlin">
class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            MyAppTheme {
                CounterScreen(viewModel = viewModel())
            }
        }
    }
}
</div></li><li class="list__item" id="-p6m5wz_280"><p id="-p6m5wz_343"><span class="control" id="-p6m5wz_344">Testez :</span> L'application doit afficher le compteur, l'incr&eacute;menter au clic, et <span class="control" id="-p6m5wz_345">conserver son &eacute;tat lors de la rotation de l'&eacute;cran</span> car l'&eacute;tat est dans le <code class="code" id="-p6m5wz_346">ViewModel</code>!</p></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="correction-du-tp-18" data-toc="correction-du-tp-18">Correction du TP 18</h2></div><div class="collapse__content"><p id="-p6m5wz_347">Absolument ! Voici la correction compl&egrave;te et tr&egrave;s d&eacute;taill&eacute;e de ce TP. C'est l'exemple &quot;Hello World&quot; de l'architecture moderne sur Android avec Jetpack Compose, et il illustre parfaitement les concepts de gestion d'&eacute;tat.</p><section class="chapter"><h3 id="tape-1-cr-ation-et-configuration-du-projet" data-toc="tape-1-cr-ation-et-configuration-du-projet">&Eacute;tape 1 : Cr&eacute;ation et Configuration du Projet</h3><ol class="list _decimal" id="-p6m5wz_354" type="1"><li class="list__item" id="-p6m5wz_357"><p id="-p6m5wz_361">Ouvrez Android Studio.</p></li><li class="list__item" id="-p6m5wz_358"><p id="-p6m5wz_362">Cliquez sur &quot;New Project&quot;.</p></li><li class="list__item" id="-p6m5wz_359"><p id="-p6m5wz_363">Dans la section &quot;Phone and Tablet&quot;, s&eacute;lectionnez le template <span class="control" id="-p6m5wz_364">&quot;Empty Activity&quot;</span> (celui avec le petit logo bleu de Jetpack Compose).</p></li><li class="list__item" id="-p6m5wz_360"><p id="-p6m5wz_365">Nommez votre projet (par exemple, <code class="code" id="-p6m5wz_366">ComposeCounterApp</code>) et cliquez sur &quot;Finish&quot;.</p></li></ol><p id="-p6m5wz_355">Android Studio va cr&eacute;er un projet avec toutes les d&eacute;pendances n&eacute;cessaires pour Compose. Vous aurez d&eacute;j&agrave; un <code class="code" id="-p6m5wz_367">MainActivity.kt</code> avec du code d'exemple.</p><section class="chapter"><h4 id="d-pendances-suppl-mentaires" data-toc="d-pendances-suppl-mentaires">D&eacute;pendances suppl&eacute;mentaires</h4><p id="-p6m5wz_368">Pour utiliser <code class="code" id="-p6m5wz_371">viewModel()</code> et <code class="code" id="-p6m5wz_372">collectAsStateWithLifecycle()</code>, assurez-vous que ces d&eacute;pendances sont bien dans votre fichier <code class="code" id="-p6m5wz_373">build.gradle.kts</code> (module). Normalement, le template les inclut, mais c'est bien de v&eacute;rifier.</p><div class="code-block" data-lang="kotlin">
dependencies {
    // ... autres dépendances
    
    // ViewModel
    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-compose:2.7.0&quot;)
    // Pour lier le cycle de vie à la collecte des StateFlows
    implementation(&quot;androidx.lifecycle:lifecycle-runtime-compose:2.7.0&quot;)
}
</div></section></section><section class="chapter"><h3 id="tape-2-cr-er-le-counterviewmodel" data-toc="tape-2-cr-er-le-counterviewmodel">&Eacute;tape 2 : Cr&eacute;er le <code class="code" id="-p6m5wz_378">CounterViewModel</code></h3><p id="-p6m5wz_375">Cr&eacute;ez un nouveau fichier Kotlin nomm&eacute; <code class="code" id="-p6m5wz_379">CounterViewModel.kt</code>.</p><div class="code-block" data-lang="kotlin">
package com.example.composecounterapp // Adaptez votre package

import androidx.lifecycle.ViewModel
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import kotlinx.coroutines.flow.update

/**
 * Le ViewModel détient et gère l'état de l'UI (le compteur).
 * Il survit aux changements de configuration, comme la rotation de l'écran.
 */
class CounterViewModel : ViewModel() {

    // 1. _count est le StateFlow privé et mutable. C'est la source de vérité.
    //    Il ne doit être modifié qu'à l'intérieur du ViewModel.
    private val _count = MutableStateFlow(0)

    // 2. count est la version publique et en lecture seule (StateFlow) de _count.
    //    L'UI va s'abonner à ce Flow pour recevoir les mises à jour.
    val count: StateFlow&lt;Int&gt; = _count.asStateFlow()

    /**
     * La seule fonction qui modifie l'état.
     * C'est une action que l'UI peut déclencher.
     */
    fun increment() {
        // La méthode .update() est une manière sûre (thread-safe)
        // de mettre à jour la valeur d'un MutableStateFlow.
        _count.update { currentValue -&gt;
            currentValue + 1
        }
    }
}
</div></section><section class="chapter"><h3 id="tape-3-4-et-5-cr-er-l-ui-dans-mainactivity-kt" data-toc="tape-3-4-et-5-cr-er-l-ui-dans-mainactivity-kt">&Eacute;tape 3, 4 et 5 : Cr&eacute;er l'UI dans <code class="code" id="-p6m5wz_384">MainActivity.kt</code></h3><p id="-p6m5wz_381">Ouvrez <code class="code" id="-p6m5wz_385">MainActivity.kt</code> et remplacez tout son contenu par ce qui suit. Nous allons cr&eacute;er trois fonctions composables pour bien s&eacute;parer les responsabilit&eacute;s.</p><div class="code-block" data-lang="kotlin">
package com.example.composecounterapp

import android.os.Bundle
import androidx.activity.ComponentActivity
import androidx.activity.compose.setContent
import androidx.compose.foundation.layout.Arrangement
import androidx.compose.foundation.layout.Column
import androidx.compose.foundation.layout.Spacer
import androidx.compose.foundation.layout.fillMaxSize
import androidx.compose.foundation.layout.height
import androidx.compose.material3.Button
import androidx.compose.material3.MaterialTheme
import androidx.compose.material3.Surface
import androidx.compose.material3.Text
import androidx.compose.runtime.Composable
import androidx.compose.runtime.getValue
import androidx.compose.ui.Alignment
import androidx.compose.ui.Modifier
import androidx.compose.ui.text.TextStyle
import androidx.compose.ui.tooling.preview.Preview
import androidx.compose.ui.unit.dp
import androidx.compose.ui.unit.sp
import androidx.lifecycle.compose.collectAsStateWithLifecycle
import androidx.lifecycle.viewmodel.compose.viewModel
import com.example.composecounterapp.ui.theme.ComposeCounterAppTheme

class MainActivity : ComponentActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        setContent {
            // Le thème de l'application (généré par le template)
            ComposeCounterAppTheme {
                // Surface est un conteneur de base de Material Design
                Surface(
                    modifier = Modifier.fillMaxSize(),
                    color = MaterialTheme.colorScheme.background
                ) {
                    // On appelle notre écran principal
                    CounterScreen()
                }
            }
        }
    }
}

/**
 * Composable &quot;intelligent&quot; (stateful).
 * Il connaît le ViewModel et est responsable de la gestion de l'état.
 */
@Composable
fun CounterScreen(
    // viewModel() est la fonction magique qui fournit une instance
    // du ViewModel liée au cycle de vie approprié (Activity, Fragment...).
    viewModel: CounterViewModel = viewModel()
) {
    // On collecte la valeur du StateFlow.
    // `collectAsStateWithLifecycle` est la manière recommandée de le faire.
    // `by` est un délégué qui déballe la valeur de `State&lt;Int&gt;` en `Int`.
    // À chaque fois que le StateFlow émet une nouvelle valeur, ce Composable sera recomposé.
    val count by viewModel.count.collectAsStateWithLifecycle()

    // On passe l'état et les événements au composable &quot;bête&quot; (stateless).
    CounterContent(
        count = count,
        onIncrement = { viewModel.increment() }
    )
}

/**
 * Composable &quot;bête&quot; (stateless).
 * Il ne fait qu'afficher des données et remonter des événements.
 * Il est facile à prévisualiser et à réutiliser car il n'a pas de logique d'état.
 */
@Composable
fun CounterContent(
    count: Int,
    onIncrement: () -&gt; Unit,
    modifier: Modifier = Modifier // Toujours passer un Modifier
) {
    Column(
        modifier = modifier.fillMaxSize(),
        verticalArrangement = Arrangement.Center,
        horizontalAlignment = Alignment.CenterHorizontally
    ) {
        Text(
            text = &quot;Le compteur est à :&quot;,
            style = MaterialTheme.typography.headlineSmall
        )
        Spacer(modifier = Modifier.height(16.dp))
        Text(
            text = &quot;$count&quot;,
            style = TextStyle(fontSize = 48.sp)
        )
        Spacer(modifier = Modifier.height(32.dp))
        Button(onClick = onIncrement) {
            Text(text = &quot;Incrémenter&quot;)
        }
    }
}

/**
 * Le Preview permet de voir à quoi ressemble notre UI directement dans Android Studio
 * sans avoir à lancer l'application.
 */
@Preview(showBackground = true)
@Composable
fun CounterContentPreview() {
    ComposeCounterAppTheme {
        // On peut tester CounterContent avec n'importe quelle valeur.
        CounterContent(count = 5, onIncrement = {})
    }
}
</div></section><section class="chapter"><h3 id="tape-6-test" data-toc="tape-6-test">&Eacute;tape 6 : Test</h3><ol class="list _decimal" id="-p6m5wz_386" type="1"><li class="list__item" id="-p6m5wz_387"><p id="-p6m5wz_392"><span class="control" id="-p6m5wz_393">Lancez l'application</span> sur un &eacute;mulateur ou un appareil physique.</p></li><li class="list__item" id="-p6m5wz_388"><p id="-p6m5wz_394">Vous devriez voir &quot;Le compteur est &agrave; : 0&quot;.</p></li><li class="list__item" id="-p6m5wz_389"><p id="-p6m5wz_395"><span class="control" id="-p6m5wz_396">Cliquez sur le bouton &quot;Incr&eacute;menter&quot;</span>. Le compteur passe &agrave; 1, 2, 3...</p></li><li class="list__item" id="-p6m5wz_390"><p id="-p6m5wz_397"><span class="control" id="-p6m5wz_398">Activez la rotation automatique</span> sur votre appareil/&eacute;mulateur et faites pivoter l'&eacute;cran.</p></li><li class="list__item" id="-p6m5wz_391"><p id="-p6m5wz_399"><span class="control" id="-p6m5wz_400">R&eacute;sultat :</span> L'&eacute;cran se redessine en mode paysage, mais le compteur <span class="control" id="-p6m5wz_401">conserve sa valeur</span> (par exemple, 3). Si vous n'aviez pas utilis&eacute; de <code class="code" id="-p6m5wz_402">ViewModel</code>, le compteur serait revenu &agrave; 0.</p></li></ol></section><section class="chapter"><h3 id="explications-des-concepts-cl-s" data-toc="explications-des-concepts-cl-s">Explications des Concepts Cl&eacute;s</h3><ul class="list _bullet" id="-p6m5wz_403"><li class="list__item" id="-p6m5wz_405"><p id="-p6m5wz_409"><span class="control" id="-p6m5wz_410"><code class="code" id="-p6m5wz_415">viewModel()</code></span>: C'est un composable fourni par la biblioth&egrave;que <code class="code" id="-p6m5wz_411">lifecycle-viewmodel-compose</code>. Il trouve ou cr&eacute;e une instance de votre <code class="code" id="-p6m5wz_412">ViewModel</code> et la lie intelligemment au cycle de vie du propri&eacute;taire actuel (ici, l' <code class="code" id="-p6m5wz_413">Activity</code>). C'est lui qui garantit que la m&ecirc;me instance de <code class="code" id="-p6m5wz_414">ViewModel</code> survit &agrave; la rotation.</p></li><li class="list__item" id="-p6m5wz_406"><p id="-p6m5wz_416"><span class="control" id="-p6m5wz_418"><code class="code" id="-p6m5wz_420">collectAsStateWithLifecycle()</code></span>: C'est LA mani&egrave;re recommand&eacute;e de collecter un <code class="code" id="-p6m5wz_419">Flow</code> dans Compose.</p><ul class="list _bullet" id="-p6m5wz_417"><li class="list__item" id="-p6m5wz_421"><p id="-p6m5wz_423">Il convertit le <code class="code" id="-p6m5wz_424">StateFlow&lt;Int&gt;</code> en un <code class="code" id="-p6m5wz_425">State&lt;Int&gt;</code> que Compose sait observer.</p></li><li class="list__item" id="-p6m5wz_422"><p id="-p6m5wz_426">Il est conscient du cycle de vie : il ne collecte les valeurs que lorsque l'UI est visible &agrave; l'&eacute;cran (<code class="code" id="-p6m5wz_427">ON_START</code>) et arr&ecirc;te la collecte quand elle ne l'est plus (<code class="code" id="-p6m5wz_428">ON_STOP</code>), ce qui &eacute;conomise des ressources.</p></li></ul></li><li class="list__item" id="-p6m5wz_407"><p id="-p6m5wz_429"><span class="control" id="-p6m5wz_431">Flux de Donn&eacute;es Unidirectionnel (Unidirectional Data Flow - UDF) :</span> C'est le patron d'architecture que nous avons mis en place.</p><ul class="list _bullet" id="-p6m5wz_430"><li class="list__item" id="-p6m5wz_432"><p id="-p6m5wz_434"><span class="control" id="-p6m5wz_435">L'&eacute;tat descend :</span> Le <code class="code" id="-p6m5wz_436">ViewModel</code> envoie l'&eacute;tat (<code class="code" id="-p6m5wz_437">count</code>) vers le bas, jusqu'au <code class="code" id="-p6m5wz_438">Text</code> qui l'affiche.</p></li><li class="list__item" id="-p6m5wz_433"><p id="-p6m5wz_439"><span class="control" id="-p6m5wz_440">Les &eacute;v&eacute;nements remontent :</span> L'utilisateur clique sur le <code class="code" id="-p6m5wz_441">Button</code>, ce qui d&eacute;clenche un &eacute;v&eacute;nement (<code class="code" id="-p6m5wz_442">onIncrement</code>) qui remonte jusqu'au <code class="code" id="-p6m5wz_443">ViewModel</code> pour qu'il mette &agrave; jour l'&eacute;tat.</p></li></ul></li><li class="list__item" id="-p6m5wz_408"><p id="-p6m5wz_444"><span class="control" id="-p6m5wz_446">Composable Stateful vs Stateless :</span></p><ul class="list _bullet" id="-p6m5wz_445"><li class="list__item" id="-p6m5wz_447"><p id="-p6m5wz_449"><span class="control" id="-p6m5wz_450"><code class="code" id="-p6m5wz_452">CounterScreen</code> est <span class="emphasis" id="-p6m5wz_453">stateful</span></span>: Il est conscient de l'&eacute;tat (il se connecte au <code class="code" id="-p6m5wz_451">ViewModel</code>).</p></li><li class="list__item" id="-p6m5wz_448"><p id="-p6m5wz_454"><span class="control" id="-p6m5wz_455"><code class="code" id="-p6m5wz_457">CounterContent</code> est <span class="emphasis" id="-p6m5wz_458">stateless</span></span>: Il est &quot;b&ecirc;te&quot;. Il re&ccedil;oit simplement des donn&eacute;es et remonte des clics. Il est donc tr&egrave;s facile &agrave; tester, &agrave; pr&eacute;visualiser (<code class="code" id="-p6m5wz_456">@Preview</code>) et &agrave; r&eacute;utiliser ailleurs dans l'application. C'est une excellente pratique de s&eacute;parer les deux.</p></li></ul></li></ul></section></div></div></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="-p6m5wz_459"><span class="control" id="-p6m5wz_469">1. Quelle est la diff&eacute;rence fondamentale entre une approche UI imp&eacute;rative et d&eacute;clarative ? (QCM)</span></p><ul class="list _bullet" id="-p6m5wz_460"><li class="list__item" id="-p6m5wz_470"><p id="-p6m5wz_474">A) Imp&eacute;rative utilise XML, d&eacute;clarative utilise Kotlin.</p></li><li class="list__item" id="-p6m5wz_471"><p id="-p6m5wz_475">B) Imp&eacute;rative se concentre sur le &quot;comment&quot; modifier l'UI, d&eacute;clarative sur le &quot;quoi&quot; afficher pour un &eacute;tat donn&eacute;.</p></li><li class="list__item" id="-p6m5wz_472"><p id="-p6m5wz_476">C) D&eacute;clarative est plus rapide &agrave; compiler.</p></li><li class="list__item" id="-p6m5wz_473"><p id="-p6m5wz_477">D) Imp&eacute;rative ne peut pas g&eacute;rer d'&eacute;tat.</p></li></ul><p id="-p6m5wz_461"><span class="control" id="-p6m5wz_478">2. Quel est le r&ocirc;le de la fonction <code class="code" id="-p6m5wz_479">remember</code> dans Jetpack Compose ? (QCM)</span></p><ul class="list _bullet" id="-p6m5wz_462"><li class="list__item" id="-p6m5wz_480"><p id="-p6m5wz_484">A) Mettre en cache des images pour am&eacute;liorer les performances.</p></li><li class="list__item" id="-p6m5wz_481"><p id="-p6m5wz_485">B) Se souvenir de la derni&egrave;re action de l'utilisateur.</p></li><li class="list__item" id="-p6m5wz_482"><p id="-p6m5wz_486">C) Pr&eacute;server la valeur d'un &eacute;tat &agrave; travers les recompositions d'un Composable.</p></li><li class="list__item" id="-p6m5wz_483"><p id="-p6m5wz_487">D) S'abonner aux changements d'un <code class="code" id="-p6m5wz_488">LiveData</code>.</p></li></ul><p id="-p6m5wz_463"><span class="control" id="-p6m5wz_489">3. Lequel de ces Composables utiliseriez-vous pour aligner trois boutons l'un &agrave; c&ocirc;t&eacute; de l'autre horizontalement ? ( QCM)</span></p><ul class="list _bullet" id="-p6m5wz_464"><li class="list__item" id="-p6m5wz_490"><p id="-p6m5wz_494">A) <code class="code" id="-p6m5wz_495">Column</code></p></li><li class="list__item" id="-p6m5wz_491"><p id="-p6m5wz_496">B) <code class="code" id="-p6m5wz_497">Box</code></p></li><li class="list__item" id="-p6m5wz_492"><p id="-p6m5wz_498">C) <code class="code" id="-p6m5wz_499">ConstraintLayout</code></p></li><li class="list__item" id="-p6m5wz_493"><p id="-p6m5wz_500">D) <code class="code" id="-p6m5wz_501">Row</code></p></li></ul><p id="-p6m5wz_465"><span class="control" id="-p6m5wz_502">4. Expliquez le concept de &quot;recomposition&quot; et pourquoi il est important qu'elle soit cibl&eacute;e. (Question ouverte)</span></p><p id="-p6m5wz_466"><span class="control" id="-p6m5wz_503">5. Comment le <code class="code" id="-p6m5wz_504">StateFlow</code> du ViewModel et <code class="code" id="-p6m5wz_505">collectAsStateWithLifecycle</code> dans le Composable travaillent-ils ensemble pour cr&eacute;er une UI r&eacute;active ? (Question ouverte)</span></p><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-de-l-auto-valuation" data-toc="correction-de-l-auto-valuation">Correction de l'auto-&eacute;valuation</h3></div><div class="collapse__content"><p id="-p6m5wz_506"><span class="control" id="-p6m5wz_517">1. Diff&eacute;rence entre imp&eacute;ratif et d&eacute;claratif ?</span></p><ul class="list _bullet" id="-p6m5wz_507"><li class="list__item" id="-p6m5wz_518"><p id="-p6m5wz_520"><span class="control" id="-p6m5wz_521">R&eacute;ponse : B) Imp&eacute;rative se concentre sur le &quot;comment&quot; modifier l'UI, d&eacute;clarative sur le &quot;quoi&quot; afficher pour un &eacute;tat donn&eacute;.</span></p></li><li class="list__item" id="-p6m5wz_519"><p id="-p6m5wz_522"><span class="control" id="-p6m5wz_523">Justification :</span> C'est le changement de paradigme central. On ne donne plus d'ordres de modification, on d&eacute;crit le r&eacute;sultat souhait&eacute; en fonction des donn&eacute;es.</p></li></ul><p id="-p6m5wz_508"><span class="control" id="-p6m5wz_524">2. Quel est le r&ocirc;le de <code class="code" id="-p6m5wz_525">remember</code>?</span></p><ul class="list _bullet" id="-p6m5wz_509"><li class="list__item" id="-p6m5wz_526"><p id="-p6m5wz_528"><span class="control" id="-p6m5wz_529">R&eacute;ponse : C) Pr&eacute;server la valeur d'un &eacute;tat &agrave; travers les recompositions d'un Composable.</span></p></li><li class="list__item" id="-p6m5wz_527"><p id="-p6m5wz_530"><span class="control" id="-p6m5wz_531">Justification :</span> Sans <code class="code" id="-p6m5wz_532">remember</code>, toute variable locale &agrave; un Composable serait r&eacute;initialis&eacute;e &agrave; chaque recomposition. <code class="code" id="-p6m5wz_533">remember</code> attache la valeur &agrave; l'emplacement du Composable dans l'arbre d'UI, lui permettant de &quot; survivre&quot;.</p></li></ul><p id="-p6m5wz_510"><span class="control" id="-p6m5wz_534">3. Lequel de ces Composables pour aligner horizontalement ?</span></p><ul class="list _bullet" id="-p6m5wz_511"><li class="list__item" id="-p6m5wz_535"><p id="-p6m5wz_537"><span class="control" id="-p6m5wz_538">R&eacute;ponse : D) <code class="code" id="-p6m5wz_539">Row</code></span></p></li><li class="list__item" id="-p6m5wz_536"><p id="-p6m5wz_540"><span class="control" id="-p6m5wz_541">Justification :</span> <code class="code" id="-p6m5wz_542">Row</code> (rang&eacute;e) est le Composable de layout sp&eacute;cifiquement con&ccedil;u pour positionner ses enfants les uns apr&egrave;s les autres sur l'axe horizontal.</p></li></ul><p id="-p6m5wz_512"><span class="control" id="-p6m5wz_543">4. Expliquez la recomposition.</span></p><ul class="list _bullet" id="-p6m5wz_513"><li class="list__item" id="-p6m5wz_544"><p id="-p6m5wz_545"><span class="control" id="-p6m5wz_546">R&eacute;ponse type :</span> La recomposition est le processus par lequel Jetpack Compose r&eacute;-ex&eacute;cute les fonctions Composable dont les param&egrave;tres d'entr&eacute;e (l'&eacute;tat) ont chang&eacute;, afin de mettre &agrave; jour l'UI. Il est crucial qu'elle soit cibl&eacute;e car si l'ensemble de l'&eacute;cran &eacute;tait redessin&eacute; &agrave; chaque petit changement (comme taper une lettre dans un champ de texte), les performances seraient catastrophiques. Compose est capable de n'identifier et de ne recomposer que les plus petits Composables qui d&eacute;pendent de l'&eacute;tat qui a chang&eacute;, ce qui rend le processus extr&ecirc;mement efficace.</p></li></ul><p id="-p6m5wz_514"><span class="control" id="-p6m5wz_547">5. Comment <code class="code" id="-p6m5wz_548">StateFlow</code> et <code class="code" id="-p6m5wz_549">collectAsStateWithLifecycle</code> collaborent-ils ?</span></p><ul class="list _bullet" id="-p6m5wz_515"><li class="list__item" id="-p6m5wz_550"><p id="-p6m5wz_551"><span class="control" id="-p6m5wz_552">R&eacute;ponse type :</span> Le <code class="code" id="-p6m5wz_553">StateFlow</code> dans le <code class="code" id="-p6m5wz_554">ViewModel</code> agit comme la &quot;source de v&eacute;rit&eacute;&quot; de l'&eacute;tat. Quand sa valeur est mise &agrave; jour, il notifie ses collecteurs. Dans le Composable, <code class="code" id="-p6m5wz_555">collectAsStateWithLifecycle</code> fait deux choses : 1) Il s'abonne (collecte) au <code class="code" id="-p6m5wz_556">StateFlow</code> de mani&egrave;re consciente du cycle de vie, s'assurant de ne pas recevoir de mises &agrave; jour inutilement en arri&egrave;re-plan. 2) Il convertit le flux de donn&eacute;es en un objet <code class="code" id="-p6m5wz_557">State</code> que Compose peut observer. Ainsi, chaque nouvelle valeur &eacute;mise par le <code class="code" id="-p6m5wz_558">StateFlow</code> est transform&eacute;e en une nouvelle valeur pour l'objet <code class="code" id="-p6m5wz_559">State</code>, ce qui d&eacute;clenche automatiquement et de mani&egrave;re transparente la recomposition du Composable. C'est le pont parfait entre le monde MVVM et le monde d&eacute;claratif de Compose.</p></li></ul></div></div></section><section class="chapter"><h3 id="conclusion-du-module" data-toc="conclusion-du-module">Conclusion du module</h3><p id="-p6m5wz_560">Vous avez eu un aper&ccedil;u du futur. Jetpack Compose change radicalement la fa&ccedil;on dont nous construisons les interfaces sur Android. En vous lib&eacute;rant de la gestion manuelle des vues, il vous permet de vous concentrer sur ce qui compte vraiment : l'&eacute;tat de votre application et la logique qui le gouverne.</p><p id="-p6m5wz_561">Votre connaissance de l'architecture MVVM, des coroutines et des flux de donn&eacute;es comme <code class="code" id="-p6m5wz_562">StateFlow</code> vous place dans une position id&eacute;ale pour adopter cette nouvelle technologie. C'est une comp&eacute;tence qui deviendra de plus en plus essentielle dans les ann&eacute;es &agrave; venir.</p></section></section><div class="last-modified">31 octobre 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="007-01-module-17.html" class="navigation-links__prev">Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin)</a><a href="007-03-module-19.html" class="navigation-links__next">Module 19 : Gestion des Permissions et Donn&eacute;es Sensibles</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>
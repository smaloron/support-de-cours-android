<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-11-07T11:26:39.35719"><title>Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"notions-abord-es","level":0,"title":"Notions abordées","anchor":"#notions-abord-es"},{"id":"le-principe-de-l-injection-de-d-pendances","level":0,"title":"Le principe de l\u0027Injection de Dépendances","anchor":"#le-principe-de-l-injection-de-d-pendances"},{"id":"hilt-la-solution-standard-recommand-e-par-google","level":0,"title":"Hilt : La solution standard recommandée par Google","anchor":"#hilt-la-solution-standard-recommand-e-par-google"},{"id":"koin-l-alternative-pure-kotlin","level":0,"title":"Koin : L\u0027alternative pure Kotlin","anchor":"#koin-l-alternative-pure-kotlin"},{"id":"tp-17-refactoriser-l-application-dog-facts-avec-hilt","level":0,"title":"TP 17 : Refactoriser l\u0027application \"Dog Facts\" avec Hilt","anchor":"#tp-17-refactoriser-l-application-dog-facts-avec-hilt"},{"id":"correction-du-tp-17","level":0,"title":"Correction du TP 17","anchor":"#correction-du-tp-17"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Android Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/007-01-module-17.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/007-01-module-17.html#webpage",
    "url": "writerside-documentation/007-01-module-17.html",
    "name": "Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Android Help"
}</script><!-- End Schema.org --></head><body data-id="007-01-module-17" data-main-title="Module 17 : Injection de Dépendances (Hilt & Koin)" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="007-bonus.md|Pour aller plus loin : L'Horizon du Développeur Android"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Android  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="007-01-module-17" id="007-01-module-17.md">Module 17 : Injection de Dépendances (Hilt & Koin)</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="-gtmxdd_12">&Agrave; la fin de ce module, vous serez capable de :</p><ul class="list _bullet" id="-gtmxdd_13"><li class="list__item" id="-gtmxdd_14"><p id="-gtmxdd_19">Expliquer le principe de l'Inversion de Contr&ocirc;le et de l'Injection de D&eacute;pendances (DI).</p></li><li class="list__item" id="-gtmxdd_15"><p id="-gtmxdd_20">Comprendre les probl&egrave;mes li&eacute;s &agrave; l'instanciation manuelle des d&eacute;pendances.</p></li><li class="list__item" id="-gtmxdd_16"><p id="-gtmxdd_21">Mettre en place Hilt, la solution de DI recommand&eacute;e par Google, pour injecter des objets.</p></li><li class="list__item" id="-gtmxdd_17"><p id="-gtmxdd_22">Utiliser les annotations Hilt de base (<code class="code" id="-gtmxdd_23">@HiltAndroidApp</code>, <code class="code" id="-gtmxdd_24">@AndroidEntryPoint</code>, <code class="code" id="-gtmxdd_25">@HiltViewModel</code>, <code class="code" id="-gtmxdd_26">@Inject</code>).</p></li><li class="list__item" id="-gtmxdd_18"><p id="-gtmxdd_27">(Alternative) Comprendre les bases de Koin comme solution de DI pure Kotlin.</p></li></ul></section><section class="chapter"><h2 id="introduction" data-toc="introduction">Introduction</h2><p id="-gtmxdd_28">Imaginez que vous construisez une voiture. Jusqu'&agrave; pr&eacute;sent, &agrave; chaque fois que vous aviez besoin d'un moteur, vous le construisiez vous-m&ecirc;me &agrave; partir de z&eacute;ro, directement &agrave; l'int&eacute;rieur du ch&acirc;ssis. Puis vous construisiez la transmission, puis les roues... C'est ce que nous avons fait en &eacute;crivant <code class="code" id="-gtmxdd_30">val dao = AppDatabase.getDatabase(..).noteDao()</code> ou <code class="code" id="-gtmxdd_31">val repository = NoteRepository(dao)</code>. C'est <span class="control" id="-gtmxdd_32">l'objet lui-m&ecirc;me qui cr&eacute;e les composants dont il d&eacute;pend</span>. C'est long, r&eacute;p&eacute;titif, et si le plan du moteur change, vous devez le modifier partout o&ugrave; vous en construisez un.</p><p id="-gtmxdd_29">L' <span class="control" id="-gtmxdd_33">Injection de D&eacute;pendances (DI)</span>, c'est comme avoir une usine de fabrication ultra-moderne. Vous ne construisez plus rien vous-m&ecirc;me. Vous d&eacute;clarez simplement : &quot;Pour cette voiture, j'ai besoin d'un moteur V8 et d'une transmission automatique&quot;. L'usine (le framework de DI) sait exactement comment construire ces composants, comment ils s'assemblent, et vous les livre &quot;cl&eacute;s en main&quot; au bon endroit, au bon moment. Votre travail n'est plus de fabriquer, mais d'assembler des pi&egrave;ces d&eacute;j&agrave; fournies.</p></section><section class="chapter"><h2 id="notions-abord-es" data-toc="notions-abord-es">Notions abord&eacute;es</h2><ul class="list _bullet" id="-gtmxdd_34"><li class="list__item" id="-gtmxdd_36"><p id="-gtmxdd_39">Le principe de l'Injection de D&eacute;pendances</p></li><li class="list__item" id="-gtmxdd_37"><p id="-gtmxdd_40">Hilt : La solution standard recommand&eacute;e par Google</p></li><li class="list__item" id="-gtmxdd_38"><p id="-gtmxdd_41">Koin : L'alternative pure Kotlin</p></li></ul></section><section class="chapter"><h2 id="le-principe-de-l-injection-de-d-pendances" data-toc="le-principe-de-l-injection-de-d-pendances">Le principe de l'Injection de D&eacute;pendances</h2><section class="chapter"><h3 id="introduction-la-notion" data-toc="introduction-la-notion">Introduction &agrave; la notion</h3><p id="-gtmxdd_44">Le c&oelig;ur de la DI est un principe appel&eacute; <span class="control" id="-gtmxdd_45">Inversion de Contr&ocirc;le (Inversion of Control - IoC)</span>. Au lieu que votre objet (<code class="code" id="-gtmxdd_46">ViewModel</code>) contr&ocirc;le la cr&eacute;ation de ses d&eacute;pendances (<code class="code" id="-gtmxdd_47">Repository</code>), vous inversez ce contr&ocirc;le et le d&eacute;l&eacute;guez &agrave; un syst&egrave;me externe (le framework de DI).</p></section><section class="chapter"><h3 id="explication-de-la-notion" data-toc="explication-de-la-notion">Explication de la notion</h3><p id="-gtmxdd_48"><span class="control" id="-gtmxdd_57">Sans DI (ce que nous avons fait jusqu'&agrave; pr&eacute;sent) :</span></p><div class="code-block" data-lang="kotlin">
// Le ViewModel est responsable de la création du Repository.
// C'est un couplage fort.
class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: NoteRepository

    init {
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao) // &lt;-- CRÉATION MANUELLE
    }
}
</div><p id="-gtmxdd_50"><span class="control" id="-gtmxdd_58">Probl&egrave;mes :</span></p><ul class="list _bullet" id="-gtmxdd_51"><li class="list__item" id="-gtmxdd_59"><p id="-gtmxdd_62"><span class="control" id="-gtmxdd_63">Couplage fort :</span> <code class="code" id="-gtmxdd_64">NoteViewModel</code> est &eacute;troitement li&eacute; &agrave; la mani&egrave;re de construire <code class="code" id="-gtmxdd_65">NoteRepository</code>.</p></li><li class="list__item" id="-gtmxdd_60"><p id="-gtmxdd_66"><span class="control" id="-gtmxdd_67">Difficult&eacute; &agrave; tester :</span> Comment tester <code class="code" id="-gtmxdd_68">NoteViewModel</code> sans une vraie base de donn&eacute;es ? On ne peut pas facilement lui fournir un &quot;faux&quot; <code class="code" id="-gtmxdd_69">NoteRepository</code> pour les tests.</p></li><li class="list__item" id="-gtmxdd_61"><p id="-gtmxdd_70"><span class="control" id="-gtmxdd_71">Code r&eacute;p&eacute;titif (<code class="code" id="-gtmxdd_72">Boilerplate</code>) :</span> Vous devez r&eacute;&eacute;crire cette logique d'initialisation partout.</p></li></ul><p id="-gtmxdd_52"><span class="control" id="-gtmxdd_73">Avec DI :</span></p><div class="code-block" data-lang="kotlin">
// Le ViewModel déclare ce dont il a besoin, mais ne le crée pas.
// Hilt fournira le Repository automatiquement.
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository // &lt;-- DÉPENDANCE INJECTÉE
) : ViewModel() {
    // ...
}
</div><p id="-gtmxdd_54"><span class="control" id="-gtmxdd_74">Avantages :</span></p><ul class="list _bullet" id="-gtmxdd_55"><li class="list__item" id="-gtmxdd_75"><p id="-gtmxdd_78"><span class="control" id="-gtmxdd_79">D&eacute;couplage :</span> Le <code class="code" id="-gtmxdd_80">ViewModel</code> ne sait plus comment le <code class="code" id="-gtmxdd_81">Repository</code> est cr&eacute;&eacute;.</p></li><li class="list__item" id="-gtmxdd_76"><p id="-gtmxdd_82"><span class="control" id="-gtmxdd_83">Testabilit&eacute; :</span> En test, on peut facilement demander au framework de DI de fournir une version &quot;mock&quot; (factice) du <code class="code" id="-gtmxdd_84">Repository</code>.</p></li><li class="list__item" id="-gtmxdd_77"><p id="-gtmxdd_85"><span class="control" id="-gtmxdd_86">Centralisation :</span> La logique de cr&eacute;ation des objets est d&eacute;finie &agrave; un seul endroit.</p></li></ul></section></section><section class="chapter"><h2 id="hilt-la-solution-standard-recommand-e-par-google" data-toc="hilt-la-solution-standard-recommand-e-par-google">Hilt : La solution standard recommand&eacute;e par Google</h2><section class="chapter"><h3 id="introduction-la-notion_1" data-toc="introduction-la-notion_1">Introduction &agrave; la notion</h3><p id="-gtmxdd_91">Hilt est la solution d'injection de d&eacute;pendances officielle pour Android. Il est construit sur une base tr&egrave;s puissante ( Dagger) mais la simplifie &eacute;norm&eacute;ment pour le contexte Android. Hilt utilise des annotations et de la g&eacute;n&eacute;ration de code pour cr&eacute;er et &quot;c&acirc;bler&quot; vos d&eacute;pendances &agrave; la <span class="control" id="-gtmxdd_92">compilation</span>. Cela le rend tr&egrave;s performant et s&ucirc;r (une erreur de configuration emp&ecirc;chera votre application de compiler).</p></section><section class="chapter"><h3 id="mise-en-place" data-toc="mise-en-place">Mise en place</h3><section class="procedure-steps"><h3 id="-gtmxdd_93" data-toc="-gtmxdd_93">Configuration de Hilt</h3><ol class="list _decimal" id="-gtmxdd_94" type="1"><li class="list__item" id="-gtmxdd_95"><p id="-gtmxdd_98"><span class="control" id="-gtmxdd_103">Ajouter les plugins Gradle :</span></p><ul class="list _bullet" id="-gtmxdd_99"><li class="list__item" id="-gtmxdd_104"><p id="-gtmxdd_105">Dans <code class="code" id="-gtmxdd_106">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_107">projet</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.51&quot; apply false
}
</div><ul class="list _bullet" id="-gtmxdd_101"><li class="list__item" id="-gtmxdd_108"><p id="-gtmxdd_109">Dans <code class="code" id="-gtmxdd_110">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_111">module :app</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;)
    id(&quot;com.google.devtools.ksp&quot;) // Hilt utilise KSP
}
</div></li><li class="list__item" id="-gtmxdd_96"><p id="-gtmxdd_112"><span class="control" id="-gtmxdd_115">Ajouter les d&eacute;pendances :</span></p><ul class="list _bullet" id="-gtmxdd_113"><li class="list__item" id="-gtmxdd_116"><p id="-gtmxdd_117">Dans <code class="code" id="-gtmxdd_118">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_119">module :app</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
dependencies {
    implementation(&quot;com.google.dagger:hilt-android:2.51&quot;)
    ksp(&quot;com.google.dagger:hilt-compiler:2.51&quot;)
}
</div></li><li class="list__item" id="-gtmxdd_97"><p id="-gtmxdd_120"><span class="control" id="-gtmxdd_123">Annoter la classe Application :</span></p><ul class="list _bullet" id="-gtmxdd_121"><li class="list__item" id="-gtmxdd_124"><p id="-gtmxdd_126">Cr&eacute;ez une classe qui h&eacute;rite de <code class="code" id="-gtmxdd_127">Application</code> et annotez-la avec <code class="code" id="-gtmxdd_128">@HiltAndroidApp</code>.</p></li><li class="list__item" id="-gtmxdd_125"><p id="-gtmxdd_129">N'oubliez pas de la d&eacute;clarer dans votre <code class="code" id="-gtmxdd_130">AndroidManifest.xml</code>.</p></li></ul><div class="code-block" data-lang="kotlin">
// Dans MyApp.kt
@HiltAndroidApp
class MyApp : Application() {}

// Dans AndroidManifest.xml
&lt;application
    android:name=&quot;.MyApp&quot;
    ... &gt;
</div></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><h3 id="utilisation" data-toc="utilisation">Utilisation</h3><ol class="list _decimal" id="-gtmxdd_131" type="1"><li class="list__item" id="-gtmxdd_132"><p id="-gtmxdd_136"><span class="control" id="-gtmxdd_137"><code class="code" id="-gtmxdd_138">@AndroidEntryPoint</code></span>: Annotez vos classes Android (Activities, Fragments) pour que Hilt puisse y injecter des d&eacute;pendances.</p></li><li class="list__item" id="-gtmxdd_133"><p id="-gtmxdd_139"><span class="control" id="-gtmxdd_140"><code class="code" id="-gtmxdd_142">@Inject constructor</code></span>: Annotez le constructeur d'une de vos classes (ex: <code class="code" id="-gtmxdd_141">NoteRepository</code>) pour apprendre &agrave; Hilt comment la cr&eacute;er.</p></li><li class="list__item" id="-gtmxdd_134"><p id="-gtmxdd_143"><span class="control" id="-gtmxdd_144"><code class="code" id="-gtmxdd_146">@HiltViewModel</code></span>: Annotez votre <code class="code" id="-gtmxdd_145">ViewModel</code> pour que Hilt le g&egrave;re. La d&eacute;pendance est ensuite inject&eacute;e via le constructeur.</p></li><li class="list__item" id="-gtmxdd_135"><p id="-gtmxdd_147"><span class="control" id="-gtmxdd_148">Modules Hilt (<code class="code" id="-gtmxdd_149">@Module</code> et <code class="code" id="-gtmxdd_150">@Provides</code>)</span>: Pour les choses que vous ne poss&eacute;dez pas (comme une interface ou une classe d'une biblioth&egrave;que externe comme Room ou Retrofit), vous devez cr&eacute;er un &quot;module&quot; pour apprendre &agrave; Hilt comment les fournir.</p></li></ol></section><section class="chapter"><h3 id="exemple-refactoriser-notre-application-de-notes-avec-hilt" data-toc="exemple-refactoriser-notre-application-de-notes-avec-hilt">Exemple : Refactoriser notre application de notes avec Hilt</h3><p id="-gtmxdd_151"><span class="control" id="-gtmxdd_161">1. <code class="code" id="-gtmxdd_162">AppModule.kt</code> (Le &quot;mode d'emploi&quot; pour Hilt)</span></p><div class="code-block" data-lang="kotlin">
package fr.formation.notes.di

import android.content.Context
import androidx.room.Room
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import fr.formation.notes.data.AppDatabase
import fr.formation.notes.data.NoteDao
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class) // Ces dépendances vivront aussi longtemps que l'app
object AppModule {

    @Provides
    @Singleton // On veut une seule instance de la BDD
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            &quot;notes_database&quot;
        ).build()
    }

    @Provides
    fun provideNoteDao(appDatabase: AppDatabase): NoteDao {
        // Hilt sait comment créer AppDatabase (grâce à la méthode au-dessus),
        // il peut donc l'utiliser pour fournir le NoteDao.
        return appDatabase.noteDao()
    }
}
</div><p id="-gtmxdd_153"><span class="control" id="-gtmxdd_163">2. <code class="code" id="-gtmxdd_164">NoteRepository.kt</code></span></p><div class="code-block" data-lang="kotlin">
// Hilt sait maintenant comment créer NoteDao, il peut donc l'injecter ici.
class NoteRepository @Inject constructor(private val noteDao: NoteDao) {
    // ...
}
</div><p id="-gtmxdd_155"><span class="control" id="-gtmxdd_165">3. <code class="code" id="-gtmxdd_166">NoteViewModel.kt</code></span></p><div class="code-block" data-lang="kotlin">
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository
) : ViewModel() {
    // ...
}
</div><p id="-gtmxdd_157"><span class="control" id="-gtmxdd_167">4. <code class="code" id="-gtmxdd_168">MainActivity.kt</code></span></p><div class="code-block" data-lang="kotlin">
@AndroidEntryPoint // Indique que Hilt doit injecter des dépendances ici
class MainActivity : AppCompatActivity() {
    // L'instanciation est toujours déléguée, mais maintenant gérée par Hilt.
    private val viewModel: NoteViewModel by viewModels()
    // ...
}
</div><p id="-gtmxdd_159">Et voil&agrave; ! Plus aucune cr&eacute;ation manuelle. Le code est propre, d&eacute;coupl&eacute; et testable.</p></section></section><section class="chapter"><h2 id="koin-l-alternative-pure-kotlin" data-toc="koin-l-alternative-pure-kotlin">Koin : L'alternative pure Kotlin</h2><section class="chapter"><h3 id="introduction-la-notion_2" data-toc="introduction-la-notion_2">Introduction &agrave; la notion</h3><p id="-gtmxdd_172">Koin est une autre biblioth&egrave;que de DI tr&egrave;s populaire. Sa philosophie est diff&eacute;rente : elle n'utilise pas de g&eacute;n&eacute;ration de code. C'est un framework pur Kotlin, souvent consid&eacute;r&eacute; comme plus simple &agrave; apprendre et &agrave; configurer. Il fonctionne &agrave; l' <span class="control" id="-gtmxdd_173">ex&eacute;cution</span> (runtime), ce qui le rend moins performant que Hilt mais plus flexible.</p></section><section class="chapter"><h3 id="utilisation_1" data-toc="utilisation_1">Utilisation</h3><ol class="list _decimal" id="-gtmxdd_174" type="1"><li class="list__item" id="-gtmxdd_175"><p id="-gtmxdd_178"><span class="control" id="-gtmxdd_180">D&eacute;finir un module :</span> Vous cr&eacute;ez un &quot;module&quot; Koin o&ugrave; vous d&eacute;crivez comment cr&eacute;er vos objets.</p><div class="code-block" data-lang="kotlin">
val appModule = module {
    // Crée une seule instance (Singleton) de AppDatabase
    single { AppDatabase.getDatabase(androidContext()) }
    // Crée une instance de NoteDao à chaque fois qu'elle est demandée (factory)
    factory { get&lt;AppDatabase&gt;().noteDao() }
    // Crée un singleton du Repository
    single { NoteRepository(get()) } // `get()` résout la dépendance (NoteDao)

    // Déclaration spéciale pour un ViewModel
    viewModel { NoteViewModel(get()) } // `get()` résout NoteRepository
}
</div></li><li class="list__item" id="-gtmxdd_176"><p id="-gtmxdd_181"><span class="control" id="-gtmxdd_183">D&eacute;marrer Koin</span> dans la classe <code class="code" id="-gtmxdd_184">Application</code>:</p><div class="code-block" data-lang="kotlin">
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@MyApp)
            modules(appModule)
        }
    }
}
</div></li><li class="list__item" id="-gtmxdd_177"><p id="-gtmxdd_185"><span class="control" id="-gtmxdd_187">Injecter dans les classes Android :</span></p><div class="code-block" data-lang="kotlin">
class MainActivity : AppCompatActivity() {
    // Injection du ViewModel gérée par Koin
    private val viewModel: NoteViewModel by viewModel()
    // ...
}
</div></li></ol></section><section class="chapter"><h3 id="hilt-vs-koin-le-choix" data-toc="hilt-vs-koin-le-choix">Hilt vs. Koin : Le choix</h3><div class="table-wrapper"><table class="wide" id="-gtmxdd_188"><thead><tr class="ijRowHead" id="-gtmxdd_191"><th id="-gtmxdd_197"><p>Caract&eacute;ristique</p></th><th id="-gtmxdd_198"><p>Hilt (Dagger)</p></th><th id="-gtmxdd_199"><p>Koin</p></th></tr></thead><tbody><tr id="-gtmxdd_192"><td id="-gtmxdd_200"><p><span class="control" id="-gtmxdd_203">V&eacute;rification</span></p></td><td id="-gtmxdd_201"><p>&Agrave; la <span class="control" id="-gtmxdd_204">compilation</span> (plus s&ucirc;r)</p></td><td id="-gtmxdd_202"><p>&Agrave; l' <span class="control" id="-gtmxdd_205">ex&eacute;cution</span> (plus de risques d'erreurs)</p></td></tr><tr id="-gtmxdd_193"><td id="-gtmxdd_206"><p><span class="control" id="-gtmxdd_209">Performance</span></p></td><td id="-gtmxdd_207"><p>Plus rapide (pas de r&eacute;flexion au runtime)</p></td><td id="-gtmxdd_208"><p>Moins rapide (utilise la r&eacute;flexion)</p></td></tr><tr id="-gtmxdd_194"><td id="-gtmxdd_210"><p><span class="control" id="-gtmxdd_213">Configuration</span></p></td><td id="-gtmxdd_211"><p>Plus complexe (plugins, annotations...)</p></td><td id="-gtmxdd_212"><p>Tr&egrave;s simple (une d&eacute;pendance, un module)</p></td></tr><tr id="-gtmxdd_195"><td id="-gtmxdd_214"><p><span class="control" id="-gtmxdd_217">&Eacute;cosyst&egrave;me</span></p></td><td id="-gtmxdd_215"><p>Standard de Google, int&eacute;gr&eacute; &agrave; Jetpack</p></td><td id="-gtmxdd_216"><p>Communaut&eacute; forte, pure Kotlin</p></td></tr><tr id="-gtmxdd_196"><td id="-gtmxdd_218"><p><span class="control" id="-gtmxdd_221">&quot;Magie&quot;</span></p></td><td id="-gtmxdd_219"><p>Beaucoup de g&eacute;n&eacute;ration de code &quot;magique&quot;</p></td><td id="-gtmxdd_220"><p>Plus explicite et facile &agrave; d&eacute;boguer</p></td></tr></tbody></table></div><p id="-gtmxdd_189"><span class="control" id="-gtmxdd_222">Conclusion :</span> Pour les d&eacute;butants et les projets o&ugrave; la simplicit&eacute; prime, Koin peut &ecirc;tre un excellent choix. Pour les projets professionnels, &agrave; grande &eacute;chelle et o&ugrave; la performance et la s&eacute;curit&eacute; &agrave; la compilation sont critiques, <span class="control" id="-gtmxdd_223">Hilt est le standard de l'industrie</span>.</p></section></section><section class="chapter"><h2 id="tp-17-refactoriser-l-application-dog-facts-avec-hilt" data-toc="tp-17-refactoriser-l-application-dog-facts-avec-hilt">TP 17 : Refactoriser l'application &quot;Dog Facts&quot; avec Hilt</h2><p id="-gtmxdd_224"><span class="control" id="-gtmxdd_226">Objectif :</span> Reprendre le TP du module 13 et le refactoriser pour utiliser Hilt pour injecter le service Retrofit et le ViewModel.</p><section class="procedure-steps" id="-gtmxdd_225"><ol class="list _decimal" id="-gtmxdd_227" type="1"><li class="list__item" id="-gtmxdd_228"><p id="-gtmxdd_234"><span class="control" id="-gtmxdd_235">Configurez Hilt</span> dans le projet (plugins, d&eacute;pendances, classe <code class="code" id="-gtmxdd_236">Application</code>).</p></li><li class="list__item" id="-gtmxdd_229"><p id="-gtmxdd_237"><span class="control" id="-gtmxdd_239">Cr&eacute;ez un module Hilt</span> (<code class="code" id="-gtmxdd_240">NetworkModule.kt</code>) pour apprendre &agrave; Hilt comment fournir l'instance de Retrofit et l' <code class="code" id="-gtmxdd_241">ApiService</code>.</p><div class="code-block" data-lang="kotlin">
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        // ... votre code de création de Retrofit ...
    }

    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
</div></li><li class="list__item" id="-gtmxdd_230"><p id="-gtmxdd_242"><span class="control" id="-gtmxdd_243">Cr&eacute;ez un <code class="code" id="-gtmxdd_247">DogFactRepository</code></span> qui prendra <code class="code" id="-gtmxdd_244">ApiService</code> en d&eacute;pendance (via <code class="code" id="-gtmxdd_245">@Inject constructor</code>). Sa seule m&eacute;thode sera <code class="code" id="-gtmxdd_246">suspend fun getNewFact()</code>.</p></li><li class="list__item" id="-gtmxdd_231"><p id="-gtmxdd_248"><span class="control" id="-gtmxdd_249">Refactorisez votre <code class="code" id="-gtmxdd_252">DogFactViewModel</code></span> pour qu'il soit annot&eacute; avec <code class="code" id="-gtmxdd_250">@HiltViewModel</code> et qu'il injecte le <code class="code" id="-gtmxdd_251">DogFactRepository</code> dans son constructeur. La logique d'appel r&eacute;seau doit maintenant se trouver dans le ViewModel.</p></li><li class="list__item" id="-gtmxdd_232"><p id="-gtmxdd_253"><span class="control" id="-gtmxdd_254">Annotez votre <code class="code" id="-gtmxdd_256">MainActivity</code></span> avec <code class="code" id="-gtmxdd_255">@AndroidEntryPoint</code>.</p></li><li class="list__item" id="-gtmxdd_233"><p id="-gtmxdd_257"><span class="control" id="-gtmxdd_258">Supprimez toute cr&eacute;ation manuelle</span> de <code class="code" id="-gtmxdd_259">RetrofitClient</code>, <code class="code" id="-gtmxdd_260">Repository</code> ou <code class="code" id="-gtmxdd_261">ViewModel</code>. L'Activity doit simplement obtenir le ViewModel via <code class="code" id="-gtmxdd_262">by viewModels()</code>.</p></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="correction-du-tp-17" data-toc="correction-du-tp-17">Correction du TP 17</h2></div><div class="collapse__content"><section class="chapter"><h3 id="pr-requis-code-de-d-part" data-toc="pr-requis-code-de-d-part">Pr&eacute;requis : Code de d&eacute;part</h3><p id="-gtmxdd_269">On part du code du TP sur Retrofit, qui contenait :</p><ul class="list _bullet" id="-gtmxdd_270"><li class="list__item" id="-gtmxdd_272"><p id="-gtmxdd_276"><code class="code" id="-gtmxdd_277">ApiService.kt</code></p></li><li class="list__item" id="-gtmxdd_273"><p id="-gtmxdd_278"><code class="code" id="-gtmxdd_279">DogFactResponse.kt</code></p></li><li class="list__item" id="-gtmxdd_274"><p id="-gtmxdd_280"><code class="code" id="-gtmxdd_281">RetrofitInstance.kt</code> (qu'on va supprimer)</p></li><li class="list__item" id="-gtmxdd_275"><p id="-gtmxdd_282"><code class="code" id="-gtmxdd_283">MainActivity.kt</code> (qui faisait tout le travail)</p></li></ul></section><section class="chapter"><h3 id="tape-1-configuration-de-hilt" data-toc="tape-1-configuration-de-hilt">&Eacute;tape 1 : Configuration de Hilt</h3><section class="chapter"><h4 id="1a-plugins-et-d-pendances" data-toc="1a-plugins-et-d-pendances">1a. Plugins et D&eacute;pendances</h4><p id="-gtmxdd_287">Modifiez vos fichiers <code class="code" id="-gtmxdd_293">build.gradle.kts</code>.</p><p id="-gtmxdd_288"><span class="control" id="-gtmxdd_294">Fichier <code class="code" id="-gtmxdd_295">build.gradle.kts</code> (au niveau du projet) :</span></p><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.51.1&quot; apply false
    id(&quot;com.google.devtools.ksp&quot;) version &quot;1.9.22-1.0.17&quot; apply false
}
</div><p id="-gtmxdd_290"><span class="control" id="-gtmxdd_296">Fichier <code class="code" id="-gtmxdd_297">build.gradle.kts</code> (au niveau du module) :</span></p><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;)
    id(&quot;com.google.devtools.ksp&quot;)
}

android { /* ... */ }

dependencies {
    // ...
    
    // Hilt
    implementation(&quot;com.google.dagger:hilt-android:2.51.1&quot;)
    ksp(&quot;com.google.dagger:hilt-compiler:2.51.1&quot;)

    // ViewModel
    implementation(&quot;androidx.lifecycle:lifecycle-viewmodel-ktx:2.7.0&quot;)
    // Pour l'obtention du ViewModel dans l'activité
    implementation(&quot;androidx.activity:activity-ktx:1.9.0&quot;)
}
</div><p id="-gtmxdd_292"><span class="control" id="-gtmxdd_298">N'oubliez pas de synchroniser</span> votre projet avec Gradle apr&egrave;s ces modifications.</p></section><section class="chapter"><h4 id="1b-classe-application" data-toc="1b-classe-application">1b. Classe Application</h4><p id="-gtmxdd_299">Cr&eacute;ez une nouvelle classe qui h&eacute;rite de <code class="code" id="-gtmxdd_302">Application</code> et annotez-la avec <code class="code" id="-gtmxdd_303">@HiltAndroidApp</code>.</p><p id="-gtmxdd_300"><span class="control" id="-gtmxdd_304">Fichier <code class="code" id="-gtmxdd_305">MyDogApp.kt</code>:</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication // Adaptez le package

import android.app.Application
import dagger.hilt.android.HiltAndroidApp

@HiltAndroidApp
class MyDogApp : Application()
</div></section><section class="chapter"><h4 id="1c-mettre-jour-l-androidmanifest-xml" data-toc="1c-mettre-jour-l-androidmanifest-xml">1c. Mettre &agrave; jour l' <code class="code" id="-gtmxdd_312">AndroidManifest.xml</code></h4><p id="-gtmxdd_307">D&eacute;clarez cette nouvelle classe dans votre manifeste.</p><p id="-gtmxdd_308"><span class="control" id="-gtmxdd_313">Fichier <code class="code" id="-gtmxdd_314">AndroidManifest.xml</code>:</span></p><div class="code-block" data-lang="markup">
&lt;application
    android:name=&quot;.MyDogApp&quot;
    ...&gt;
    &lt;!-- ... --&gt;
&lt;/application&gt;
</div><p id="-gtmxdd_310">La configuration de base de Hilt est termin&eacute;e.</p></section></section><section class="chapter"><h3 id="tape-2-cr-er-le-module-hilt-pour-le-r-seau" data-toc="tape-2-cr-er-le-module-hilt-pour-le-r-seau">&Eacute;tape 2 : Cr&eacute;er le Module Hilt pour le R&eacute;seau</h3><p id="-gtmxdd_315">Cr&eacute;ez un nouveau fichier <code class="code" id="-gtmxdd_321">NetworkModule.kt</code>. Ce module va expliquer &agrave; Hilt comment construire nos objets li&eacute;s au r&eacute;seau. <span class="control" id="-gtmxdd_322">On peut supprimer le fichier <code class="code" id="-gtmxdd_323">RetrofitInstance.kt</code></span>, car ce module le remplace enti&egrave;rement.</p><p id="-gtmxdd_316"><span class="control" id="-gtmxdd_324">Fichier <code class="code" id="-gtmxdd_325">NetworkModule.kt</code>:</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.di // C'est une bonne pratique de mettre les modules dans un package 'di'

import com.example.yourapplication.data.remote.ApiService
import com.squareup.moshi.Moshi
import com.squareup.moshi.kotlin.reflect.KotlinJsonAdapterFactory
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.components.SingletonComponent
import retrofit2.Retrofit
import retrofit2.converter.moshi.MoshiConverterFactory
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    private const val BASE_URL = &quot;https://dog-api.kinduff.com/&quot;

    @Provides
    @Singleton
    fun provideMoshi(): Moshi {
        return Moshi.Builder()
            .add(KotlinJsonAdapterFactory())
            .build()
    }

    @Provides
    @Singleton
    fun provideRetrofit(moshi: Moshi): Retrofit {
        return Retrofit.Builder()
            .baseUrl(BASE_URL)
            .addConverterFactory(MoshiConverterFactory.create(moshi))
            .build()
    }

    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
</div><p id="-gtmxdd_318"><span class="control" id="-gtmxdd_326">Explications :</span></p><ul class="list _bullet" id="-gtmxdd_319"><li class="list__item" id="-gtmxdd_327"><p id="-gtmxdd_331"><code class="code" id="-gtmxdd_332">@Module</code> et <code class="code" id="-gtmxdd_333">@InstallIn(SingletonComponent::class)</code>: Indique &agrave; Hilt que ce module fournit des d&eacute;pendances qui vivront aussi longtemps que l'application.</p></li><li class="list__item" id="-gtmxdd_328"><p id="-gtmxdd_334"><code class="code" id="-gtmxdd_335">@Provides</code>: Marque une fonction qui &quot;fournit&quot; une d&eacute;pendance.</p></li><li class="list__item" id="-gtmxdd_329"><p id="-gtmxdd_336"><code class="code" id="-gtmxdd_337">@Singleton</code>: Indique que Hilt ne doit cr&eacute;er qu'une seule instance de cet objet.</p></li><li class="list__item" id="-gtmxdd_330"><p id="-gtmxdd_338"><span class="control" id="-gtmxdd_339">Cha&icirc;ne de d&eacute;pendances :</span> Remarquez comment <code class="code" id="-gtmxdd_340">provideRetrofit</code> prend <code class="code" id="-gtmxdd_341">Moshi</code> en param&egrave;tre et <code class="code" id="-gtmxdd_342">provideApiService</code> prend <code class="code" id="-gtmxdd_343">Retrofit</code>. Hilt comprend cette cha&icirc;ne et sait dans quel ordre appeler les fonctions pour construire les objets.</p></li></ul></section><section class="chapter"><h3 id="tape-3-cr-er-le-dogfactrepository" data-toc="tape-3-cr-er-le-dogfactrepository">&Eacute;tape 3 : Cr&eacute;er le <code class="code" id="-gtmxdd_351">DogFactRepository</code></h3><p id="-gtmxdd_345">Ce repository encapsule la source de donn&eacute;es (notre <code class="code" id="-gtmxdd_352">ApiService</code>).</p><p id="-gtmxdd_346"><span class="control" id="-gtmxdd_353">Fichier <code class="code" id="-gtmxdd_354">DogFactRepository.kt</code>:</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.data.repository // Bonnes pratiques pour les packages

import com.example.yourapplication.data.remote.ApiService
import javax.inject.Inject

class DogFactRepository @Inject constructor(
    private val apiService: ApiService
) {
    /**
     * Appelle l'API pour obtenir une nouvelle information.
     * Gère la transformation de la réponse pour ne retourner que le texte.
     */
    suspend fun getNewFact(): Result&lt;String&gt; {
        return try {
            val response = apiService.getDogFact()
            if (response.facts.isNotEmpty()) {
                Result.success(response.facts.first())
            } else {
                Result.failure(Exception(&quot;Aucun fait n'a été trouvé.&quot;))
            }
        } catch (e: Exception) {
            Result.failure(e)
        }
    }
}
</div><p id="-gtmxdd_348"><span class="control" id="-gtmxdd_355">Explications :</span></p><ul class="list _bullet" id="-gtmxdd_349"><li class="list__item" id="-gtmxdd_356"><p id="-gtmxdd_358"><code class="code" id="-gtmxdd_359">@Inject constructor(...)</code>: C'est la magie de Hilt. On dit &agrave; Hilt : &quot;Pour cr&eacute;er un <code class="code" id="-gtmxdd_360">DogFactRepository</code>, tu as besoin d'un <code class="code" id="-gtmxdd_361">ApiService</code>. Trouve comment le fournir (via <code class="code" id="-gtmxdd_362">NetworkModule</code>) et injecte-le ici.&quot;</p></li><li class="list__item" id="-gtmxdd_357"><p id="-gtmxdd_363"><span class="control" id="-gtmxdd_364"><code class="code" id="-gtmxdd_367">Result&lt;String&gt;</code></span>: C'est une excellente pratique pour la gestion d'erreurs. La couche Repository retourne soit un succ&egrave;s avec la donn&eacute;e (<code class="code" id="-gtmxdd_365">String</code>), soit un &eacute;chec avec l'exception. Le ViewModel n'a plus besoin de bloc <code class="code" id="-gtmxdd_366">try-catch</code>.</p></li></ul></section><section class="chapter"><h3 id="tape-4-refactoriser-le-dogfactviewmodel" data-toc="tape-4-refactoriser-le-dogfactviewmodel">&Eacute;tape 4 : Refactoriser le <code class="code" id="-gtmxdd_375">DogFactViewModel</code></h3><p id="-gtmxdd_369">Le ViewModel devient le chef d'orchestre. Il ne conna&icirc;t que le Repository.</p><p id="-gtmxdd_370"><span class="control" id="-gtmxdd_376">Fichier <code class="code" id="-gtmxdd_377">DogFactViewModel.kt</code>:</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication.ui // Mettez les ViewModels dans un package 'ui' ou 'presentation'

import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.lifecycle.ViewModel
import androidx.lifecycle.viewModelScope
import com.example.yourapplication.data.repository.DogFactRepository
import dagger.hilt.android.lifecycle.HiltViewModel
import kotlinx.coroutines.launch
import javax.inject.Inject

@HiltViewModel
class DogFactViewModel @Inject constructor(
    private val repository: DogFactRepository
) : ViewModel() {

    // L'état de l'UI est exposé via LiveData (ou StateFlow) pour être observé
    private val _dogFact = MutableLiveData&lt;String&gt;()
    val dogFact: LiveData&lt;String&gt; = _dogFact

    private val _isLoading = MutableLiveData&lt;Boolean&gt;()
    val isLoading: LiveData&lt;Boolean&gt; = _isLoading

    init {
        // Charger un premier fait au démarrage du ViewModel
        fetchNewFact()
    }

    fun fetchNewFact() {
        viewModelScope.launch {
            _isLoading.value = true // Indiquer le début du chargement
            val result = repository.getNewFact()
            result.onSuccess { fact -&gt;
                _dogFact.value = fact
            }.onFailure { error -&gt;
                _dogFact.value = &quot;Erreur de chargement: ${error.message}&quot;
            }
            _isLoading.value = false // Indiquer la fin du chargement
        }
    }
}
</div><p id="-gtmxdd_372"><span class="control" id="-gtmxdd_378">Explications :</span></p><ul class="list _bullet" id="-gtmxdd_373"><li class="list__item" id="-gtmxdd_379"><p id="-gtmxdd_383"><code class="code" id="-gtmxdd_384">@HiltViewModel</code>: Permet &agrave; Hilt d'injecter des d&eacute;pendances dans ce ViewModel.</p></li><li class="list__item" id="-gtmxdd_380"><p id="-gtmxdd_385"><code class="code" id="-gtmxdd_386">@Inject constructor(...)</code>: Comme pour le repository, Hilt va fournir automatiquement une instance de <code class="code" id="-gtmxdd_387">DogFactRepository</code>.</p></li><li class="list__item" id="-gtmxdd_381"><p id="-gtmxdd_388"><span class="control" id="-gtmxdd_389"><code class="code" id="-gtmxdd_394">LiveData</code></span>: Le ViewModel expose l'&eacute;tat de l'UI (<code class="code" id="-gtmxdd_390">_dogFact</code>, <code class="code" id="-gtmxdd_391">_isLoading</code>) via <code class="code" id="-gtmxdd_392">LiveData</code>. L'Activity va observer ces <code class="code" id="-gtmxdd_393">LiveData</code> et se mettra &agrave; jour automatiquement.</p></li><li class="list__item" id="-gtmxdd_382"><p id="-gtmxdd_395">La logique d'appel (via <code class="code" id="-gtmxdd_396">repository.getNewFact()</code>) et la gestion du succ&egrave;s/&eacute;chec sont enti&egrave;rement contenues ici.</p></li></ul></section><section class="chapter"><h3 id="tape-5-6-mettre-jour-mainactivity" data-toc="tape-5-6-mettre-jour-mainactivity">&Eacute;tape 5 &amp; 6 : Mettre &agrave; jour <code class="code" id="-gtmxdd_405">MainActivity</code></h3><p id="-gtmxdd_398">L'activit&eacute; devient tr&egrave;s simple. Son seul r&ocirc;le est d'observer le ViewModel et de r&eacute;agir aux changements d'&eacute;tat.</p><p id="-gtmxdd_399"><span class="control" id="-gtmxdd_406">Fichier <code class="code" id="-gtmxdd_407">MainActivity.kt</code>:</span></p><div class="code-block" data-lang="kotlin">
package com.example.yourapplication

import androidx.appcompat.app.AppCompatActivity
import android.os.Bundle
import android.view.View
import androidx.activity.viewModels
import com.example.yourapplication.databinding.ActivityMainBinding
import com.example.yourapplication.ui.DogFactViewModel
import dagger.hilt.android.AndroidEntryPoint

@AndroidEntryPoint
class MainActivity : AppCompatActivity() {

    private lateinit var binding: ActivityMainBinding
    
    // Obtenir une instance du ViewModel gérée par Hilt. C'est tout !
    private val viewModel: DogFactViewModel by viewModels()

    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        binding = ActivityMainBinding.inflate(layoutInflater)
        setContentView(binding.root)

        // L'UI écoute les changements du ViewModel
        setupObservers()

        binding.newFactButton.setOnClickListener {
            // L'UI notifie le ViewModel d'une action utilisateur
            viewModel.fetchNewFact()
        }
    }

    private fun setupObservers() {
        viewModel.dogFact.observe(this) { fact -&gt;
            binding.factTextView.text = fact
        }

        viewModel.isLoading.observe(this) { isLoading -&gt;
            binding.progressBar.visibility = if (isLoading) View.VISIBLE else View.GONE
            binding.newFactButton.isEnabled = !isLoading
        }
    }
}
</div><p id="-gtmxdd_401"><span class="control" id="-gtmxdd_408">Explications :</span></p><ul class="list _bullet" id="-gtmxdd_402"><li class="list__item" id="-gtmxdd_409"><p id="-gtmxdd_412"><code class="code" id="-gtmxdd_413">@AndroidEntryPoint</code>: Indique &agrave; Hilt que cette classe peut recevoir des d&eacute;pendances.</p></li><li class="list__item" id="-gtmxdd_410"><p id="-gtmxdd_414"><code class="code" id="-gtmxdd_415">private val viewModel: DogFactViewModel by viewModels()</code>: C'est la seule ligne n&eacute;cessaire pour obtenir une instance du <code class="code" id="-gtmxdd_416">DogFactViewModel</code>. Hilt s'occupe de toute la construction en arri&egrave;re-plan.</p></li><li class="list__item" id="-gtmxdd_411"><p id="-gtmxdd_417"><span class="control" id="-gtmxdd_419">Flux unidirectionnel :</span></p><ol class="list _decimal" id="-gtmxdd_418" type="1"><li class="list__item" id="-gtmxdd_420"><p id="-gtmxdd_423"><span class="control" id="-gtmxdd_424">Action UI :</span> L'utilisateur clique sur le bouton, l'activit&eacute; appelle <code class="code" id="-gtmxdd_425">viewModel.fetchNewFact()</code>.</p></li><li class="list__item" id="-gtmxdd_421"><p id="-gtmxdd_426"><span class="control" id="-gtmxdd_427">Mise &agrave; jour de l'&eacute;tat :</span> Le ViewModel fait son travail et met &agrave; jour ses <code class="code" id="-gtmxdd_428">LiveData</code> (<code class="code" id="-gtmxdd_429">_isLoading</code>, <code class="code" id="-gtmxdd_430">_dogFact</code>).</p></li><li class="list__item" id="-gtmxdd_422"><p id="-gtmxdd_431"><span class="control" id="-gtmxdd_432">Observation :</span> Les <code class="code" id="-gtmxdd_433">observers</code> dans <code class="code" id="-gtmxdd_434">MainActivity</code> d&eacute;tectent les changements et mettent &agrave; jour l'UI en cons&eacute;quence.</p></li></ol></li></ul><p id="-gtmxdd_403">L'application a maintenant une architecture propre, d&eacute;coupl&eacute;e et facilement testable.</p></section></div></div></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="-gtmxdd_435"><span class="control" id="-gtmxdd_444">1. Quel est le principe de l'Inversion de Contr&ocirc;le ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_436"><li class="list__item" id="-gtmxdd_445"><p id="-gtmxdd_449">A) La View contr&ocirc;le le ViewModel.</p></li><li class="list__item" id="-gtmxdd_446"><p id="-gtmxdd_450">B) Une classe ne cr&eacute;e pas ses propres d&eacute;pendances, mais les re&ccedil;oit d'une source externe.</p></li><li class="list__item" id="-gtmxdd_447"><p id="-gtmxdd_451">C) Les d&eacute;pendances sont cr&eacute;&eacute;es au moment de l'ex&eacute;cution plut&ocirc;t qu'&agrave; la compilation.</p></li><li class="list__item" id="-gtmxdd_448"><p id="-gtmxdd_452">D) Le code est ex&eacute;cut&eacute; dans l'ordre inverse de son &eacute;criture.</p></li></ul><p id="-gtmxdd_437"><span class="control" id="-gtmxdd_453">2. Quelle annotation Hilt doit-on mettre sur une Activity ou un Fragment pour activer l'injection ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_438"><li class="list__item" id="-gtmxdd_454"><p id="-gtmxdd_458">A) <code class="code" id="-gtmxdd_459">@HiltActivity</code></p></li><li class="list__item" id="-gtmxdd_455"><p id="-gtmxdd_460">B) <code class="code" id="-gtmxdd_461">@Inject</code></p></li><li class="list__item" id="-gtmxdd_456"><p id="-gtmxdd_462">C) <code class="code" id="-gtmxdd_463">@AndroidEntryPoint</code></p></li><li class="list__item" id="-gtmxdd_457"><p id="-gtmxdd_464">D) <code class="code" id="-gtmxdd_465">@Module</code></p></li></ul><p id="-gtmxdd_439"><span class="control" id="-gtmxdd_466">3. Dans Koin, quelle fonction du DSL utilise-t-on pour d&eacute;clarer une d&eacute;pendance qui doit &ecirc;tre une instance unique ( Singleton) ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_440"><li class="list__item" id="-gtmxdd_467"><p id="-gtmxdd_471">A) <code class="code" id="-gtmxdd_472">factory { ... }</code></p></li><li class="list__item" id="-gtmxdd_468"><p id="-gtmxdd_473">B) <code class="code" id="-gtmxdd_474">singleton { ... }</code></p></li><li class="list__item" id="-gtmxdd_469"><p id="-gtmxdd_475">C) <code class="code" id="-gtmxdd_476">single { ... }</code></p></li><li class="list__item" id="-gtmxdd_470"><p id="-gtmxdd_477">D) <code class="code" id="-gtmxdd_478">viewModel { ... }</code></p></li></ul><p id="-gtmxdd_441"><span class="control" id="-gtmxdd_479">4. Expliquez pourquoi l'injection de d&eacute;pendances rend le code plus facile &agrave; tester. (Question ouverte)</span></p><p id="-gtmxdd_442">**5. Quel est, selon vous, le principal compromis &agrave; faire lorsque l'on choisit Koin plut&ocirc;t que Hilt ? (Question ouverte) **</p><section class="chapter"><div class="collapse"><div class="collapse__title"><h3 id="correction-de-l-auto-valuation" data-toc="correction-de-l-auto-valuation">Correction de l'auto-&eacute;valuation</h3></div><div class="collapse__content"><p id="-gtmxdd_480"><span class="control" id="-gtmxdd_490">1. Quel est le principe de l'Inversion de Contr&ocirc;le ?</span></p><ul class="list _bullet" id="-gtmxdd_481"><li class="list__item" id="-gtmxdd_491"><p id="-gtmxdd_493"><span class="control" id="-gtmxdd_494">R&eacute;ponse : B) Une classe ne cr&eacute;e pas ses propres d&eacute;pendances, mais les re&ccedil;oit d'une source externe.</span></p></li><li class="list__item" id="-gtmxdd_492"><p id="-gtmxdd_495"><span class="control" id="-gtmxdd_496">Justification :</span> C'est la d&eacute;finition m&ecirc;me de l'IoC. Le &quot;contr&ocirc;le&quot; de l'instanciation est invers&eacute;, passant de l'objet lui-m&ecirc;me au framework de DI.</p></li></ul><p id="-gtmxdd_482"><span class="control" id="-gtmxdd_497">2. Quelle annotation Hilt pour activer l'injection dans une Activity/Fragment ?</span></p><ul class="list _bullet" id="-gtmxdd_483"><li class="list__item" id="-gtmxdd_498"><p id="-gtmxdd_500"><span class="control" id="-gtmxdd_501">R&eacute;ponse : C) <code class="code" id="-gtmxdd_502">@AndroidEntryPoint</code></span></p></li><li class="list__item" id="-gtmxdd_499"><p id="-gtmxdd_503"><span class="control" id="-gtmxdd_504">Justification :</span> Cette annotation signale &agrave; Hilt que cette classe Android est un &quot;point d'entr&eacute;e&quot; o&ugrave; des d&eacute;pendances devront &ecirc;tre inject&eacute;es. Hilt g&eacute;n&egrave;re alors le code n&eacute;cessaire pour le faire.</p></li></ul><p id="-gtmxdd_484"><span class="control" id="-gtmxdd_505">3. Quelle fonction Koin pour un Singleton ?</span></p><ul class="list _bullet" id="-gtmxdd_485"><li class="list__item" id="-gtmxdd_506"><p id="-gtmxdd_508"><span class="control" id="-gtmxdd_509">R&eacute;ponse : C) <code class="code" id="-gtmxdd_510">single { ... }</code></span></p></li><li class="list__item" id="-gtmxdd_507"><p id="-gtmxdd_511"><span class="control" id="-gtmxdd_512">Justification :</span> <code class="code" id="-gtmxdd_513">single</code> est la fonction du DSL de Koin pour d&eacute;clarer qu'une seule et m&ecirc;me instance de l'objet doit &ecirc;tre cr&eacute;&eacute;e et r&eacute;utilis&eacute;e pour toute la dur&eacute;e de vie de l'application.</p></li></ul><p id="-gtmxdd_486"><span class="control" id="-gtmxdd_514">4. Pourquoi la DI facilite-t-elle les tests ?</span></p><ul class="list _bullet" id="-gtmxdd_487"><li class="list__item" id="-gtmxdd_515"><p id="-gtmxdd_516"><span class="control" id="-gtmxdd_517">R&eacute;ponse type :</span> Parce qu'elle permet de substituer facilement les vraies d&eacute;pendances par des fausses (des &quot;mocks&quot; ou &quot;fakes&quot;). Par exemple, pour tester un <code class="code" id="-gtmxdd_518">ViewModel</code> qui d&eacute;pend d'un <code class="code" id="-gtmxdd_519">Repository</code>, on peut configurer le framework de DI pour qu'il injecte un <code class="code" id="-gtmxdd_520">FakeRepository</code> qui renvoie des donn&eacute;es en m&eacute;moire au lieu de faire un vrai appel r&eacute;seau ou BDD. Cela rend les tests rapides, fiables et isol&eacute;s, car on ne teste que la logique du <code class="code" id="-gtmxdd_521">ViewModel</code> sans d&eacute;pendre de syst&egrave;mes externes (comme un serveur qui pourrait &ecirc;tre en panne).</p></li></ul><p id="-gtmxdd_488"><span class="control" id="-gtmxdd_522">5. Quel est le principal compromis en choisissant Koin plut&ocirc;t que Hilt ?</span></p><ul class="list _bullet" id="-gtmxdd_489"><li class="list__item" id="-gtmxdd_523"><p id="-gtmxdd_524"><span class="control" id="-gtmxdd_525">R&eacute;ponse type :</span> Le principal compromis est de sacrifier la <span class="control" id="-gtmxdd_526">s&eacute;curit&eacute; &agrave; la compilation</span> pour la <span class="control" id="-gtmxdd_527">simplicit&eacute; de configuration</span>. Avec Koin, si vous oubliez de d&eacute;clarer une d&eacute;pendance dans un module, vous ne le d&eacute;couvrirez qu'&agrave; l' ex&eacute;cution, lorsque l'application plantera. Avec Hilt, le m&ecirc;me oubli provoquerait une erreur de compilation, vous for&ccedil;ant &agrave; corriger le probl&egrave;me avant m&ecirc;me de pouvoir lancer l'application. On &eacute;change donc de la robustesse et de la performance contre une courbe d'apprentissage et une mise en place plus douces.</p></li></ul></div></div></section></section><div class="last-modified">07 novembre 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="007-bonus.html" class="navigation-links__prev">Pour aller plus loin : L'Horizon du D&eacute;veloppeur Android</a><a href="007-02-module-18.html" class="navigation-links__next">Module 18 : Jetpack Compose - Le Futur de l'UI sur Android</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>
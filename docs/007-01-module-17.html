<!DOCTYPE html SYSTEM "about:legacy-compat">
<html lang="en-US" data-preset="contrast" data-primary-color="#307FFF"><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="UTF-8"><meta name="robots" content="noindex"><meta name="built-on" content="2025-10-31T14:22:32.566637"><title>Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android</title><script type="application/json" id="virtual-toc-data">[{"id":"objectifs-p-dagogiques","level":0,"title":"Objectifs pédagogiques","anchor":"#objectifs-p-dagogiques"},{"id":"introduction","level":0,"title":"Introduction","anchor":"#introduction"},{"id":"notions-abord-es","level":0,"title":"Notions abordées","anchor":"#notions-abord-es"},{"id":"le-principe-de-l-injection-de-d-pendances","level":0,"title":"Le principe de l\u0027Injection de Dépendances","anchor":"#le-principe-de-l-injection-de-d-pendances"},{"id":"hilt-la-solution-standard-recommand-e-par-google","level":0,"title":"Hilt : La solution standard recommandée par Google","anchor":"#hilt-la-solution-standard-recommand-e-par-google"},{"id":"koin-l-alternative-pure-kotlin","level":0,"title":"Koin : L\u0027alternative pure Kotlin","anchor":"#koin-l-alternative-pure-kotlin"},{"id":"tp-17-refactoriser-l-application-dog-facts-avec-hilt","level":0,"title":"TP 17 : Refactoriser l\u0027application \"Dog Facts\" avec Hilt","anchor":"#tp-17-refactoriser-l-application-dog-facts-avec-hilt"},{"id":"auto-valuation","level":0,"title":"Auto-évaluation","anchor":"#auto-valuation"},{"id":"correction-de-l-auto-valuation","level":0,"title":"Correction de l\u0027auto-évaluation","anchor":"#correction-de-l-auto-valuation"}]</script><script type="application/json" id="topic-shortcuts"></script><link href="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.css" rel="stylesheet"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="https://jetbrains.com/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="https://jetbrains.com/favicon-32x32.png"><link rel="icon" type="image/png" sizes="16x16" href="https://jetbrains.com/favicon-16x16.png"><meta name="msapplication-TileImage" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-144x144.png"><meta name="msapplication-square70x70logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-70x70.png"><meta name="msapplication-square150x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-150x150.png"><meta name="msapplication-wide310x150logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x150.png"><meta name="msapplication-square310x310logo" content="https://resources.jetbrains.com/storage/ui/favicons/mstile-310x310.png"><meta name="image" content=""><!-- Open Graph --><meta property="og:title" content="Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android"><meta property="og:description" content=""><meta property="og:image" content=""><meta property="og:site_name" content="Android Help"><meta property="og:type" content="website"><meta property="og:locale" content="en_US"><meta property="og:url" content="writerside-documentation/007-01-module-17.html"><!-- End Open Graph --><!-- Twitter Card --><meta name="twitter:card" content="summary_large_image"><meta name="twitter:site" content=""><meta name="twitter:title" content="Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android"><meta name="twitter:description" content=""><meta name="twitter:creator" content=""><meta name="twitter:image:src" content=""><!-- End Twitter Card --><!-- Schema.org WebPage --><script type="application/ld+json">{
    "@context": "http://schema.org",
    "@type": "WebPage",
    "@id": "writerside-documentation/007-01-module-17.html#webpage",
    "url": "writerside-documentation/007-01-module-17.html",
    "name": "Module 17 : Injection de D&eacute;pendances (Hilt &amp; Koin) | Android",
    "description": "",
    "image": "",
    "inLanguage":"en-US"
}</script><!-- End Schema.org --><!-- Schema.org WebSite --><script type="application/ld+json">{
    "@type": "WebSite",
    "@id": "writerside-documentation/#website",
    "url": "writerside-documentation/",
    "name": "Android Help"
}</script><!-- End Schema.org --></head><body data-id="007-01-module-17" data-main-title="Module 17 : Injection de Dépendances (Hilt & Koin)" data-article-props="{&quot;seeAlsoStyle&quot;:&quot;links&quot;}" data-template="article" data-breadcrumbs="007-bonus.md|Pour aller plus loin : L'Horizon du Développeur Android"><div class="wrapper"><main class="panel _main"><header class="panel__header"><div class="container"><h3>Android  Help</h3><div class="panel-trigger"></div></div></header><section class="panel__content"><div class="container"><article class="article" data-shortcut-switcher="inactive"><h1 data-toc="007-01-module-17" id="007-01-module-17.md">Module 17 : Injection de Dépendances (Hilt & Koin)</h1><section class="chapter"><h2 id="objectifs-p-dagogiques" data-toc="objectifs-p-dagogiques">Objectifs p&eacute;dagogiques</h2><p id="-gtmxdd_12">&Agrave; la fin de ce module, vous serez capable de :</p><ul class="list _bullet" id="-gtmxdd_13"><li class="list__item" id="-gtmxdd_14"><p id="-gtmxdd_19">Expliquer le principe de l'Inversion de Contr&ocirc;le et de l'Injection de D&eacute;pendances (DI).</p></li><li class="list__item" id="-gtmxdd_15"><p id="-gtmxdd_20">Comprendre les probl&egrave;mes li&eacute;s &agrave; l'instanciation manuelle des d&eacute;pendances.</p></li><li class="list__item" id="-gtmxdd_16"><p id="-gtmxdd_21">Mettre en place Hilt, la solution de DI recommand&eacute;e par Google, pour injecter des objets.</p></li><li class="list__item" id="-gtmxdd_17"><p id="-gtmxdd_22">Utiliser les annotations Hilt de base (<code class="code" id="-gtmxdd_23">@HiltAndroidApp</code>, <code class="code" id="-gtmxdd_24">@AndroidEntryPoint</code>, <code class="code" id="-gtmxdd_25">@HiltViewModel</code>, <code class="code" id="-gtmxdd_26">@Inject</code>).</p></li><li class="list__item" id="-gtmxdd_18"><p id="-gtmxdd_27">(Alternative) Comprendre les bases de Koin comme solution de DI pure Kotlin.</p></li></ul></section><section class="chapter"><h2 id="introduction" data-toc="introduction">Introduction</h2><p id="-gtmxdd_28">Imaginez que vous construisez une voiture. Jusqu'&agrave; pr&eacute;sent, &agrave; chaque fois que vous aviez besoin d'un moteur, vous le construisiez vous-m&ecirc;me &agrave; partir de z&eacute;ro, directement &agrave; l'int&eacute;rieur du ch&acirc;ssis. Puis vous construisiez la transmission, puis les roues... C'est ce que nous avons fait en &eacute;crivant <code class="code" id="-gtmxdd_30">val dao = AppDatabase.getDatabase(..).noteDao()</code> ou <code class="code" id="-gtmxdd_31">val repository = NoteRepository(dao)</code>. C'est <span class="control" id="-gtmxdd_32">l'objet lui-m&ecirc;me qui cr&eacute;e les composants dont il d&eacute;pend</span>. C'est long, r&eacute;p&eacute;titif, et si le plan du moteur change, vous devez le modifier partout o&ugrave; vous en construisez un.</p><p id="-gtmxdd_29">L' <span class="control" id="-gtmxdd_33">Injection de D&eacute;pendances (DI)</span>, c'est comme avoir une usine de fabrication ultra-moderne. Vous ne construisez plus rien vous-m&ecirc;me. Vous d&eacute;clarez simplement : &quot;Pour cette voiture, j'ai besoin d'un moteur V8 et d'une transmission automatique&quot;. L'usine (le framework de DI) sait exactement comment construire ces composants, comment ils s'assemblent, et vous les livre &quot;cl&eacute;s en main&quot; au bon endroit, au bon moment. Votre travail n'est plus de fabriquer, mais d'assembler des pi&egrave;ces d&eacute;j&agrave; fournies.</p></section><section class="chapter"><h2 id="notions-abord-es" data-toc="notions-abord-es">Notions abord&eacute;es</h2><ul class="list _bullet" id="-gtmxdd_34"><li class="list__item" id="-gtmxdd_36"><p id="-gtmxdd_39">Le principe de l'Injection de D&eacute;pendances</p></li><li class="list__item" id="-gtmxdd_37"><p id="-gtmxdd_40">Hilt : La solution standard recommand&eacute;e par Google</p></li><li class="list__item" id="-gtmxdd_38"><p id="-gtmxdd_41">Koin : L'alternative pure Kotlin</p></li></ul></section><section class="chapter"><h2 id="le-principe-de-l-injection-de-d-pendances" data-toc="le-principe-de-l-injection-de-d-pendances">Le principe de l'Injection de D&eacute;pendances</h2><section class="chapter"><h3 id="introduction-la-notion" data-toc="introduction-la-notion">Introduction &agrave; la notion</h3><p id="-gtmxdd_44">Le c&oelig;ur de la DI est un principe appel&eacute; <span class="control" id="-gtmxdd_45">Inversion de Contr&ocirc;le (Inversion of Control - IoC)</span>. Au lieu que votre objet (<code class="code" id="-gtmxdd_46">ViewModel</code>) contr&ocirc;le la cr&eacute;ation de ses d&eacute;pendances (<code class="code" id="-gtmxdd_47">Repository</code>), vous inversez ce contr&ocirc;le et le d&eacute;l&eacute;guez &agrave; un syst&egrave;me externe (le framework de DI).</p></section><section class="chapter"><h3 id="explication-de-la-notion" data-toc="explication-de-la-notion">Explication de la notion</h3><p id="-gtmxdd_48"><span class="control" id="-gtmxdd_57">Sans DI (ce que nous avons fait jusqu'&agrave; pr&eacute;sent) :</span></p><div class="code-block" data-lang="kotlin">
// Le ViewModel est responsable de la création du Repository.
// C'est un couplage fort.
class NoteViewModel(application: Application) : AndroidViewModel(application) {
    private val repository: NoteRepository

    init {
        val noteDao = AppDatabase.getDatabase(application).noteDao()
        repository = NoteRepository(noteDao) // &lt;-- CRÉATION MANUELLE
    }
}
</div><p id="-gtmxdd_50"><span class="control" id="-gtmxdd_58">Probl&egrave;mes :</span></p><ul class="list _bullet" id="-gtmxdd_51"><li class="list__item" id="-gtmxdd_59"><p id="-gtmxdd_62"><span class="control" id="-gtmxdd_63">Couplage fort :</span> <code class="code" id="-gtmxdd_64">NoteViewModel</code> est &eacute;troitement li&eacute; &agrave; la mani&egrave;re de construire <code class="code" id="-gtmxdd_65">NoteRepository</code>.</p></li><li class="list__item" id="-gtmxdd_60"><p id="-gtmxdd_66"><span class="control" id="-gtmxdd_67">Difficult&eacute; &agrave; tester :</span> Comment tester <code class="code" id="-gtmxdd_68">NoteViewModel</code> sans une vraie base de donn&eacute;es ? On ne peut pas facilement lui fournir un &quot;faux&quot; <code class="code" id="-gtmxdd_69">NoteRepository</code> pour les tests.</p></li><li class="list__item" id="-gtmxdd_61"><p id="-gtmxdd_70"><span class="control" id="-gtmxdd_71">Code r&eacute;p&eacute;titif (<code class="code" id="-gtmxdd_72">Boilerplate</code>) :</span> Vous devez r&eacute;&eacute;crire cette logique d'initialisation partout.</p></li></ul><p id="-gtmxdd_52"><span class="control" id="-gtmxdd_73">Avec DI :</span></p><div class="code-block" data-lang="kotlin">
// Le ViewModel déclare ce dont il a besoin, mais ne le crée pas.
// Hilt fournira le Repository automatiquement.
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository // &lt;-- DÉPENDANCE INJECTÉE
) : ViewModel() {
    // ...
}
</div><p id="-gtmxdd_54"><span class="control" id="-gtmxdd_74">Avantages :</span></p><ul class="list _bullet" id="-gtmxdd_55"><li class="list__item" id="-gtmxdd_75"><p id="-gtmxdd_78"><span class="control" id="-gtmxdd_79">D&eacute;couplage :</span> Le <code class="code" id="-gtmxdd_80">ViewModel</code> ne sait plus comment le <code class="code" id="-gtmxdd_81">Repository</code> est cr&eacute;&eacute;.</p></li><li class="list__item" id="-gtmxdd_76"><p id="-gtmxdd_82"><span class="control" id="-gtmxdd_83">Testabilit&eacute; :</span> En test, on peut facilement demander au framework de DI de fournir une version &quot;mock&quot; (factice) du <code class="code" id="-gtmxdd_84">Repository</code>.</p></li><li class="list__item" id="-gtmxdd_77"><p id="-gtmxdd_85"><span class="control" id="-gtmxdd_86">Centralisation :</span> La logique de cr&eacute;ation des objets est d&eacute;finie &agrave; un seul endroit.</p></li></ul></section></section><section class="chapter"><h2 id="hilt-la-solution-standard-recommand-e-par-google" data-toc="hilt-la-solution-standard-recommand-e-par-google">Hilt : La solution standard recommand&eacute;e par Google</h2><section class="chapter"><h3 id="introduction-la-notion_1" data-toc="introduction-la-notion_1">Introduction &agrave; la notion</h3><p id="-gtmxdd_91">Hilt est la solution d'injection de d&eacute;pendances officielle pour Android. Il est construit sur une base tr&egrave;s puissante ( Dagger) mais la simplifie &eacute;norm&eacute;ment pour le contexte Android. Hilt utilise des annotations et de la g&eacute;n&eacute;ration de code pour cr&eacute;er et &quot;c&acirc;bler&quot; vos d&eacute;pendances &agrave; la <span class="control" id="-gtmxdd_92">compilation</span>. Cela le rend tr&egrave;s performant et s&ucirc;r (une erreur de configuration emp&ecirc;chera votre application de compiler).</p></section><section class="chapter"><h3 id="mise-en-place" data-toc="mise-en-place">Mise en place</h3><section class="procedure-steps"><h3 id="-gtmxdd_93" data-toc="-gtmxdd_93">Configuration de Hilt</h3><ol class="list _decimal" id="-gtmxdd_94" type="1"><li class="list__item" id="-gtmxdd_95"><p id="-gtmxdd_98"><span class="control" id="-gtmxdd_103">Ajouter les plugins Gradle :</span></p><ul class="list _bullet" id="-gtmxdd_99"><li class="list__item" id="-gtmxdd_104"><p id="-gtmxdd_105">Dans <code class="code" id="-gtmxdd_106">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_107">projet</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;) version &quot;2.51&quot; apply false
}
</div><ul class="list _bullet" id="-gtmxdd_101"><li class="list__item" id="-gtmxdd_108"><p id="-gtmxdd_109">Dans <code class="code" id="-gtmxdd_110">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_111">module :app</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
plugins {
    // ...
    id(&quot;com.google.dagger.hilt.android&quot;)
    id(&quot;com.google.devtools.ksp&quot;) // Hilt utilise KSP
}
</div></li><li class="list__item" id="-gtmxdd_96"><p id="-gtmxdd_112"><span class="control" id="-gtmxdd_115">Ajouter les d&eacute;pendances :</span></p><ul class="list _bullet" id="-gtmxdd_113"><li class="list__item" id="-gtmxdd_116"><p id="-gtmxdd_117">Dans <code class="code" id="-gtmxdd_118">build.gradle.kts</code> (niveau <span class="control" id="-gtmxdd_119">module :app</span>) :</p></li></ul><div class="code-block" data-lang="kotlin">
dependencies {
    implementation(&quot;com.google.dagger:hilt-android:2.51&quot;)
    ksp(&quot;com.google.dagger:hilt-compiler:2.51&quot;)
}
</div></li><li class="list__item" id="-gtmxdd_97"><p id="-gtmxdd_120"><span class="control" id="-gtmxdd_123">Annoter la classe Application :</span></p><ul class="list _bullet" id="-gtmxdd_121"><li class="list__item" id="-gtmxdd_124"><p id="-gtmxdd_126">Cr&eacute;ez une classe qui h&eacute;rite de <code class="code" id="-gtmxdd_127">Application</code> et annotez-la avec <code class="code" id="-gtmxdd_128">@HiltAndroidApp</code>.</p></li><li class="list__item" id="-gtmxdd_125"><p id="-gtmxdd_129">N'oubliez pas de la d&eacute;clarer dans votre <code class="code" id="-gtmxdd_130">AndroidManifest.xml</code>.</p></li></ul><div class="code-block" data-lang="kotlin">
// Dans MyApp.kt
@HiltAndroidApp
class MyApp : Application() {}

// Dans AndroidManifest.xml
&lt;application
    android:name=&quot;.MyApp&quot;
    ... &gt;
</div></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><h3 id="utilisation" data-toc="utilisation">Utilisation</h3><ol class="list _decimal" id="-gtmxdd_131" type="1"><li class="list__item" id="-gtmxdd_132"><p id="-gtmxdd_136"><span class="control" id="-gtmxdd_137"><code class="code" id="-gtmxdd_138">@AndroidEntryPoint</code></span>: Annotez vos classes Android (Activities, Fragments) pour que Hilt puisse y injecter des d&eacute;pendances.</p></li><li class="list__item" id="-gtmxdd_133"><p id="-gtmxdd_139"><span class="control" id="-gtmxdd_140"><code class="code" id="-gtmxdd_142">@Inject constructor</code></span>: Annotez le constructeur d'une de vos classes (ex: <code class="code" id="-gtmxdd_141">NoteRepository</code>) pour apprendre &agrave; Hilt comment la cr&eacute;er.</p></li><li class="list__item" id="-gtmxdd_134"><p id="-gtmxdd_143"><span class="control" id="-gtmxdd_144"><code class="code" id="-gtmxdd_146">@HiltViewModel</code></span>: Annotez votre <code class="code" id="-gtmxdd_145">ViewModel</code> pour que Hilt le g&egrave;re. La d&eacute;pendance est ensuite inject&eacute;e via le constructeur.</p></li><li class="list__item" id="-gtmxdd_135"><p id="-gtmxdd_147"><span class="control" id="-gtmxdd_148">Modules Hilt (<code class="code" id="-gtmxdd_149">@Module</code> et <code class="code" id="-gtmxdd_150">@Provides</code>)</span>: Pour les choses que vous ne poss&eacute;dez pas (comme une interface ou une classe d'une biblioth&egrave;que externe comme Room ou Retrofit), vous devez cr&eacute;er un &quot;module&quot; pour apprendre &agrave; Hilt comment les fournir.</p></li></ol></section><section class="chapter"><h3 id="exemple-refactoriser-notre-application-de-notes-avec-hilt" data-toc="exemple-refactoriser-notre-application-de-notes-avec-hilt">Exemple : Refactoriser notre application de notes avec Hilt</h3><p id="-gtmxdd_151"><span class="control" id="-gtmxdd_161">1. <code class="code" id="-gtmxdd_162">AppModule.kt</code> (Le &quot;mode d'emploi&quot; pour Hilt)</span></p><div class="code-block" data-lang="kotlin">
package fr.formation.notes.di

import android.content.Context
import androidx.room.Room
import dagger.Module
import dagger.Provides
import dagger.hilt.InstallIn
import dagger.hilt.android.qualifiers.ApplicationContext
import dagger.hilt.components.SingletonComponent
import fr.formation.notes.data.AppDatabase
import fr.formation.notes.data.NoteDao
import javax.inject.Singleton

@Module
@InstallIn(SingletonComponent::class) // Ces dépendances vivront aussi longtemps que l'app
object AppModule {

    @Provides
    @Singleton // On veut une seule instance de la BDD
    fun provideAppDatabase(@ApplicationContext context: Context): AppDatabase {
        return Room.databaseBuilder(
            context,
            AppDatabase::class.java,
            &quot;notes_database&quot;
        ).build()
    }

    @Provides
    fun provideNoteDao(appDatabase: AppDatabase): NoteDao {
        // Hilt sait comment créer AppDatabase (grâce à la méthode au-dessus),
        // il peut donc l'utiliser pour fournir le NoteDao.
        return appDatabase.noteDao()
    }
}
</div><p id="-gtmxdd_153"><span class="control" id="-gtmxdd_163">2. <code class="code" id="-gtmxdd_164">NoteRepository.kt</code></span></p><div class="code-block" data-lang="kotlin">
// Hilt sait maintenant comment créer NoteDao, il peut donc l'injecter ici.
class NoteRepository @Inject constructor(private val noteDao: NoteDao) {
    // ...
}
</div><p id="-gtmxdd_155"><span class="control" id="-gtmxdd_165">3. <code class="code" id="-gtmxdd_166">NoteViewModel.kt</code></span></p><div class="code-block" data-lang="kotlin">
@HiltViewModel
class NoteViewModel @Inject constructor(
    private val repository: NoteRepository
) : ViewModel() {
    // ...
}
</div><p id="-gtmxdd_157"><span class="control" id="-gtmxdd_167">4. <code class="code" id="-gtmxdd_168">MainActivity.kt</code></span></p><div class="code-block" data-lang="kotlin">
@AndroidEntryPoint // Indique que Hilt doit injecter des dépendances ici
class MainActivity : AppCompatActivity() {
    // L'instanciation est toujours déléguée, mais maintenant gérée par Hilt.
    private val viewModel: NoteViewModel by viewModels()
    // ...
}
</div><p id="-gtmxdd_159">Et voil&agrave; ! Plus aucune cr&eacute;ation manuelle. Le code est propre, d&eacute;coupl&eacute; et testable.</p></section></section><section class="chapter"><h2 id="koin-l-alternative-pure-kotlin" data-toc="koin-l-alternative-pure-kotlin">Koin : L'alternative pure Kotlin</h2><section class="chapter"><h3 id="introduction-la-notion_2" data-toc="introduction-la-notion_2">Introduction &agrave; la notion</h3><p id="-gtmxdd_172">Koin est une autre biblioth&egrave;que de DI tr&egrave;s populaire. Sa philosophie est diff&eacute;rente : elle n'utilise pas de g&eacute;n&eacute;ration de code. C'est un framework pur Kotlin, souvent consid&eacute;r&eacute; comme plus simple &agrave; apprendre et &agrave; configurer. Il fonctionne &agrave; l' <span class="control" id="-gtmxdd_173">ex&eacute;cution</span> (runtime), ce qui le rend moins performant que Hilt mais plus flexible.</p></section><section class="chapter"><h3 id="utilisation_1" data-toc="utilisation_1">Utilisation</h3><ol class="list _decimal" id="-gtmxdd_174" type="1"><li class="list__item" id="-gtmxdd_175"><p id="-gtmxdd_178"><span class="control" id="-gtmxdd_180">D&eacute;finir un module :</span> Vous cr&eacute;ez un &quot;module&quot; Koin o&ugrave; vous d&eacute;crivez comment cr&eacute;er vos objets.</p><div class="code-block" data-lang="kotlin">
val appModule = module {
    // Crée une seule instance (Singleton) de AppDatabase
    single { AppDatabase.getDatabase(androidContext()) }
    // Crée une instance de NoteDao à chaque fois qu'elle est demandée (factory)
    factory { get&lt;AppDatabase&gt;().noteDao() }
    // Crée un singleton du Repository
    single { NoteRepository(get()) } // `get()` résout la dépendance (NoteDao)

    // Déclaration spéciale pour un ViewModel
    viewModel { NoteViewModel(get()) } // `get()` résout NoteRepository
}
</div></li><li class="list__item" id="-gtmxdd_176"><p id="-gtmxdd_181"><span class="control" id="-gtmxdd_183">D&eacute;marrer Koin</span> dans la classe <code class="code" id="-gtmxdd_184">Application</code>:</p><div class="code-block" data-lang="kotlin">
class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()
        startKoin {
            androidContext(this@MyApp)
            modules(appModule)
        }
    }
}
</div></li><li class="list__item" id="-gtmxdd_177"><p id="-gtmxdd_185"><span class="control" id="-gtmxdd_187">Injecter dans les classes Android :</span></p><div class="code-block" data-lang="kotlin">
class MainActivity : AppCompatActivity() {
    // Injection du ViewModel gérée par Koin
    private val viewModel: NoteViewModel by viewModel()
    // ...
}
</div></li></ol></section><section class="chapter"><h3 id="hilt-vs-koin-le-choix" data-toc="hilt-vs-koin-le-choix">Hilt vs. Koin : Le choix</h3><div class="table-wrapper"><table class="wide" id="-gtmxdd_188"><thead><tr class="ijRowHead" id="-gtmxdd_191"><th id="-gtmxdd_197"><p>Caract&eacute;ristique</p></th><th id="-gtmxdd_198"><p>Hilt (Dagger)</p></th><th id="-gtmxdd_199"><p>Koin</p></th></tr></thead><tbody><tr id="-gtmxdd_192"><td id="-gtmxdd_200"><p><span class="control" id="-gtmxdd_203">V&eacute;rification</span></p></td><td id="-gtmxdd_201"><p>&Agrave; la <span class="control" id="-gtmxdd_204">compilation</span> (plus s&ucirc;r)</p></td><td id="-gtmxdd_202"><p>&Agrave; l' <span class="control" id="-gtmxdd_205">ex&eacute;cution</span> (plus de risques d'erreurs)</p></td></tr><tr id="-gtmxdd_193"><td id="-gtmxdd_206"><p><span class="control" id="-gtmxdd_209">Performance</span></p></td><td id="-gtmxdd_207"><p>Plus rapide (pas de r&eacute;flexion au runtime)</p></td><td id="-gtmxdd_208"><p>Moins rapide (utilise la r&eacute;flexion)</p></td></tr><tr id="-gtmxdd_194"><td id="-gtmxdd_210"><p><span class="control" id="-gtmxdd_213">Configuration</span></p></td><td id="-gtmxdd_211"><p>Plus complexe (plugins, annotations...)</p></td><td id="-gtmxdd_212"><p>Tr&egrave;s simple (une d&eacute;pendance, un module)</p></td></tr><tr id="-gtmxdd_195"><td id="-gtmxdd_214"><p><span class="control" id="-gtmxdd_217">&Eacute;cosyst&egrave;me</span></p></td><td id="-gtmxdd_215"><p>Standard de Google, int&eacute;gr&eacute; &agrave; Jetpack</p></td><td id="-gtmxdd_216"><p>Communaut&eacute; forte, pure Kotlin</p></td></tr><tr id="-gtmxdd_196"><td id="-gtmxdd_218"><p><span class="control" id="-gtmxdd_221">&quot;Magie&quot;</span></p></td><td id="-gtmxdd_219"><p>Beaucoup de g&eacute;n&eacute;ration de code &quot;magique&quot;</p></td><td id="-gtmxdd_220"><p>Plus explicite et facile &agrave; d&eacute;boguer</p></td></tr></tbody></table></div><p id="-gtmxdd_189"><span class="control" id="-gtmxdd_222">Conclusion :</span> Pour les d&eacute;butants et les projets o&ugrave; la simplicit&eacute; prime, Koin peut &ecirc;tre un excellent choix. Pour les projets professionnels, &agrave; grande &eacute;chelle et o&ugrave; la performance et la s&eacute;curit&eacute; &agrave; la compilation sont critiques, <span class="control" id="-gtmxdd_223">Hilt est le standard de l'industrie</span>.</p></section></section><section class="chapter"><h2 id="tp-17-refactoriser-l-application-dog-facts-avec-hilt" data-toc="tp-17-refactoriser-l-application-dog-facts-avec-hilt">TP 17 : Refactoriser l'application &quot;Dog Facts&quot; avec Hilt</h2><p id="-gtmxdd_224"><span class="control" id="-gtmxdd_227">Objectif :</span> Reprendre le TP du module 13 et le refactoriser pour utiliser Hilt pour injecter le service Retrofit et le ViewModel.</p><section class="procedure-steps" id="-gtmxdd_225"><ol class="list _decimal" id="-gtmxdd_228" type="1"><li class="list__item" id="-gtmxdd_229"><p id="-gtmxdd_235"><span class="control" id="-gtmxdd_236">Configurez Hilt</span> dans le projet (plugins, d&eacute;pendances, classe <code class="code" id="-gtmxdd_237">Application</code>).</p></li><li class="list__item" id="-gtmxdd_230"><p id="-gtmxdd_238"><span class="control" id="-gtmxdd_240">Cr&eacute;ez un module Hilt</span> (<code class="code" id="-gtmxdd_241">NetworkModule.kt</code>) pour apprendre &agrave; Hilt comment fournir l'instance de Retrofit et l' <code class="code" id="-gtmxdd_242">ApiService</code>.</p><div class="code-block" data-lang="kotlin">
@Module
@InstallIn(SingletonComponent::class)
object NetworkModule {

    @Provides
    @Singleton
    fun provideRetrofit(): Retrofit {
        // ... votre code de création de Retrofit ...
    }

    @Provides
    @Singleton
    fun provideApiService(retrofit: Retrofit): ApiService {
        return retrofit.create(ApiService::class.java)
    }
}
</div></li><li class="list__item" id="-gtmxdd_231"><p id="-gtmxdd_243"><span class="control" id="-gtmxdd_244">Cr&eacute;ez un <code class="code" id="-gtmxdd_248">DogFactRepository</code></span> qui prendra <code class="code" id="-gtmxdd_245">ApiService</code> en d&eacute;pendance (via <code class="code" id="-gtmxdd_246">@Inject constructor</code>). Sa seule m&eacute;thode sera <code class="code" id="-gtmxdd_247">suspend fun getNewFact()</code>.</p></li><li class="list__item" id="-gtmxdd_232"><p id="-gtmxdd_249"><span class="control" id="-gtmxdd_250">Refactorisez votre <code class="code" id="-gtmxdd_253">DogFactViewModel</code></span> pour qu'il soit annot&eacute; avec <code class="code" id="-gtmxdd_251">@HiltViewModel</code> et qu'il injecte le <code class="code" id="-gtmxdd_252">DogFactRepository</code> dans son constructeur. La logique d'appel r&eacute;seau doit maintenant se trouver dans le ViewModel.</p></li><li class="list__item" id="-gtmxdd_233"><p id="-gtmxdd_254"><span class="control" id="-gtmxdd_255">Annotez votre <code class="code" id="-gtmxdd_257">MainActivity</code></span> avec <code class="code" id="-gtmxdd_256">@AndroidEntryPoint</code>.</p></li><li class="list__item" id="-gtmxdd_234"><p id="-gtmxdd_258"><span class="control" id="-gtmxdd_259">Supprimez toute cr&eacute;ation manuelle</span> de <code class="code" id="-gtmxdd_260">RetrofitClient</code>, <code class="code" id="-gtmxdd_261">Repository</code> ou <code class="code" id="-gtmxdd_262">ViewModel</code>. L'Activity doit simplement obtenir le ViewModel via <code class="code" id="-gtmxdd_263">by viewModels()</code>.</p></li></ol><ol class="list _decimal"></ol></section></section><section class="chapter"><h2 id="auto-valuation" data-toc="auto-valuation">Auto-&eacute;valuation</h2><p id="-gtmxdd_264"><span class="control" id="-gtmxdd_272">1. Quel est le principe de l'Inversion de Contr&ocirc;le ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_265"><li class="list__item" id="-gtmxdd_273"><p id="-gtmxdd_277">A) La View contr&ocirc;le le ViewModel.</p></li><li class="list__item" id="-gtmxdd_274"><p id="-gtmxdd_278">B) Une classe ne cr&eacute;e pas ses propres d&eacute;pendances, mais les re&ccedil;oit d'une source externe.</p></li><li class="list__item" id="-gtmxdd_275"><p id="-gtmxdd_279">C) Les d&eacute;pendances sont cr&eacute;&eacute;es au moment de l'ex&eacute;cution plut&ocirc;t qu'&agrave; la compilation.</p></li><li class="list__item" id="-gtmxdd_276"><p id="-gtmxdd_280">D) Le code est ex&eacute;cut&eacute; dans l'ordre inverse de son &eacute;criture.</p></li></ul><p id="-gtmxdd_266"><span class="control" id="-gtmxdd_281">2. Quelle annotation Hilt doit-on mettre sur une Activity ou un Fragment pour activer l'injection ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_267"><li class="list__item" id="-gtmxdd_282"><p id="-gtmxdd_286">A) <code class="code" id="-gtmxdd_287">@HiltActivity</code></p></li><li class="list__item" id="-gtmxdd_283"><p id="-gtmxdd_288">B) <code class="code" id="-gtmxdd_289">@Inject</code></p></li><li class="list__item" id="-gtmxdd_284"><p id="-gtmxdd_290">C) <code class="code" id="-gtmxdd_291">@AndroidEntryPoint</code></p></li><li class="list__item" id="-gtmxdd_285"><p id="-gtmxdd_292">D) <code class="code" id="-gtmxdd_293">@Module</code></p></li></ul><p id="-gtmxdd_268"><span class="control" id="-gtmxdd_294">3. Dans Koin, quelle fonction du DSL utilise-t-on pour d&eacute;clarer une d&eacute;pendance qui doit &ecirc;tre une instance unique ( Singleton) ? (QCM)</span></p><ul class="list _bullet" id="-gtmxdd_269"><li class="list__item" id="-gtmxdd_295"><p id="-gtmxdd_299">A) <code class="code" id="-gtmxdd_300">factory { ... }</code></p></li><li class="list__item" id="-gtmxdd_296"><p id="-gtmxdd_301">B) <code class="code" id="-gtmxdd_302">singleton { ... }</code></p></li><li class="list__item" id="-gtmxdd_297"><p id="-gtmxdd_303">C) <code class="code" id="-gtmxdd_304">single { ... }</code></p></li><li class="list__item" id="-gtmxdd_298"><p id="-gtmxdd_305">D) <code class="code" id="-gtmxdd_306">viewModel { ... }</code></p></li></ul><p id="-gtmxdd_270"><span class="control" id="-gtmxdd_307">4. Expliquez pourquoi l'injection de d&eacute;pendances rend le code plus facile &agrave; tester. (Question ouverte)</span></p><p id="-gtmxdd_271">**5. Quel est, selon vous, le principal compromis &agrave; faire lorsque l'on choisit Koin plut&ocirc;t que Hilt ? (Question ouverte) **</p></section><section class="chapter"><div class="collapse"><div class="collapse__title"><h2 id="correction-de-l-auto-valuation" data-toc="correction-de-l-auto-valuation">Correction de l'auto-&eacute;valuation</h2></div><div class="collapse__content"><p id="-gtmxdd_308"><span class="control" id="-gtmxdd_318">1. Quel est le principe de l'Inversion de Contr&ocirc;le ?</span></p><ul class="list _bullet" id="-gtmxdd_309"><li class="list__item" id="-gtmxdd_319"><p id="-gtmxdd_321"><span class="control" id="-gtmxdd_322">R&eacute;ponse : B) Une classe ne cr&eacute;e pas ses propres d&eacute;pendances, mais les re&ccedil;oit d'une source externe.</span></p></li><li class="list__item" id="-gtmxdd_320"><p id="-gtmxdd_323"><span class="control" id="-gtmxdd_324">Justification :</span> C'est la d&eacute;finition m&ecirc;me de l'IoC. Le &quot;contr&ocirc;le&quot; de l'instanciation est invers&eacute;, passant de l'objet lui-m&ecirc;me au framework de DI.</p></li></ul><p id="-gtmxdd_310"><span class="control" id="-gtmxdd_325">2. Quelle annotation Hilt pour activer l'injection dans une Activity/Fragment ?</span></p><ul class="list _bullet" id="-gtmxdd_311"><li class="list__item" id="-gtmxdd_326"><p id="-gtmxdd_328"><span class="control" id="-gtmxdd_329">R&eacute;ponse : C) <code class="code" id="-gtmxdd_330">@AndroidEntryPoint</code></span></p></li><li class="list__item" id="-gtmxdd_327"><p id="-gtmxdd_331"><span class="control" id="-gtmxdd_332">Justification :</span> Cette annotation signale &agrave; Hilt que cette classe Android est un &quot;point d'entr&eacute;e&quot; o&ugrave; des d&eacute;pendances devront &ecirc;tre inject&eacute;es. Hilt g&eacute;n&egrave;re alors le code n&eacute;cessaire pour le faire.</p></li></ul><p id="-gtmxdd_312"><span class="control" id="-gtmxdd_333">3. Quelle fonction Koin pour un Singleton ?</span></p><ul class="list _bullet" id="-gtmxdd_313"><li class="list__item" id="-gtmxdd_334"><p id="-gtmxdd_336"><span class="control" id="-gtmxdd_337">R&eacute;ponse : C) <code class="code" id="-gtmxdd_338">single { ... }</code></span></p></li><li class="list__item" id="-gtmxdd_335"><p id="-gtmxdd_339"><span class="control" id="-gtmxdd_340">Justification :</span> <code class="code" id="-gtmxdd_341">single</code> est la fonction du DSL de Koin pour d&eacute;clarer qu'une seule et m&ecirc;me instance de l'objet doit &ecirc;tre cr&eacute;&eacute;e et r&eacute;utilis&eacute;e pour toute la dur&eacute;e de vie de l'application.</p></li></ul><p id="-gtmxdd_314"><span class="control" id="-gtmxdd_342">4. Pourquoi la DI facilite-t-elle les tests ?</span></p><ul class="list _bullet" id="-gtmxdd_315"><li class="list__item" id="-gtmxdd_343"><p id="-gtmxdd_344"><span class="control" id="-gtmxdd_345">R&eacute;ponse type :</span> Parce qu'elle permet de substituer facilement les vraies d&eacute;pendances par des fausses (des &quot;mocks&quot; ou &quot;fakes&quot;). Par exemple, pour tester un <code class="code" id="-gtmxdd_346">ViewModel</code> qui d&eacute;pend d'un <code class="code" id="-gtmxdd_347">Repository</code>, on peut configurer le framework de DI pour qu'il injecte un <code class="code" id="-gtmxdd_348">FakeRepository</code> qui renvoie des donn&eacute;es en m&eacute;moire au lieu de faire un vrai appel r&eacute;seau ou BDD. Cela rend les tests rapides, fiables et isol&eacute;s, car on ne teste que la logique du <code class="code" id="-gtmxdd_349">ViewModel</code> sans d&eacute;pendre de syst&egrave;mes externes (comme un serveur qui pourrait &ecirc;tre en panne).</p></li></ul><p id="-gtmxdd_316"><span class="control" id="-gtmxdd_350">5. Quel est le principal compromis en choisissant Koin plut&ocirc;t que Hilt ?</span></p><ul class="list _bullet" id="-gtmxdd_317"><li class="list__item" id="-gtmxdd_351"><p id="-gtmxdd_352"><span class="control" id="-gtmxdd_353">R&eacute;ponse type :</span> Le principal compromis est de sacrifier la <span class="control" id="-gtmxdd_354">s&eacute;curit&eacute; &agrave; la compilation</span> pour la <span class="control" id="-gtmxdd_355">simplicit&eacute; de configuration</span>. Avec Koin, si vous oubliez de d&eacute;clarer une d&eacute;pendance dans un module, vous ne le d&eacute;couvrirez qu'&agrave; l' ex&eacute;cution, lorsque l'application plantera. Avec Hilt, le m&ecirc;me oubli provoquerait une erreur de compilation, vous for&ccedil;ant &agrave; corriger le probl&egrave;me avant m&ecirc;me de pouvoir lancer l'application. On &eacute;change donc de la robustesse et de la performance contre une courbe d'apprentissage et une mise en place plus douces.</p></li></ul></div></div></section><div class="last-modified">30 octobre 2025</div><div data-feedback-placeholder="true"></div><div class="navigation-links _bottom"><a href="007-bonus.html" class="navigation-links__prev">Pour aller plus loin : L'Horizon du D&eacute;veloppeur Android</a><a href="007-02-module-18.html" class="navigation-links__next">Module 18 : Jetpack Compose - Le Futur de l'UI sur Android</a></div></article><div id="disqus_thread"></div></div></section></main></div><script src="https://resources.jetbrains.com/writerside/apidoc/6.22.0-b776/app.js"></script></body></html>